--- src\components\AboutDialog.jsx ---
// src/components/AboutDialog.jsx
import React from "react";
import packageJson from "../../package.json";

const AboutDialog = ({ isOpen, onClose }) => {
  if (!isOpen) return null;

  const appName = "Notes & Tasks App";
  const appVersion = packageJson.version; // Replace this dynamically if needed
  const currentYear = new Date().getFullYear();

  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex justify-center items-center z-50">
      <div className="bg-white dark:bg-zinc-800 p-6 rounded shadow-lg w-96 text-center">
        <h2 className="text-xl font-bold mb-4">About {appName}</h2>
        <div className="space-y-2 mb-6 text-zinc-800 dark:text-zinc-200">
          <p>{appName} &copy; {currentYear}</p>
          <p>Version: {appVersion}</p>
        </div>
        <button
          onClick={onClose}
          className="px-5 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50"
          autoFocus
        >
          Close
        </button>
      </div>
    </div>
  );
};

export default AboutDialog;


--- src\components\AddDialog.jsx ---
// src/components/AddDialog.jsx
import React, { useEffect } from "react"; // Import useEffect

const AddDialog = ({
  isOpen,
  newItemType,
  newItemLabel,
  // showError, // Replaced by errorMessage
  onLabelChange,
  onAdd,
  onCancel,
  errorMessage, // New prop for specific error messages
}) => {
  if (!isOpen) return null;

  const inputRef = React.useRef(null); // Ref for the input element

  // Focus the input when the dialog opens
  useEffect(() => {
    if (isOpen && inputRef.current) {
      inputRef.current.focus();
      // Select text if it's not empty (useful if reopening after error)
      // if (newItemLabel) {
      //   inputRef.current.select();
      // }
    }
  }, [isOpen]); // Dependency array includes isOpen


  const handleSubmit = (e) => {
    e.preventDefault();
    onAdd(); // onAdd should now handle validation feedback
  };

  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex justify-center items-center z-50">
      <div className="bg-white dark:bg-zinc-800 p-6 rounded shadow-lg w-96">
        <h2 className="text-lg font-bold mb-4">Add {newItemType}</h2>
        <form onSubmit={handleSubmit}>
          <input
            ref={inputRef} // Assign ref to the input
            type="text"
            value={newItemLabel}
            onChange={onLabelChange}
            className={`border p-2 rounded w-full mb-2 text-gray-900 dark:text-gray ${errorMessage ? 'border-red-500' : 'border-gray-300 dark:border-gray-600'}`} // Highlight if error
            placeholder={`Enter ${newItemType} name`}
            // autoFocus // Replaced by useEffect focus management
            aria-invalid={!!errorMessage} // Accessibility
            aria-describedby={errorMessage ? "add-error-message" : undefined}
          />
          {/* Display specific error message */}
          {errorMessage && (
            <p id="add-error-message" className="text-red-600 text-sm mb-2">{errorMessage}</p>
          )}
          <div className="mt-4 flex justify-end space-x-2">
            <button
              type="button"
              onClick={onCancel}
              className="px-4 py-2 border rounded dark:border-gray-600 hover:bg-gray-100 dark:hover:bg-gray-700"
            >
              Cancel
            </button>
            <button
              type="submit"
              className="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 disabled:opacity-50"
              // Optionally disable add button if label is empty, though validation handles it
              // disabled={!newItemLabel.trim()}
            >
              Add
            </button>
          </div>
        </form>
      </div>
    </div>
  );
};

export default AddDialog;

--- src\components\ContentEditor.jsx ---
import React, { useState, useEffect } from "react"; // Removed useCallback as it's not used here
import EditorPane from "./EditorPane";

const ContentEditor = ({
  item,
  onSaveContent,
  defaultFontFamily,
  defaultFontSize,
}) => {
  if (!item) {
    console.error(
      "ContentEditor RENDER ERROR: Received null or undefined 'item' prop."
    );
    return (
      <div className="p-4 text-red-500 dark:text-red-400">
        Error: Item data is missing. Cannot display editor.
      </div>
    );
  }

  // Initialize state using the key prop in App.jsx to trigger re-initialization
  // The 'key' prop on ContentEditor in App.jsx (key={selectedItemId}) handles re-initialization.
  // So, useState can directly use item.content.
  const [body, setBody] = useState(item.content ?? "");

  // This useEffect will sync internal 'body' state if the 'item.content' prop changes
  // externally (e.g., due to undo/redo or another operation updating the item).
  useEffect(() => {
    setBody(item.content ?? "");
  }, [item.content, item.id]); // Depend on item.id as well if you want to reset for new item

  const handleChange = (html) => {
    // console.log(`ContentEditor: handleChange for item ${item.id}, new html:`, html.substring(0, 50) + "...");
    setBody(html); // Update internal state for responsiveness
    onSaveContent(item.id, html); // Propagate change up for saving
  };

  return (
    <div className="p-0 flex flex-col flex-grow h-full">
      {" "}
      {/* Changed p-4 to p-0, EditorPane has p-3 */}
      <h2 className="text-xl font-semibold mb-3 px-4 pt-4 break-words text-zinc-800 dark:text-zinc-100">
        {" "}
        {/* Added explicit text colors */}
        {item.label}
      </h2>
      <EditorPane
        html={body} // Use internal body state
        onChange={handleChange}
        defaultFontFamily={defaultFontFamily}
        defaultFontSize={defaultFontSize}
      />
    </div>
  );
};

export default ContentEditor;


--- src\components\ContextMenu.jsx ---
// src/components/ContextMenu.jsx
import React, { useRef, useEffect } from "react";
import { Scissors, Copy, ClipboardPaste, Upload, Download } from "lucide-react";

const ContextMenu = ({
  visible,
  x,
  y,
  item,
  isEmptyArea,
  clipboardItem,
  // Actions
  onAddRootFolder,
  onAddFolder,
  onAddNote,
  onAddTask,
  onRename,
  onDelete,
  onCopy,
  onCut,
  onPaste,
  onDuplicate,
  // Modified Import/Export handlers accepting context
  onExportItem,
  onImportItem,
  onExportTree,
  onImportTree,
  onClose,
}) => {
  const contextMenuRef = useRef(null);

  useEffect(() => {
    const handleOutsideClick = (e) => {
      if (
        visible &&
        contextMenuRef.current &&
        !contextMenuRef.current.contains(e.target)
      ) {
        onClose();
      }
    };
    const handleEscapeKey = (e) => {
      if (e.key === "Escape" && visible) {
        onClose();
      }
    };
    window.addEventListener("mousedown", handleOutsideClick);
    window.addEventListener("keydown", handleEscapeKey);
    return () => {
      window.removeEventListener("mousedown", handleOutsideClick);
      window.removeEventListener("keydown", handleEscapeKey);
    };
  }, [visible, onClose]);

  if (!visible) return null;

  const canPaste = !!clipboardItem;
  const itemPadding = "px-4 py-2.5 sm:py-2"; // Consistent padding for items

  return (
    <div
      ref={contextMenuRef}
      className="fixed z-50 bg-white dark:bg-zinc-800 border border-zinc-500 rounded shadow-md text-base md:text-sm min-w-[180px]" // Adjusted base font size
      style={{ top: y, left: x }}
    >
      {/* --- Actions for Empty Area --- */}
      {isEmptyArea && (
        <>
          <button
            className={`block w-full ${itemPadding} text-left hover:bg-zinc-100 dark:hover:bg-zinc-700 flex items-center gap-2`}
            onClick={() => {
              onAddRootFolder();
              onClose();
            }}
          >
            ➕ Add Root Folder
          </button>
          <hr className="my-1 border-zinc-300 dark:border-zinc-600" />
          {canPaste && (
            <button
              className={`block w-full ${itemPadding} text-left flex items-center gap-2 hover:bg-zinc-100 dark:hover:bg-zinc-700`}
              onClick={() => {
                onPaste();
                onClose();
              }}
              title="Paste item at root"
            >
              <ClipboardPaste className="w-4 h-4" /> Paste
            </button>
          )}
          {canPaste && (
            <hr className="my-1 border-zinc-300 dark:border-zinc-600" />
          )}
          <button
            className={`block w-full ${itemPadding} text-left hover:bg-zinc-100 dark:hover:bg-zinc-700 flex items-center gap-2`}
            onClick={() => {
              onExportTree();
              onClose();
            }}
            title="Export the entire tree"
          >
            <Download className="w-4 h-4" /> Export Full Tree...
          </button>
          <button
            className={`block w-full ${itemPadding} text-left hover:bg-zinc-100 dark:hover:bg-zinc-700 flex items-center gap-2`}
            onClick={() => {
              onImportTree();
              onClose();
            }}
            title="Import items into the tree"
          >
            <Upload className="w-4 h-4" /> Import Full Tree...
          </button>
        </>
      )}

      {/* --- Actions for Existing Item --- */}
      {!isEmptyArea && item && (
        <>
          {item.type === "folder" && (
            <>
              <button
                className={`block w-full ${itemPadding} text-left hover:bg-zinc-100 dark:hover:bg-zinc-700 flex items-center gap-2`}
                onClick={() => {
                  onAddFolder();
                  onClose();
                }}
              >
                ➕ Add Folder Here
              </button>
              <button
                className={`block w-full ${itemPadding} text-left hover:bg-zinc-100 dark:hover:bg-zinc-700 flex items-center gap-2`}
                onClick={() => {
                  onAddNote();
                  onClose();
                }}
              >
                ➕ Add Note Here
              </button>
              <button
                className={`block w-full ${itemPadding} text-left hover:bg-zinc-100 dark:hover:bg-zinc-700 flex items-center gap-2`}
                onClick={() => {
                  onAddTask();
                  onClose();
                }}
              >
                ➕ Add Task Here
              </button>
              <hr className="my-1 border-zinc-300 dark:border-zinc-600" />
            </>
          )}

          <button
            className={`block w-full ${itemPadding} text-left hover:bg-zinc-100 dark:hover:bg-zinc-700 flex items-center gap-2`}
            onClick={() => {
              onCut();
              onClose();
            }}
          >
            <Scissors className="w-4 h-4" /> Cut
          </button>
          <button
            className={`block w-full ${itemPadding} text-left hover:bg-zinc-100 dark:hover:bg-zinc-700 flex items-center gap-2`}
            onClick={() => {
              onCopy();
              onClose();
            }}
          >
            <Copy className="w-4 h-4" /> Copy
          </button>
          <button
            className={`block w-full ${itemPadding} text-left hover:bg-zinc-100 dark:hover:bg-zinc-700 flex items-center gap-2`}
            onClick={() => {
              onDuplicate();
              onClose();
            }}
          >
            <Copy className="w-4 h-4 opacity-0" aria-hidden="true" />
            Duplicate
          </button>
          {item.type === "folder" && canPaste && (
            <button
              className={`block w-full ${itemPadding} text-left flex items-center gap-2 hover:bg-zinc-100 dark:hover:bg-zinc-700`}
              onClick={() => {
                onPaste();
                onClose();
              }}
              title={`Paste item into ${item.label}`}
            >
              <ClipboardPaste className="w-4 h-4" /> Paste Here
            </button>
          )}
          <hr className="my-1 border-zinc-300 dark:border-zinc-600" />

          <button
            className={`block w-full ${itemPadding} text-left hover:bg-zinc-100 dark:hover:bg-zinc-700 flex items-center gap-2`}
            onClick={() => {
              onExportItem();
              onClose();
            }}
            title={`Export '${item.label}' and its contents`}
          >
            <Download className="w-4 h-4" /> Export Item...
          </button>
          {item.type === "folder" && (
            <button
              className={`block w-full ${itemPadding} text-left hover:bg-zinc-100 dark:hover:bg-zinc-700 flex items-center gap-2`}
              onClick={() => {
                onImportItem();
                onClose();
              }}
              title={`Import items under '${item.label}'`}
            >
              <Upload className="w-4 h-4" /> Import under Item...
            </button>
          )}
          <hr className="my-1 border-zinc-300 dark:border-zinc-600" />

          <button
            className={`block w-full ${itemPadding} text-left hover:bg-zinc-100 dark:hover:bg-zinc-700 flex items-center gap-2`}
            onClick={() => {
              onRename();
              onClose();
            }}
          >
            ✏️ Rename
          </button>
          <button
            className={`block w-full ${itemPadding} text-left hover:bg-zinc-100 dark:hover:bg-zinc-700 flex items-center gap-2`}
            onClick={() => {
              onDelete();
              onClose();
            }}
          >
            🗑️ Delete
          </button>
        </>
      )}
    </div>
  );
};

export default ContextMenu;


--- src\components\EditorPane.jsx ---
import React, { useState, useRef, useEffect, useCallback } from "react";
import { useTree } from "../hooks/useTree"; // Assuming this is still needed for direct updates
import {
  Undo,
  Redo,
  Bold as BoldIcon,
  Italic as ItalicIcon,
  Underline as UnderlineIcon,
  Scissors,
  Copy,
  ClipboardPaste,
  TextSelect,
  AlignLeft,
  AlignRight,
  AlignCenter,
  Type,
  Link as LinkIcon,
  Code as CodeIcon,
  SquareCode as CodeBlockIcon,
  TerminalSquare as ShellIcon,
  List as UnorderedListIcon,
  ListOrdered as OrderedListIcon,
} from "lucide-react";

const FONT_FAMILIES = [
  "Arial",
  "Times New Roman",
  "Courier New",
  "Georgia",
  "Verdana",
];
const FONT_SIZES = ["1", "2", "3", "4", "5", "6", "7"];
const URL_REGEX = /(https?:\/\/[^\s]+|www\.[^\s]+)/gi;

const ensureProtocol = (url) => {
  if (!url) return "";
  let fullUrl = url.trim();
  fullUrl = fullUrl.replace(/[.,;!?]*$/, "");
  if (!/^(?:https?|ftp):\/\//i.test(fullUrl)) {
    if (fullUrl.startsWith("www.")) {
      fullUrl = `https://${fullUrl}`;
    } else if (fullUrl.includes(".") && !fullUrl.includes(" ")) {
      fullUrl = `https://${fullUrl}`;
    }
  }
  return fullUrl;
};

const createLinkHtml = (url, text) => {
  const safeUrl = ensureProtocol(url);
  if (safeUrl.startsWith("http") || safeUrl.startsWith("ftp")) {
    const encodedUrl = encodeURI(safeUrl)
      .replace(/"/g, "&quot;")
      .replace(/'/g, "&#39;");
    const safeText =
      text && text.trim().length > 0
        ? text.replace(/</g, "&lt;").replace(/>/g, "&gt;")
        : safeUrl;
    return `<a href="${encodedUrl}" target="_blank" rel="noopener noreferrer">${safeText}</a>`;
  }
  return text && text.trim().length > 0
    ? text.replace(/</g, "&lt;").replace(/>/g, "&gt;")
    : url;
};

const isValidNode = (node) => {
  return node && node.nodeType && document.body.contains(node);
};

const EditorPane = ({
  html = "",
  onChange,
  defaultFontFamily,
  defaultFontSize,
}) => {
  const [fontFamily, setFontFamily] = useState(
    defaultFontFamily || FONT_FAMILIES[0]
  );
  const [fontSize, setFontSize] = useState(defaultFontSize || FONT_SIZES[2]);
  const [isRTL, setIsRTL] = useState(false);
  const editorRef = useRef(null);
  const propUpdateInProgress = useRef(false);
  const [typingTimeout, setTypingTimeout] = useState(null);

  const { updateNoteContent, updateTask, selectedItemId, selectedItem } =
    useTree(); // If direct updates are needed

  const handleContentChangeInternal = useCallback(
    (newHtml) => {
      if (onChange) {
        // onChange is onSaveContent from App.jsx via ContentEditor
        onChange(newHtml);
      }
      // The following direct update from EditorPane might be redundant if ContentEditor already calls useTree functions
      // Consider if this is necessary or if all updates should go through ContentEditor's onSaveContent
      /*
      if (selectedItem && selectedItemId) {
        if (selectedItem.type === "task") {
          updateTask(selectedItemId, { content: newHtml });
        } else {
          updateNoteContent(selectedItemId, newHtml);
        }
      }
      */
    },
    [onChange /*, updateNoteContent, updateTask, selectedItemId, selectedItem*/] // Adjust dependencies if direct update is kept
  );

  useEffect(() => {
    if (editorRef.current && html !== editorRef.current.innerHTML) {
      propUpdateInProgress.current = true;
      const currentScrollTop = editorRef.current.scrollTop;
      const selection = window.getSelection();
      const range =
        selection && selection.rangeCount > 0 ? selection.getRangeAt(0) : null;
      const startContainer = range?.startContainer;
      const startOffset = range?.startOffset;
      editorRef.current.innerHTML = html;
      editorRef.current.scrollTop = currentScrollTop;
      try {
        if (selection && range && isValidNode(startContainer)) {
          const newRange = document.createRange();
          if (
            startContainer.nodeType === Node.TEXT_NODE &&
            startOffset <= startContainer.length
          ) {
            newRange.setStart(startContainer, startOffset);
          } else if (
            startContainer.nodeType === Node.ELEMENT_NODE &&
            startOffset <= startContainer.childNodes.length
          ) {
            newRange.setStart(startContainer, startOffset);
          } else {
            newRange.selectNodeContents(editorRef.current);
            newRange.collapse(false);
          }
          newRange.collapse(true);
          selection.removeAllRanges();
          selection.addRange(newRange);
        } else if (selection) {
          const endRange = document.createRange();
          endRange.selectNodeContents(editorRef.current);
          endRange.collapse(false);
          selection.removeAllRanges();
          selection.addRange(endRange);
          editorRef.current.focus();
        }
      } catch (e) {
        console.error("Error setting cursor position after prop update:", e);
        editorRef.current?.focus();
      }
      requestAnimationFrame(() => {
        propUpdateInProgress.current = false;
      });
    }
  }, [html]);

  useEffect(() => {
    if (editorRef.current) {
      editorRef.current.dir = isRTL ? "rtl" : "ltr";
    }
  }, [isRTL]);

  useEffect(() => {
    const editor = editorRef.current;
    if (!editor) return;
    const handlePasteEvent = (e) => {
      e.preventDefault();
      const text = e.clipboardData.getData("text/plain");
      if (!text) return;
      const linkedHtml = text.replace(URL_REGEX, (match) =>
        createLinkHtml(match, match)
      );
      document.execCommand("insertHTML", false, linkedHtml);
      if (editorRef.current) {
        requestAnimationFrame(() => {
          if (editorRef.current)
            handleContentChangeInternal(editorRef.current.innerHTML);
        });
      }
    };
    editor.addEventListener("paste", handlePasteEvent);
    return () => {
      if (editorRef.current) {
        editorRef.current.removeEventListener("paste", handlePasteEvent);
      }
    };
  }, [handleContentChangeInternal]);

  useEffect(() => {
    const editor = editorRef.current;
    if (!editor) return;
    const handleClick = (event) => {
      let targetElement = event.target;
      while (targetElement && targetElement !== editor) {
        if (targetElement.tagName === "A" && targetElement.href) {
          event.preventDefault();
          window.open(targetElement.href, "_blank", "noopener,noreferrer");
          return;
        }
        targetElement = targetElement.parentNode;
      }
    };
    editor.addEventListener("click", handleClick);
    return () => {
      if (editorRef.current) {
        editorRef.current.removeEventListener("click", handleClick);
      }
    };
  }, []);

  useEffect(() => {
    return () => {
      if (typingTimeout) clearTimeout(typingTimeout);
    };
  }, [typingTimeout]);

  const findEquivalentNode = (root, targetNode) => {
    if (!root || !targetNode) return null;
    if (root === targetNode) return root;
    const walker = document.createTreeWalker(root, NodeFilter.SHOW_ALL);
    let currentNode;
    while ((currentNode = walker.nextNode())) {
      if (
        currentNode.nodeType === targetNode.nodeType &&
        currentNode.nodeValue === targetNode.nodeValue
      ) {
        return currentNode;
      }
    }
    return null;
  };

  const applyCommand = useCallback(
    (cmd, value = null) => {
      editorRef.current?.focus();
      try {
        const success = document.execCommand(cmd, false, value);
        if (!success) console.warn(`execCommand(${cmd}) was not successful.`);
      } catch (error) {
        console.error(`Error executing command ${cmd}:`, error);
      }
      editorRef.current?.focus();
      if (cmd !== "paste") {
        requestAnimationFrame(() => {
          if (editorRef.current)
            handleContentChangeInternal(editorRef.current.innerHTML);
        });
      }
    },
    [handleContentChangeInternal]
  );

  const handleInput = useCallback(
    (event) => {
      if (!editorRef.current || propUpdateInProgress.current) return;
      const newHtml = event.target.innerHTML;
      if (typingTimeout) clearTimeout(typingTimeout);
      setTypingTimeout(
        setTimeout(() => {
          if (!editorRef.current) return;
          const selection = window.getSelection();
          const range =
            selection && selection.rangeCount > 0
              ? selection.getRangeAt(0)
              : null;
          const cursorNode = range?.startContainer;
          const cursorOffset = range?.startOffset;
          const tempDiv = document.createElement("div");
          tempDiv.innerHTML = editorRef.current.innerHTML;
          const textNodes = [];
          const walker = document.createTreeWalker(
            tempDiv,
            NodeFilter.SHOW_TEXT,
            (node) =>
              node.parentNode.nodeName !== "A"
                ? NodeFilter.FILTER_ACCEPT
                : NodeFilter.FILTER_REJECT,
            false
          );
          let node;
          while ((node = walker.nextNode())) {
            textNodes.push(node);
          }
          let madeChanges = false;
          textNodes.forEach((textNode) => {
            const text = textNode.nodeValue;
            const fragment = document.createDocumentFragment();
            let lastIndex = 0;
            const urlMatches = [...text.matchAll(URL_REGEX)];
            urlMatches.forEach((match) => {
              const url = match[0];
              const matchIndex = match.index;
              const isCompleteUrl =
                url.length >= 8 &&
                (matchIndex + url.length === text.length ||
                  /[\s.,;!?)]/.test(text[matchIndex + url.length])) &&
                (matchIndex === 0 || /[\s.,;!?(]/.test(text[matchIndex - 1]));
              if (isCompleteUrl) {
                if (matchIndex > lastIndex) {
                  fragment.appendChild(
                    document.createTextNode(
                      text.substring(lastIndex, matchIndex)
                    )
                  );
                }
                const link = document.createElement("a");
                const safeUrl = ensureProtocol(url);
                link.href = safeUrl;
                link.target = "_blank";
                link.rel = "noopener noreferrer";
                link.textContent = url;
                fragment.appendChild(link);
                lastIndex = matchIndex + url.length;
                madeChanges = true;
              }
            });
            if (lastIndex < text.length) {
              fragment.appendChild(
                document.createTextNode(text.substring(lastIndex))
              );
            }
            if (madeChanges && textNode.parentNode) {
              const liveTextNode = findEquivalentNode(
                editorRef.current,
                textNode
              );
              if (liveTextNode && liveTextNode.parentNode) {
                liveTextNode.parentNode.replaceChild(fragment, liveTextNode);
              } else {
                console.warn(
                  "Could not find equivalent live node for auto-linking."
                );
              }
            }
          });
          if (madeChanges) {
            requestAnimationFrame(() => {
              if (!editorRef.current) return;
              const finalHtml = editorRef.current.innerHTML;
              if (
                range &&
                cursorNode &&
                cursorOffset !== undefined &&
                selection
              ) {
                try {
                  const newRange = document.createRange();
                  const liveCursorNode = findEquivalentNode(
                    editorRef.current,
                    cursorNode
                  );
                  if (liveCursorNode && isValidNode(liveCursorNode)) {
                    const adjustedOffset = Math.min(
                      cursorOffset,
                      liveCursorNode.length || liveCursorNode.childNodes.length
                    );
                    newRange.setStart(liveCursorNode, adjustedOffset);
                    newRange.collapse(true);
                    selection.removeAllRanges();
                    selection.addRange(newRange);
                  } else {
                    newRange.selectNodeContents(editorRef.current);
                    newRange.collapse(false);
                    selection.removeAllRanges();
                    selection.addRange(newRange);
                  }
                } catch (e) {
                  console.error("Auto-link cursor restoration error:", e);
                  const endRange = document.createRange();
                  endRange.selectNodeContents(editorRef.current);
                  endRange.collapse(false);
                  if (selection) {
                    selection.removeAllRanges();
                    selection.addRange(endRange);
                  }
                }
              }
              handleContentChangeInternal(finalHtml);
            });
          }
        }, 700)
      );
      handleContentChangeInternal(newHtml); // Immediate update for responsiveness
    },
    [handleContentChangeInternal, typingTimeout]
  );

  const handlePasteFromClipboard = useCallback(async () => {
    if (!navigator.clipboard?.readText) {
      applyCommand("paste");
      return;
    }
    editorRef.current?.focus();
    try {
      const text = await navigator.clipboard.readText();
      if (text) {
        const escapedText = text
          .replace(/&/g, "&amp;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;")
          .replace(/"/g, "&quot;")
          .replace(/'/g, "&#039;");
        const htmlToInsert = escapedText.replace(/\r?\n/g, "<br>");
        document.execCommand("insertHTML", false, htmlToInsert);
      }
      requestAnimationFrame(() => {
        if (editorRef.current)
          handleContentChangeInternal(editorRef.current.innerHTML);
      });
    } catch (err) {
      console.error("Failed to read clipboard or insert HTML: ", err);
      try {
        const success = document.execCommand("paste", false, null);
        if (success && editorRef.current) {
          requestAnimationFrame(() => {
            if (editorRef.current)
              handleContentChangeInternal(editorRef.current.innerHTML);
          });
        } else if (!success) {
          console.warn("Fallback execCommand('paste') also failed.");
        }
      } catch (execErr) {
        console.error("Error during fallback execCommand('paste'):", execErr);
      }
    }
    editorRef.current?.focus();
  }, [applyCommand, handleContentChangeInternal]);

  const applyBlockStyle = useCallback(
    (tag, className = null) => {
      editorRef.current?.focus();
      const selection = window.getSelection();
      if (!selection || selection.rangeCount === 0) return;
      const range = selection.getRangeAt(0);
      let startBlock = range.startContainer;
      while (
        (startBlock && startBlock.nodeType !== Node.ELEMENT_NODE) ||
        ![
          "P",
          "DIV",
          "LI",
          "H1",
          "H2",
          "H3",
          "H4",
          "H5",
          "H6",
          "BLOCKQUOTE",
          "PRE",
        ].includes(startBlock.nodeName)
      ) {
        if (startBlock === editorRef.current) break;
        startBlock = startBlock.parentNode;
      }
      if (!startBlock || startBlock === editorRef.current) {
        document.execCommand("formatBlock", false, "div");
        const newSelection = window.getSelection();
        if (!newSelection || newSelection.rangeCount === 0) return;
        const newRange = newSelection.getRangeAt(0);
        startBlock = newRange.startContainer;
        while (
          (startBlock && startBlock.nodeType !== Node.ELEMENT_NODE) ||
          ![
            "P",
            "DIV",
            "LI",
            "H1",
            "H2",
            "H3",
            "H4",
            "H5",
            "H6",
            "BLOCKQUOTE",
            "PRE",
          ].includes(startBlock.nodeName)
        ) {
          if (startBlock === editorRef.current) break;
          startBlock = startBlock.parentNode;
        }
        if (!startBlock || startBlock === editorRef.current) {
          console.error("Failed to wrap selection.");
          return;
        }
      }
      const isAlreadyStyled =
        (startBlock.nodeName === tag.toUpperCase() &&
          (!className || startBlock.classList.contains(className))) ||
        (tag === "pre" && startBlock.nodeName === "PRE") ||
        (tag === "div" &&
          className === "shell-command" &&
          startBlock.classList.contains("shell-command"));
      if (isAlreadyStyled) {
        document.execCommand("formatBlock", false, "p");
      } else {
        document.execCommand("formatBlock", false, tag);
        const finalSelection = window.getSelection();
        if (!finalSelection || finalSelection.rangeCount === 0) return;
        let finalRange = finalSelection.getRangeAt(0);
        let newBlock = finalRange.startContainer;
        while (newBlock && newBlock.nodeName !== tag.toUpperCase()) {
          if (newBlock === editorRef.current) break;
          newBlock = newBlock.parentNode;
        }
        if (newBlock && newBlock !== editorRef.current) {
          if (className) {
            newBlock.className = "";
            newBlock.classList.add(className);
          }
          if (tag === "pre") {
            const codeElement = document.createElement("code");
            codeElement.innerHTML = newBlock.innerHTML.replace(
              /<br\s*\/?>/gi,
              "\n"
            );
            newBlock.innerHTML = "";
            newBlock.appendChild(codeElement);
          }
        } else {
          console.warn("Could not reliably find the newly formatted block.");
        }
      }
      requestAnimationFrame(() => {
        if (editorRef.current)
          handleContentChangeInternal(editorRef.current.innerHTML);
      });
    },
    [handleContentChangeInternal]
  );

  const applyInlineStyle = useCallback(
    (tag) => {
      editorRef.current?.focus();
      const command = tag === "code" ? "insertHTML" : null;
      if (command) {
        const selection = window.getSelection();
        if (!selection || selection.rangeCount === 0) return;
        const range = selection.getRangeAt(0);
        const selectedText = range.toString();
        const commonAncestor = range.commonAncestorContainer;
        let isWrapped = false;
        let parentElement = commonAncestor;
        if (parentElement.nodeType !== Node.ELEMENT_NODE)
          parentElement = parentElement.parentNode;
        if (
          parentElement &&
          parentElement.nodeName === tag.toUpperCase() &&
          parentElement.closest(".editor-pane") === editorRef.current
        )
          isWrapped = true;
        else if (
          !range.collapsed &&
          range.startContainer === range.endContainer &&
          range.startContainer.parentNode.nodeName === tag.toUpperCase()
        ) {
          isWrapped = true;
          parentElement = range.startContainer.parentNode;
        }
        if (isWrapped && parentElement) {
          const textContent = parentElement.textContent;
          const textNode = document.createTextNode(textContent);
          parentElement.parentNode.replaceChild(textNode, parentElement);
        } else if (!range.collapsed) {
          const newNodeHtml = `<${tag}>${selectedText
            .replace(/</g, "&lt;")
            .replace(/>/g, "&gt;")}</${tag}>`;
          document.execCommand(command, false, newNodeHtml);
        }
      } else {
        document.execCommand(tag, false, null);
      }
      requestAnimationFrame(() => {
        if (editorRef.current)
          handleContentChangeInternal(editorRef.current.innerHTML);
      });
    },
    [handleContentChangeInternal]
  );

  const handleCreateLink = useCallback(() => {
    editorRef.current?.focus();
    const selection = window.getSelection();
    const selectedText = selection ? selection.toString().trim() : "";
    let url = prompt(
      "Enter the URL:",
      selectedText.startsWith("http") ? selectedText : "https://"
    );
    if (!url) return;
    const fullUrl = ensureProtocol(url);
    if (!fullUrl.startsWith("http") && !fullUrl.startsWith("ftp")) {
      alert("Invalid URL provided.");
      return;
    }
    const linkHtml = createLinkHtml(fullUrl, selectedText || fullUrl);
    document.execCommand("insertHTML", false, linkHtml);
    requestAnimationFrame(() => {
      if (editorRef.current)
        handleContentChangeInternal(editorRef.current.innerHTML);
    });
  }, [handleContentChangeInternal]);

  const toggleDirection = useCallback(() => {
    setIsRTL((prev) => !prev);
  }, []);
  const handleFontChange = useCallback(
    (command, value) => {
      applyCommand(command, value);
      if (command === "fontName") setFontFamily(value);
      if (command === "fontSize") setFontSize(value);
    },
    [applyCommand]
  );

  const buttonBaseClass =
    "p-1.5 sm:p-1 hover:bg-zinc-100 dark:hover:bg-zinc-700 rounded";

  return (
    <div className="flex flex-col flex-grow border rounded bg-transparent dark:border-zinc-700">
      {" "}
      {/* MODIFIED: bg-transparent */}
      <div className="flex flex-wrap items-center gap-x-3 gap-y-1.5 sm:gap-y-1 p-2 border-b border-zinc-200 dark:border-zinc-700 flex-shrink-0">
        {/* ... All Toolbar Buttons ... */}
        <button
          onClick={() => applyCommand("undo")}
          title="Undo"
          className={buttonBaseClass}
        >
          <Undo className="w-5 h-5" />
        </button>
        <button
          onClick={() => applyCommand("redo")}
          title="Redo"
          className={buttonBaseClass}
        >
          <Redo className="w-5 h-5" />
        </button>
        <button
          onClick={() => applyCommand("cut")}
          title="Cut"
          className={buttonBaseClass}
        >
          <Scissors className="w-5 h-5" />
        </button>
        <button
          onClick={() => applyCommand("copy")}
          title="Copy"
          className={buttonBaseClass}
        >
          <Copy className="w-5 h-5" />
        </button>
        <button
          onClick={handlePasteFromClipboard}
          title="Paste"
          className={buttonBaseClass}
        >
          <ClipboardPaste className="w-5 h-5" />
        </button>
        <button
          onClick={() => applyCommand("bold")}
          title="Bold"
          className={buttonBaseClass}
        >
          <BoldIcon className="w-5 h-5" />
        </button>
        <button
          onClick={() => applyCommand("italic")}
          title="Italic"
          className={buttonBaseClass}
        >
          <ItalicIcon className="w-5 h-5" />
        </button>
        <button
          onClick={() => applyCommand("underline")}
          title="Underline"
          className={buttonBaseClass}
        >
          <UnderlineIcon className="w-5 h-5" />
        </button>
        <button
          onClick={() => applyInlineStyle("code")}
          title="Inline Code"
          className={buttonBaseClass}
        >
          <CodeIcon className="w-5 h-5" />
        </button>
        <button
          onClick={() => applyBlockStyle("pre")}
          title="Code Block"
          className={buttonBaseClass}
        >
          <CodeBlockIcon className="w-5 h-5" />
        </button>
        <button
          onClick={() => applyBlockStyle("div", "shell-command")}
          title="Shell Command Block"
          className={buttonBaseClass}
        >
          <ShellIcon className="w-5 h-5" />
        </button>
        <button
          onClick={() => applyCommand("justifyLeft")}
          title="Align Left"
          className={buttonBaseClass}
        >
          <AlignLeft className="w-5 h-5" />
        </button>
        <button
          onClick={() => applyCommand("justifyCenter")}
          title="Align Center"
          className={buttonBaseClass}
        >
          <AlignCenter className="w-5 h-5" />
        </button>
        <button
          onClick={() => applyCommand("justifyRight")}
          title="Align Right"
          className={buttonBaseClass}
        >
          <AlignRight className="w-5 h-5" />
        </button>
        <button
          onClick={() => applyCommand("selectAll")}
          title="Select All"
          className={buttonBaseClass}
        >
          <TextSelect className="w-5 h-5" />
        </button>
        <button
          onClick={() => applyCommand("insertUnorderedList")}
          title="Bulleted List"
          className={buttonBaseClass}
        >
          <UnorderedListIcon className="w-5 h-5" />
        </button>
        <button
          onClick={() => applyCommand("insertOrderedList")}
          title="Numbered List"
          className={buttonBaseClass}
        >
          <OrderedListIcon className="w-5 h-5" />
        </button>
        <button
          onClick={handleCreateLink}
          title="Create Link"
          className={buttonBaseClass}
        >
          <LinkIcon className="w-5 h-5" />
        </button>
        <button
          onClick={toggleDirection}
          title={`Text Direction: ${isRTL ? "RTL" : "LTR"}`}
          className={`p-1.5 sm:p-1 flex items-center ${
            isRTL ? "bg-blue-100 dark:bg-blue-900" : ""
          } hover:bg-zinc-100 dark:hover:bg-zinc-700 rounded`}
        >
          <Type className="w-5 h-5 mr-1" />
          <span>{isRTL ? "RTL" : "LTR"}</span>
        </button>
        <select
          title="Font Family"
          className="p-1.5 sm:p-1 text-base md:text-sm border rounded bg-white dark:bg-zinc-700 border-zinc-300 dark:border-zinc-600 focus:outline-none focus:ring-1 focus:ring-blue-500"
          value={fontFamily}
          onChange={(e) => handleFontChange("fontName", e.target.value)}
        >
          {FONT_FAMILIES.map((f) => (
            <option key={f} value={f}>
              {f}
            </option>
          ))}
        </select>
        <select
          title="Font Size"
          className="p-1.5 sm:p-1 text-base md:text-sm border rounded bg-white dark:bg-zinc-700 border-zinc-300 dark:border-zinc-600 focus:outline-none focus:ring-1 focus:ring-blue-500"
          value={fontSize}
          onChange={(e) => handleFontChange("fontSize", e.target.value)}
        >
          {FONT_SIZES.map((s) => (
            <option key={s} value={s}>
              {s}
            </option>
          ))}
        </select>
      </div>
      <div
        ref={editorRef}
        dir={isRTL ? "rtl" : "ltr"}
        contentEditable
        suppressContentEditableWarning
        onInput={handleInput}
        // MODIFIED: Removed explicit bg-white dark:bg-zinc-900. Inherits from Panel in App.jsx now.
        className="editor-pane prose prose-base md:prose-sm dark:prose-invert max-w-none w-full flex-grow p-3 border-t border-zinc-300 dark:border-zinc-600 rounded-b resize-y overflow-auto focus:outline-none focus:ring-1 focus:ring-blue-500 dark:text-zinc-100 prose-a:text-blue-600 dark:prose-a:text-blue-400 hover:prose-a:underline whitespace-pre-wrap prose-code:before:content-none prose-code:after:content-none prose-pre:bg-inherit dark:prose-pre:bg-inherit prose-pre:p-0"
        role="textbox"
        aria-multiline="true"
      />
    </div>
  );
};

export default EditorPane;


--- src\components\ExportDialog.jsx ---
// src/components/ExportDialog.jsx
import React, { useState, useEffect } from "react";

// Added defaultFormat prop
const ExportDialog = ({ isOpen, context, onClose, onExport, defaultFormat = 'json' }) => {
  // Initialize target based on context, default to 'selected' if no context
  const [target, setTarget] = useState(() => {
    if (context === 'tree') return 'entire';
    if (context === 'item') return 'selected';
    return 'selected';
  });

  // NEW: State for selected format, initialized by prop
  const [format, setFormat] = useState(defaultFormat);

  // Update target if context changes
  useEffect(() => {
     if (isOpen) {
        if (context === 'tree') setTarget('entire');
        else if (context === 'item') setTarget('selected');
        setFormat(defaultFormat); // Reset format on open based on default
     }
  }, [context, isOpen, defaultFormat]); // Add defaultFormat dependency

  if (!isOpen) return null;

  const handleExportClick = () => {
    onExport(target, format); // Pass the currently selected format state
    onClose();
  };

  const showRadioButtons = context !== 'item' && context !== 'tree';
  const dialogTitle = context === 'tree' ? "Export Full Tree"
                      : context === 'item' ? "Export Selected Item"
                      : "Export Options";

  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex justify-center items-center z-50">
      <div className="bg-white dark:bg-zinc-800 p-6 rounded shadow-lg w-80">
        <h2 className="text-xl font-bold mb-4">{dialogTitle}</h2>

        {/* Conditionally render Target Radio Buttons */}
        {showRadioButtons && (
           <div className="mb-4">
             <p className="mb-2 font-medium">Export Target</p>
             <label className="inline-flex items-center mr-4"> <input type="radio" name="exportTarget" value="selected" checked={target === "selected"} onChange={() => setTarget("selected")} /> <span className="ml-2">Selected Item</span> </label>
             <label className="inline-flex items-center"> <input type="radio" name="exportTarget" value="entire" checked={target === "entire"} onChange={() => setTarget("entire")} /> <span className="ml-2">Entire Tree</span> </label>
           </div>
        )}

        {/* Format Selection */}
        <div className="mb-4">
          <p className="mb-2 font-medium">Format</p>
          {/* UPDATED: Use radio buttons for format selection */}
           <div className="flex space-x-4">
               <label className="flex items-center space-x-1 cursor-pointer">
                   <input
                       type="radio"
                       name="exportFormat"
                       value="json"
                       checked={format === 'json'}
                       onChange={(e) => setFormat(e.target.value)}
                       className="form-radio text-blue-600"
                   />
                   <span>JSON</span>
               </label>
               <label className="flex items-center space-x-1 cursor-pointer">
                   <input
                       type="radio"
                       name="exportFormat"
                       value="pdf"
                       checked={format === 'pdf'}
                       onChange={(e) => setFormat(e.target.value)}
                       className="form-radio text-green-600"
                   />
                   <span>PDF</span>
               </label>
           </div>
        </div>

        {/* Export Button */}
        <button
          onClick={handleExportClick} // Call unified handler
          className={`w-full px-4 py-2 text-white rounded mt-4 ${format === 'json' ? 'bg-blue-600 hover:bg-blue-700' : 'bg-green-600 hover:bg-green-700'}`}
        >
          Export as {format.toUpperCase()}
        </button>

        {/* Cancel Button */}
        <button
           onClick={onClose}
           className="w-full px-4 py-2 border dark:border-zinc-600 rounded mt-2 hover:bg-zinc-100 dark:hover:bg-zinc-700"
         >
          Cancel
        </button>
      </div>
    </div>
  );
};

export default ExportDialog;

--- src\components\FolderContents.jsx ---
// src/components/FolderContents.jsx
import React from "react";
import { sortItems } from "../utils/treeUtils";
// --- MODIFICATION: Import MoreVertical icon ---
import { MoreVertical } from "lucide-react";
// --- END MODIFICATION ---

const FolderContents = ({
  folder,
  onSelect,
  handleDragStart,
  handleDragEnter,
  handleDragOver,
  handleDragLeave,
  handleDrop,
  handleDragEnd,
  draggedId,
  dragOverItemId,
  onToggleExpand,
  expandedItems,
  // --- MODIFICATION: Add prop for menu button click ---
  onShowItemMenu,
  // --- END MODIFICATION ---
}) => {
  const hasChildren =
    folder && Array.isArray(folder.children) && folder.children.length > 0;

  if (!hasChildren) {
    return (
      <p className="text-zinc-500 dark:text-zinc-400 italic p-3">
        This folder is empty.
      </p>
    );
  }

  return (
    <div>
      <ul className="space-y-1 sm:space-y-2">
        {sortItems(folder.children).map((child) => {
          const isBeingDragged = child.id === draggedId;
          const isDragOverTarget =
            child.id === dragOverItemId && child.type === "folder";

          return (
            <li
              key={child.id}
              data-testid={`item-${child.id}`}
              // --- MODIFICATION: Added group class for hover effect on button ---
              className={`group relative flex items-center p-3 sm:p-2 hover:bg-zinc-100 dark:hover:bg-zinc-700 rounded cursor-pointer ${
                isBeingDragged ? "opacity-40" : ""
              }`}
              // --- END MODIFICATION ---
              onClick={() => onSelect && onSelect(child.id)} // Keep main click for selection
              role="button"
              tabIndex={0}
              onKeyDown={(e) => {
                if (e.key === "Enter" || e.key === " ") {
                  onSelect && onSelect(child.id);
                }
              }}
              draggable={true}
              onDragStart={(e) =>
                handleDragStart && handleDragStart(e, child.id)
              }
              onDragEnter={(e) =>
                handleDragEnter && handleDragEnter(e, child.id)
              }
              onDragOver={(e) => handleDragOver && handleDragOver(e)}
              onDragLeave={(e) => handleDragLeave && handleDragLeave(e)}
              onDrop={(e) => handleDrop && handleDrop(e, child.id)}
              onDragEnd={(e) => handleDragEnd && handleDragEnd(e)}
              aria-label={`${child.label} (${
                child.type.charAt(0).toUpperCase() + child.type.slice(1)
              })`}
              // --- MODIFICATION: Removed context menu handler from li, moved to button ---
              // onContextMenu={(e) => { ... }}
              // --- END MODIFICATION ---
            >
              {isDragOverTarget && (
                <div
                  data-testid="drag-over-indicator"
                  className="absolute inset-y-0 left-0 right-0 bg-blue-200 dark:bg-blue-800 opacity-30 rounded pointer-events-none z-0"
                  aria-hidden="true"
                ></div>
              )}
              {/* Expand/Collapse Button & Icon Area */}
              <div className="w-6 h-6 flex-shrink-0 flex items-center justify-center mr-1 z-10">
                {child.type === "folder" && onToggleExpand && expandedItems ? (
                  <button
                    onClick={(e) => {
                      e.stopPropagation();
                      onToggleExpand(child.id);
                    }}
                    className={`flex items-center justify-center h-full w-full focus:outline-none text-xs rounded-sm p-0.5 text-zinc-500 dark:text-zinc-400 hover:bg-black/10 dark:hover:bg-white/10`}
                    aria-expanded={!!expandedItems[child.id]}
                    aria-label={
                      expandedItems[child.id]
                        ? `Collapse ${child.label}`
                        : `Expand ${child.label}`
                    }
                    title={expandedItems[child.id] ? `Collapse` : `Expand`}
                  >
                    {" "}
                    {expandedItems[child.id] ? "▾" : "▸"}{" "}
                  </button>
                ) : (
                  <span
                    className="inline-block w-full h-full"
                    aria-hidden="true"
                  >
                    &nbsp;
                  </span>
                )}
              </div>
              {/* Item Icon */}
              <div className="w-6 h-6 flex-shrink-0 flex items-center justify-center mr-1.5 sm:mr-1 z-10">
                {child.type === "folder"
                  ? expandedItems && expandedItems[child.id]
                    ? "📂"
                    : "📁"
                  : child.type === "note"
                  ? "📝"
                  : child.completed
                  ? "✅"
                  : "⬜️"}
              </div>
              {/* Label */}
              <span
                className={`flex-grow truncate z-10 text-base md:text-sm ${
                  child.type === "task" && child.completed
                    ? "line-through text-zinc-500 dark:text-zinc-400"
                    : ""
                }`}
              >
                {child.label}
              </span>
              {/* Type Indicator */}
              <span className="ml-2 text-zinc-500 text-xs sm:text-sm z-10 flex-shrink-0">
                {" "}
                {/* Added flex-shrink-0 */}(
                {child.type.charAt(0).toUpperCase() + child.type.slice(1)})
              </span>
              {/* --- MODIFICATION: Add More Options Button --- */}
              <button
                onClick={(e) => {
                  e.preventDefault();
                  e.stopPropagation(); // Prevent the li's onClick
                  if (onShowItemMenu) {
                    onShowItemMenu(child, e.currentTarget); // Pass item and button element
                  }
                }}
                className={`ml-1 p-1 rounded hover:bg-black/10 dark:hover:bg-white/20 text-zinc-500 dark:text-zinc-400 opacity-0 group-hover:opacity-100 focus:opacity-100 flex-shrink-0`} // Show on hover/focus
                aria-label={`More options for ${child.label}`}
                title="More options"
              >
                <MoreVertical className="w-4 h-4" />
              </button>
              {/* --- END MODIFICATION --- */}
            </li>
          );
        })}
      </ul>
    </div>
  );
};

export default FolderContents;


--- src\components\ImportDialog.jsx ---
// src/components/ImportDialog.jsx
import React, { useState, useEffect } from "react";

const ImportDialog = ({ isOpen, context, onClose, onImport, selectedItem }) => {
  // target will be 'entire' (for full tree) or 'selected' (for under item)
  const [target, setTarget] = useState("entire"); // Default, will be overridden by context
  const [file, setFile] = useState(null);
  const [importing, setImporting] = useState(false);
  const [importMessage, setImportMessage] = useState("");

  useEffect(() => {
    if (isOpen) {
      // Set target based on the context the dialog was opened with
      if (context === "tree") {
        setTarget("entire");
      } else if (context === "item") {
        setTarget("selected");
      } else {
        // Fallback or default if context is not specific
        // e.g., default to 'entire' if no item selected, else 'selected'
        setTarget(selectedItem ? "selected" : "entire");
      }
      setFile(null);
      setImporting(false);
      setImportMessage("");
    }
  }, [context, isOpen, selectedItem]); // Add selectedItem to dependencies

  if (!isOpen) return null;

  const handleFileChange = (e) => {
    if (e.target.files && e.target.files[0]) {
      setFile(e.target.files[0]);
      setImportMessage("");
    } else {
      setFile(null);
    }
  };

  const handleImportClick = async () => {
    if (file) {
      setImporting(true);
      setImportMessage("Importing...");
      const result = await onImport(file, target); // onImport is async handleFileImport from App.jsx
      setImporting(false);
      if (result && result.success) {
        setImportMessage(result.message || "Import successful!");
        // Dialog is closed by App.jsx by calling onClose via setImportDialogState
      } else {
        setImportMessage(result?.error || "Import failed. Please try again.");
      }
    } else {
      setImportMessage("Please select a file first.");
    }
  };

  const isFullTreeImportContext = context === "tree";
  const isImportUnderItemContext = context === "item";

  let dialogTitle = "Import Data";
  if (isFullTreeImportContext) {
    dialogTitle = "Import Tree (Overwrite Existing)";
  } else if (isImportUnderItemContext && selectedItem) {
    dialogTitle = `Import Under "${selectedItem.label}"`;
  }

  return (
    <div className="fixed inset-0 bg-black bg-opacity-60 flex justify-center items-center z-50 p-4 backdrop-blur-sm">
      <div className="bg-white dark:bg-zinc-800 p-6 rounded-lg shadow-xl w-full max-w-md sm:max-w-sm">
        <h2 className="text-lg sm:text-xl font-semibold mb-4 text-zinc-900 dark:text-zinc-100">
          {dialogTitle}
        </h2>

        {/* Only show target options if the context doesn't strictly define it */}
        {/* Or if you always want to allow changing, but pre-select based on context */}
        {!isFullTreeImportContext && ( // Don't show radio buttons if importing full tree via specific menu action
          <div className="mb-4">
            <p className="mb-2 font-medium text-sm text-zinc-700 dark:text-zinc-300">
              Import Target
            </p>
            <div className="space-y-2">
              <label className="flex items-center cursor-pointer p-2 rounded-md hover:bg-zinc-50 dark:hover:bg-zinc-700/50">
                <input
                  type="radio"
                  name="importTarget"
                  value="selected"
                  checked={target === "selected"}
                  onChange={() => {
                    setTarget("selected");
                    setImportMessage("");
                  }}
                  disabled={importing || !selectedItem} // Disable if no item is selected for this option
                  className="form-radio h-4 w-4 text-blue-600 disabled:opacity-50 dark:focus:ring-blue-500 focus:ring-offset-0 dark:bg-zinc-700 dark:border-zinc-600"
                />
                <span
                  className={`ml-2 text-sm text-zinc-700 dark:text-zinc-200 ${
                    !selectedItem ? "opacity-50" : ""
                  }`}
                >
                  Under Selected Item{" "}
                  {selectedItem
                    ? `(${selectedItem.label})`
                    : "(No item selected)"}
                </span>
              </label>
              <label className="flex items-center cursor-pointer p-2 rounded-md hover:bg-zinc-50 dark:hover:bg-zinc-700/50">
                <input
                  type="radio"
                  name="importTarget"
                  value="entire"
                  checked={target === "entire"}
                  onChange={() => {
                    setTarget("entire");
                    setImportMessage("");
                  }}
                  disabled={importing}
                  className="form-radio h-4 w-4 text-blue-600 dark:focus:ring-blue-500 focus:ring-offset-0 dark:bg-zinc-700 dark:border-zinc-600"
                />
                <span className="ml-2 text-sm text-zinc-700 dark:text-zinc-200">
                  Into empty tree or overwrite existing data
                </span>
              </label>
            </div>
          </div>
        )}
        {isFullTreeImportContext && (
          <p className="mb-4 text-sm text-zinc-600 dark:text-zinc-400">
            This will replace your entire current tree with the contents of the
            JSON file.
          </p>
        )}

        <div className="mb-6">
          <label
            className="block mb-2 text-sm font-medium text-zinc-700 dark:text-zinc-300"
            htmlFor="import-file"
          >
            Select JSON File
          </label>
          <input /* ... (input field as before) ... */
            type="file"
            id="import-file"
            accept=".json,application/json"
            onChange={handleFileChange}
            disabled={importing}
            className="block w-full text-sm text-zinc-500 dark:text-zinc-300
                       file:mr-4 file:py-2 file:px-4
                       file:rounded-md file:border-0
                       file:text-sm file:font-semibold
                       file:bg-blue-100 dark:file:bg-zinc-700
                       file:text-blue-700 dark:file:text-blue-300
                       hover:file:bg-blue-200 dark:hover:file:bg-zinc-600
                       focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 dark:focus:ring-offset-zinc-800
                       disabled:opacity-50"
          />
          {file && (
            <p className="mt-1 text-xs text-zinc-500 dark:text-zinc-400">
              Selected: {file.name}
            </p>
          )}
        </div>

        {importMessage && (
          <p
            className={`text-sm mb-4 p-2 rounded ${
              (importMessage.toLowerCase().includes("successful") ||
                importMessage.toLowerCase().includes("saved")) &&
              !importMessage.toLowerCase().includes("failed") &&
              !importMessage.toLowerCase().includes("error")
                ? "bg-green-100 dark:bg-green-900/60 text-green-700 dark:text-green-300 border border-green-300 dark:border-green-700"
                : "bg-red-100 dark:bg-red-900/60 text-red-700 dark:text-red-300 border border-red-300 dark:border-red-700"
            }`}
          >
            {importMessage}
          </p>
        )}

        <div className="mt-6 flex flex-col sm:flex-row-reverse gap-3">
          <button /* ... (Import button as before) ... */
            onClick={handleImportClick}
            disabled={
              !file ||
              importing ||
              (target === "selected" &&
                !selectedItem &&
                !isFullTreeImportContext)
            } // Also disable "Import" if target is "selected" but no item is selected
            className="w-full sm:w-auto inline-flex justify-center rounded-md border border-transparent shadow-sm px-4 py-2 bg-blue-600 text-base font-medium text-white hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 dark:focus:ring-offset-zinc-800 focus:ring-blue-500 sm:text-sm disabled:opacity-50 disabled:cursor-not-allowed"
          >
            {importing ? "Importing..." : "Import"}
          </button>
          <button /* ... (Cancel button as before) ... */
            type="button"
            onClick={onClose}
            disabled={importing}
            className="w-full sm:w-auto inline-flex justify-center rounded-md border border-zinc-300 dark:border-zinc-600 shadow-sm px-4 py-2 bg-white dark:bg-zinc-700 text-base font-medium text-zinc-700 dark:text-zinc-200 hover:bg-zinc-50 dark:hover:bg-zinc-600 focus:outline-none focus:ring-2 focus:ring-offset-2 dark:focus:ring-offset-zinc-800 focus:ring-indigo-500 sm:text-sm disabled:opacity-50"
          >
            Close
          </button>
        </div>
      </div>
    </div>
  );
};

export default ImportDialog;


--- src\components\Login.jsx ---
import React, { useState } from "react";
// import { useNavigate } from 'react-router-dom'; // If using React Router

const API_BASE_URL =
  process.env.VITE_API_BASE_URL || "http://localhost:5001/api";

const Login = ({ onLoginSuccess, onSwitchToRegister }) => {
  // Added onSwitchToRegister
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const [error, setError] = useState("");
  const [isLoading, setIsLoading] = useState(false);
  // const navigate = useNavigate();

  const handleSubmit = async (e) => {
    e.preventDefault();
    setError("");
    setIsLoading(true);
    if (!email || !password) {
      setError("Please enter both email and password.");
      setIsLoading(false);
      return;
    }

    try {
      const response = await fetch(`${API_BASE_URL}/auth/login`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ email, password }),
      });
      const data = await response.json();
      setIsLoading(false);

      if (!response.ok) {
        setError(data.error || "Login failed. Please check your credentials.");
        return;
      }

      if (data.token) {
        localStorage.setItem("userToken", data.token);
        console.log("Login successful, token saved.");
        if (onLoginSuccess) {
          onLoginSuccess(data.user); // Pass user data which might include more than just token
        }
        // if (navigate) navigate('/app'); // Or your main app route
      } else {
        setError("Login failed: No token received from server.");
      }
    } catch (err) {
      setIsLoading(false);
      console.error("Login request error:", err);
      setError("Network error or server issue. Please try again.");
    }
  };

  return (
    <div className="flex items-center justify-center min-h-screen bg-zinc-100 dark:bg-zinc-900">
      <div className="p-8 bg-white dark:bg-zinc-800 rounded-lg shadow-xl w-full max-w-md">
        <h2 className="text-2xl font-semibold text-center text-zinc-900 dark:text-white mb-6">
          Login to Notes & Tasks
        </h2>
        {error && (
          <p className="text-red-500 dark:text-red-400 text-sm mb-4 p-3 bg-red-100 dark:bg-red-900/30 rounded">
            {error}
          </p>
        )}
        <form onSubmit={handleSubmit}>
          <div className="mb-4">
            <label
              className="block text-sm font-medium text-zinc-700 dark:text-zinc-300 mb-1"
              htmlFor="email-login"
            >
              Email Address
            </label>
            <input
              type="email"
              id="email-login"
              value={email}
              onChange={(e) => setEmail(e.target.value)}
              className="w-full px-4 py-2.5 border border-zinc-300 dark:border-zinc-600 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 bg-white dark:bg-zinc-700 text-zinc-900 dark:text-white"
              required
              placeholder="you@example.com"
            />
          </div>
          <div className="mb-6">
            <label
              className="block text-sm font-medium text-zinc-700 dark:text-zinc-300 mb-1"
              htmlFor="password-login"
            >
              Password
            </label>
            <input
              type="password"
              id="password-login"
              value={password}
              onChange={(e) => setPassword(e.target.value)}
              className="w-full px-4 py-2.5 border border-zinc-300 dark:border-zinc-600 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 bg-white dark:bg-zinc-700 text-zinc-900 dark:text-white"
              required
              placeholder="••••••••"
            />
          </div>
          <button
            type="submit"
            disabled={isLoading}
            className="w-full bg-blue-600 text-white py-2.5 px-4 rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 dark:focus:ring-offset-zinc-800 transition duration-150 ease-in-out disabled:opacity-50"
          >
            {isLoading ? "Logging in..." : "Login"}
          </button>
        </form>
        <p className="mt-6 text-sm text-center text-zinc-600 dark:text-zinc-400">
          Don't have an account?{" "}
          <button
            onClick={onSwitchToRegister} // Ensure this calls the prop
            className="font-medium text-blue-600 hover:text-blue-500 dark:text-blue-400 dark:hover:text-blue-300"
          >
            Create one
          </button>
        </p>
      </div>
    </div>
  );
};

export default Login;


--- src\components\Register.jsx ---
import React, { useState } from "react";

const API_BASE_URL =
  process.env.VITE_API_BASE_URL || "http://localhost:5001/api";

const Register = ({ onRegisterSuccess, onSwitchToLogin }) => {
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const [confirmPassword, setConfirmPassword] = useState("");
  const [error, setError] = useState("");
  const [isLoading, setIsLoading] = useState(false);

  const handleSubmit = async (e) => {
    e.preventDefault();
    setError("");
    if (!email || !password || !confirmPassword) {
      setError("Please fill in all fields.");
      return;
    }
    if (password !== confirmPassword) {
      setError("Passwords do not match.");
      return;
    }
    if (password.length < 8) {
      setError("Password must be at least 8 characters long.");
      return;
    }

    setIsLoading(true);
    try {
      const response = await fetch(`${API_BASE_URL}/auth/register`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ email, password }),
      });
      const data = await response.json();
      setIsLoading(false);

      if (!response.ok) {
        setError(data.error || "Registration failed. Please try again.");
        return;
      }
      alert("Registration successful! Please log in.");
      if (onRegisterSuccess) {
        onRegisterSuccess(); // This should switch the view to Login in App.jsx
      }
    } catch (err) {
      setIsLoading(false);
      console.error("Registration request error:", err);
      setError("Network error or server issue. Please try again.");
    }
  };

  return (
    <div className="flex items-center justify-center min-h-screen bg-zinc-100 dark:bg-zinc-900">
      <div className="p-8 bg-white dark:bg-zinc-800 rounded-lg shadow-xl w-full max-w-md">
        <h2 className="text-2xl font-semibold text-center text-zinc-900 dark:text-white mb-6">
          Create Account
        </h2>
        {error && (
          <p className="text-red-500 dark:text-red-400 text-sm mb-4 p-3 bg-red-100 dark:bg-red-900/30 rounded">
            {error}
          </p>
        )}
        <form onSubmit={handleSubmit}>
          <div className="mb-4">
            <label
              className="block text-sm font-medium text-zinc-700 dark:text-zinc-300 mb-1"
              htmlFor="email-register"
            >
              Email Address
            </label>
            <input
              type="email"
              id="email-register"
              value={email}
              onChange={(e) => setEmail(e.target.value)}
              className="w-full px-4 py-2.5 border border-zinc-300 dark:border-zinc-600 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 bg-white dark:bg-zinc-700 text-zinc-900 dark:text-white"
              required
              placeholder="you@example.com"
            />
          </div>
          <div className="mb-4">
            <label
              className="block text-sm font-medium text-zinc-700 dark:text-zinc-300 mb-1"
              htmlFor="password-register"
            >
              Password (min. 8 characters)
            </label>
            <input
              type="password"
              id="password-register"
              value={password}
              onChange={(e) => setPassword(e.target.value)}
              className="w-full px-4 py-2.5 border border-zinc-300 dark:border-zinc-600 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 bg-white dark:bg-zinc-700 text-zinc-900 dark:text-white"
              required
              placeholder="••••••••"
            />
          </div>
          <div className="mb-6">
            <label
              className="block text-sm font-medium text-zinc-700 dark:text-zinc-300 mb-1"
              htmlFor="confirmPassword-register"
            >
              Confirm Password
            </label>
            <input
              type="password"
              id="confirmPassword-register"
              value={confirmPassword}
              onChange={(e) => setConfirmPassword(e.target.value)}
              className="w-full px-4 py-2.5 border border-zinc-300 dark:border-zinc-600 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 bg-white dark:bg-zinc-700 text-zinc-900 dark:text-white"
              required
              placeholder="••••••••"
            />
          </div>
          <button
            type="submit"
            disabled={isLoading}
            className="w-full bg-green-600 text-white py-2.5 px-4 rounded-md hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-offset-2 dark:focus:ring-offset-zinc-800 transition duration-150 ease-in-out disabled:opacity-50"
          >
            {isLoading ? "Registering..." : "Create Account"}
          </button>
        </form>
        <p className="mt-6 text-sm text-center text-zinc-600 dark:text-zinc-400">
          Already have an account?{" "}
          <button
            onClick={onSwitchToLogin} // Ensure this calls the prop
            className="font-medium text-blue-600 hover:text-blue-500 dark:text-blue-400 dark:hover:text-blue-300"
          >
            Log In
          </button>
        </p>
      </div>
    </div>
  );
};

export default Register;


--- src\components\RenameDialog.jsx ---
import React from "react";

const RenameDialog = ({
  isOpen,
  item,
  newName,
  onNameChange,
  onRename,
  onCancel,
}) => {
  if (!isOpen) return null;

  const handleSubmit = (e) => {
    e.preventDefault();
    onRename();
  };

  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex justify-center items-center z-50">
      <div className="bg-white dark:bg-zinc-800 p-6 rounded shadow-lg w-96">
        <h2 className="text-lg font-bold mb-4">Rename “{item.label}”</h2>
        <form onSubmit={handleSubmit}>
          <input
            type="text"
            value={newName}
            onChange={onNameChange}
            className="border p-2 rounded w-full mb-2 text-gray-900 dark:text-gray"
            autoFocus
          />
          <div className="mt-4 flex justify-end space-x-2">
            <button
              type="button"
              onClick={onCancel}
              className="px-4 py-2 border rounded"
            >
              Cancel
            </button>
            <button
              type="submit"
              className="px-4 py-2 bg-blue-600 text-white rounded"
            >
              Rename
            </button>
          </div>
        </form>
      </div>
    </div>
  );
};

export default RenameDialog;


--- src\components\SearchPanel.jsx ---
import React, { useState, useEffect } from "react";
import { matchText } from "../utils/searchUtils";

const defaultOptions = { caseSensitive: false, wholeWord: false, useRegex: false };

export default function SearchPanel({ searchItems, initialQuery = "", options = defaultOptions, onClose }) {
  const [query, setQuery] = useState(initialQuery);
  const [opts, setOpts] = useState(options);
  const [results, setResults] = useState([]);
  const [preview, setPreview] = useState(null);

  useEffect(() => {
    if (query) {
      const hits = searchItems(query, opts);
      setResults(hits);
      setPreview(hits[0] || null);
    } else {
      setResults([]);
      setPreview(null);
    }
  }, [query, opts, searchItems]);

  
  if (results.length === 0) {
    return (
      <div className="flex flex-col h-full bg-zinc-900 border-l border-zinc-700">
        <div className="p-4 text-sm text-zinc-400">No matches found.</div>
      </div>
    );
  }

return (
    <div className="flex flex-col h-full bg-zinc-900 border-l border-zinc-700 shadow-lg">
      {/* Header */}
      <div className="p-2 border-b border-zinc-700 flex items-center space-x-2">
        <input
          autoFocus
          type="text"
          className="flex-1 px-2 py-1 rounded bg-zinc-800 focus:outline-none"
          placeholder="Search..."
          value={query}
          onChange={(e) => setQuery(e.target.value)}
        />
        <button
          onClick={onClose}
          className="px-2 py-1 rounded hover:bg-zinc-700"
          title="Close"
        >
          ✕
        </button>
      </div>
      {/* Options */}
      <div className="p-2 flex space-x-3 text-xs">
        <label className="flex items-center space-x-1">
          <input
            type="checkbox"
            checked={opts.caseSensitive}
            onChange={(e) => setOpts({ ...opts, caseSensitive: e.target.checked })}
          />
          <span>Case</span>
        </label>
        <label className="flex items-center space-x-1">
          <input
            type="checkbox"
            checked={opts.wholeWord}
            onChange={(e) => setOpts({ ...opts, wholeWord: e.target.checked })}
          />
          <span>Whole</span>
        </label>
        <label className="flex items-center space-x-1">
          <input
            type="checkbox"
            checked={opts.useRegex}
            onChange={(e) => setOpts({ ...opts, useRegex: e.target.checked })}
          />
          <span>RegEx</span>
        </label>
      </div>
      {/* Body */}
      <div className="flex flex-1 overflow-hidden">
        {/* Results list */}
        <div className="w-44 border-r border-zinc-800 overflow-auto">
          {results.map((item) => (
            <div
              key={item.id}
              onClick={() => setPreview(item)}
              className="p-2 cursor-pointer border-b border-zinc-800 hover:bg-zinc-800"
            >
              <p className="text-sm font-medium">{item.label || item.title}</p>
            </div>
          ))}
        </div>
        {/* Preview */}
        <div className="flex-1 overflow-auto p-4">
          {preview ? (
            <>
              <h3 className="text-lg font-semibold mb-2">{preview.label || preview.title}</h3>
              <pre className="whitespace-pre-wrap">{preview.content || preview.text}</pre>
            </>
          ) : (
            <p className="text-zinc-500">Select a result to preview.</p>
          )}
        </div>
      </div>
    </div>
  );
}

--- src\components\SearchResultsPane.jsx ---
// src/components/SearchResultsPane.jsx
import React from "react";
import { CaseSensitive, WholeWord, Regex, XCircle } from "lucide-react";

function escapeRegex(string) {
  return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}

const HighlightMultiple = ({ text, query, opts }) => {
  if (!text || !query) {
    return <>{text}</>;
  }
  const flags = opts.caseSensitive ? "g" : "gi";
  let regex;
  try {
    const pattern = opts.useRegex ? query : escapeRegex(query);
    regex = new RegExp(pattern, flags);
  } catch (e) {
    return <>{text}</>;
  }
  const parts = [];
  let lastIndex = 0;
  let match;
  const textToSearch = String(text);

  while ((match = regex.exec(textToSearch)) !== null) {
    if (match.index > lastIndex) {
      parts.push(textToSearch.substring(lastIndex, match.index));
    }
    parts.push(
      <strong
        key={match.index + "-" + match[0]}
        className="text-yellow-600 dark:text-yellow-300 bg-yellow-200 dark:bg-yellow-700/50 px-0.5 rounded"
      >
        {match[0]}
      </strong>
    );
    lastIndex = regex.lastIndex;
    if (opts.useRegex && match[0].length === 0) {
      regex.lastIndex++;
    }
  }
  if (lastIndex < textToSearch.length) {
    parts.push(textToSearch.substring(lastIndex));
  }
  return parts.length > 0 ? <>{parts}</> : <>{text}</>;
};

const HighlightedPathLabel = ({ pathString, itemLabel, highlightDetails }) => {
  if (!pathString) return <>{pathString}</>;
  const pathParts = pathString.split(" / ");
  const labelFromPath = pathParts[pathParts.length - 1];

  if (
    labelFromPath === itemLabel &&
    highlightDetails &&
    highlightDetails.start !== -1 &&
    highlightDetails.end > highlightDetails.start
  ) {
    const prefix = itemLabel.substring(0, highlightDetails.start);
    const highlighted = itemLabel.substring(
      highlightDetails.start,
      highlightDetails.end
    );
    const suffix = itemLabel.substring(highlightDetails.end);

    pathParts[pathParts.length - 1] = (
      <>
        {prefix}
        <strong className="text-purple-500 dark:text-purple-400 bg-purple-200 dark:bg-purple-700/30 px-0.5 rounded">
          {highlighted}
        </strong>
        {suffix}
      </>
    );
    return (
      <>
        {pathParts.map((part, index) => (
          <React.Fragment key={index}>
            {index > 0 && " / "}
            {part}
          </React.Fragment>
        ))}
      </>
    );
  }
  return <>{pathString}</>;
};

export default function SearchResultsPane({
  query,
  onQueryChange,
  results,
  onSelectResult,
  onClose,
  opts,
  setOpts,
  headerHeightClass,
}) {
  const isRegexEnabledCurrently = false;
  return (
    <div className="flex flex-col h-full bg-zinc-50 dark:bg-zinc-900 text-zinc-900 dark:text-zinc-100">
      <div
        className={`flex items-center space-x-2 p-2 sm:p-3 border-b border-zinc-200 dark:border-zinc-700 flex-shrink-0 ${headerHeightClass}`} // Adjusted padding
      >
        <input
          id="global-search-input"
          className="flex-1 px-3 sm:px-2 py-2 sm:py-1 rounded bg-white dark:bg-zinc-800 focus:outline-none text-zinc-900 dark:text-zinc-100 text-base md:text-sm" // Adjusted padding and font
          placeholder="Search..."
          value={query || ""}
          onChange={(e) => onQueryChange(e.target.value)}
          autoFocus
        />
        <div className="flex items-center space-x-1">
          {[
            {
              key: "caseSensitive",
              label: "Case Sensitive",
              Icon: CaseSensitive,
              disabled: false,
            },
            {
              key: "wholeWord",
              label: "Whole Word",
              Icon: WholeWord,
              disabled: false,
            },
            {
              key: "useRegex",
              label: "Use Regular Expression",
              Icon: Regex,
              disabled: !isRegexEnabledCurrently,
            },
          ].map(({ key, label, Icon, disabled }) => (
            <button
              key={key}
              title={disabled ? `${label} (Disabled)` : label}
              onClick={() => {
                if (!disabled) {
                  setOpts((prevOpts) => ({
                    ...prevOpts,
                    [key]: !prevOpts[key],
                  }));
                }
              }}
              disabled={disabled}
              className={`p-1.5 sm:p-1 rounded focus:outline-none focus:ring-1 focus:ring-blue-500 ${
                // Adjusted padding
                disabled
                  ? "text-zinc-400 dark:text-zinc-600 cursor-not-allowed"
                  : opts[key]
                  ? "bg-blue-600 text-white hover:bg-blue-700"
                  : "text-zinc-500 dark:text-zinc-400 hover:bg-zinc-200 dark:hover:bg-zinc-700"
              }`}
            >
              <Icon className="w-5 h-5 sm:w-4 sm:h-4" />{" "}
              {/* Adjusted icon size */}
            </button>
          ))}
        </div>
        <button
          onClick={onClose}
          className="p-1.5 sm:p-1 text-zinc-500 dark:text-zinc-400 hover:bg-zinc-200 dark:hover:bg-zinc-700 rounded" // Adjusted padding
          title="Close Search"
        >
          <XCircle className="w-5 h-5" />
        </button>
      </div>

      <div className="flex-1 overflow-auto">
        {results.length === 0 ? (
          <p className="p-4 text-sm text-zinc-500 dark:text-zinc-400">
            No matches.
          </p>
        ) : (
          results.map(
            (
              item // item is a processed search result entry
            ) => (
              <div
                key={item.id}
                onClick={() => onSelectResult(item)}
                className="p-3 sm:p-2 border-b border-zinc-200 dark:border-zinc-800 cursor-pointer hover:bg-zinc-100 dark:hover:bg-zinc-700" // Increased base padding
              >
                {item.path && (
                  <p
                    className="text-xs text-zinc-500 dark:text-zinc-400 truncate mb-0.5"
                    title={item.path}
                  >
                    <HighlightedPathLabel
                      pathString={item.path}
                      itemLabel={item.label || item.title || ""}
                      highlightDetails={item.pathLabelHighlight}
                    />
                    {item.matchSource && (
                      <span
                        className={`text-xs ml-1 ${
                          item.matchSource === "label"
                            ? "text-blue-400"
                            : item.matchSource === "content"
                            ? "text-green-400"
                            : "text-gray-400"
                        }`}
                      >
                        ({item.matchSource})
                      </span>
                    )}
                  </p>
                )}

                <p
                  className="text-base md:text-sm text-zinc-800 dark:text-zinc-200 max-w-full truncate" // Adjusted font size
                  title={item.displaySnippetText}
                >
                  <HighlightMultiple
                    text={item.displaySnippetText}
                    query={query}
                    opts={opts}
                  />
                </p>
              </div>
            )
          )
        )}
      </div>
    </div>
  );
}


--- src\components\SettingsDialog.jsx ---
// src/components/SettingsDialog.jsx
//
// Complete, uncommented implementation with safe fallback when no SettingsProvider
//
import React, { useState, useMemo } from 'react';
import { X, Search, RotateCcw, AlertTriangle } from 'lucide-react';
import {
  useSettings,
  defaultSettings,
  themeOptions,
  sortOrderOptions,
  exportFormatOptions,
  editorFontFamilyOptions,
  editorFontSizeOptions,
} from '../contexts/SettingsContext';

/** Convert a setting's current value to human‑readable text for search */
function valueLabel(setting, settings) {
  const v = settings[setting.id];
  if (typeof v === 'boolean') return v ? 'Enabled' : 'Disabled';
  if (setting.options) {
    const o = setting.options.find(opt => opt.value === v);
    if (o) return o.label;
  }
  if (setting.id === 'defaultExportFormat') {
    const o = exportFormatOptions.find(opt => opt.value === v);
    if (o) return o.label;
  }
  return String(v);
}

export default function SettingsDialog({ isOpen, onClose }) {
  // Safe context attempt
  let context;
  try {
    context = useSettings();
  } catch {
    // Render tests mount without provider – use defaults & no‑ops
    context = {
      settings: defaultSettings,
      updateSetting: () => {},
      resetSettings: () => {},
      resetApplicationData: () => {},
    };
  }
  const { settings, updateSetting, resetSettings, resetApplicationData } = context;
  const [search, setSearch] = useState('');

  /** All setting descriptors (memoised) */
  const all = useMemo(() => [
    {
      id: 'theme',
      label: 'Theme',
      desc: 'Select the application color scheme.',
      options: themeOptions,
      control: (
        <select
          id="theme"
          data-testid="setting-theme-select"
          value={settings.theme}
          onChange={e => updateSetting('theme', e.target.value)}
          className="p-1 border rounded bg-white dark:bg-zinc-700 dark:border-zinc-600 min-w-[150px]"
        >
          {themeOptions.map(o => <option key={o.value} value={o.value}>{o.label}</option>)}
        </select>
      ),
    },
    {
      id: 'autoExpandNewFolders',
      label: 'Auto‑Expand New Folders',
      desc: 'Automatically expand parent folders when adding a new item.',
      control: (
        <input
          id="autoExpandNewFolders"
          type="checkbox"
          data-testid="setting-autoexpand-checkbox"
          checked={settings.autoExpandNewFolders}
          onChange={e => updateSetting('autoExpandNewFolders', e.target.checked)}
          className="form-checkbox h-5 w-5 text-blue-600 rounded cursor-pointer"
        />
      ),
    },
    {
      id: 'editorFontFamily',
      label: 'Default Editor Font',
      desc: 'Default font family for the note/task editor.',
      options: editorFontFamilyOptions,
      control: (
        <select
          id="editorFontFamily"
          data-testid="setting-fontfamily-select"
          value={settings.editorFontFamily}
          onChange={e => updateSetting('editorFontFamily', e.target.value)}
          className="p-1 border rounded bg-white dark:bg-zinc-700 dark:border-zinc-600 min-w-[150px]"
        >
          {editorFontFamilyOptions.map(o => <option key={o.value} value={o.value}>{o.label}</option>)}
        </select>
      ),
    },
    {
      id: 'editorFontSize',
      label: 'Default Editor Font Size',
      desc: 'Default font size for the note/task editor.',
      options: editorFontSizeOptions,
      control: (
        <select
          id="editorFontSize"
          data-testid="setting-fontsize-select"
          value={settings.editorFontSize}
          onChange={e => updateSetting('editorFontSize', e.target.value)}
          className="p-1 border rounded bg-white dark:bg-zinc-700 dark:border-zinc-600 min-w-[150px]"
        >
          {editorFontSizeOptions.map(o => <option key={o.value} value={o.value}>{o.label}</option>)}
        </select>
      ),
    },
    {
      id: 'defaultExportFormat',
      label: 'Default Export Format',
      desc: 'Pre‑selected format when exporting items or the tree.',
      control: (
        <div className="flex space-x-3">
          {exportFormatOptions.map(o => (
            <label key={o.value} className="flex items-center space-x-1 cursor-pointer">
              <input
                type="radio"
                name="defaultExportFormat"
                data-testid={`setting-exportformat-${o.value}`}
                value={o.value}
                checked={settings.defaultExportFormat === o.value}
                onChange={e => updateSetting('defaultExportFormat', e.target.value)}
                className="form-radio text-blue-600 cursor-pointer"
              />
              <span>{o.label}</span>
            </label>
          ))}
        </div>
      ),
    },
    {
      id: 'resetSettings',
      label: 'Reset Settings',
      desc: 'Reset all settings to their default values.',
      control: (
        <button
          type="button"
          data-testid="setting-resetsettings-button"
          onClick={() => {
            if (window.confirm('Reset all settings to default?')) resetSettings();
          }}
          className="px-3 py-1 text-sm bg-yellow-500 text-white rounded hover:bg-yellow-600 flex items-center"
        >
          <RotateCcw className="w-4 h-4 mr-1" /> Reset
        </button>
      ),
    },
    {
      id: 'resetData',
      label: 'Reset Application Data',
      desc: 'WARNING: Deletes all notes, tasks, folders, and resets settings.',
      control: (
        <button
          type="button"
          data-testid="setting-resetdata-button"
          onClick={() => {
            if (window.confirm('WARNING: This will permanently delete all data and reset settings.')) {
              resetApplicationData();
            }
          }}
          className="px-3 py-1 text-sm bg-red-600 text-white rounded hover:bg-red-700 flex items-center"
        >
          <AlertTriangle className="w-4 h-4 mr-1" /> Reset All Data
        </button>
      ),
    },
  ], [settings, updateSetting, resetSettings, resetApplicationData]);

  const filtered = useMemo(() => {
    if (!search) return all;
    const term = search.toLowerCase();
    return all.filter(s =>
      s.label.toLowerCase().includes(term) ||
      s.desc.toLowerCase().includes(term) ||
      valueLabel(s, settings).toLowerCase().includes(term),
    );
  }, [all, search, settings]);

  if (!isOpen) return null;

  return (
    <div
      data-testid="settings-dialog-overlay"
      className="fixed inset-0 bg-black bg-opacity-60 flex justify-center items-center z-50 p-4 backdrop-blur-sm transition-opacity duration-200"
    >
      <div
        data-testid="settings-dialog-content"
        className="bg-white dark:bg-zinc-800 p-5 rounded-lg shadow-xl w-full max-w-3xl max-h-[85vh] flex flex-col border border-zinc-200 dark:border-zinc-700"
      >
        {/* Header */}
        <div className="flex justify-between items-center mb-4 border-b pb-3 dark:border-zinc-600 flex-shrink-0">
          <h2 className="text-xl font-semibold">Settings</h2>
          <button
            aria-label="Close Settings"
            data-testid="settings-close-button-header"
            onClick={onClose}
            className="p-1 rounded-full text-zinc-500 dark:text-zinc-400 hover:bg-zinc-200 dark:hover:bg-zinc-700"
          >
            <X className="w-5 h-5" />
          </button>
        </div>

        {/* Search */}
        <div className="mb-4 relative flex-shrink-0">
          <input
            data-testid="settings-search-input"
            type="text"
            placeholder="Search settings..."
            value={search}
            onChange={e => setSearch(e.target.value)}
            className="w-full p-2 pl-10 border rounded dark:bg-zinc-700 dark:border-zinc-600 focus:outline-none focus:ring-2 focus:ring-blue-500"
          />
          <Search className="w-5 h-5 text-zinc-400 absolute left-3 top-1/2 transform -translate-y-1/2 pointer-events-none" />
        </div>

        {/* Settings list */}
        <div className="flex-grow overflow-y-auto space-y-5 pr-2 -mr-2 custom-scrollbar">
          {filtered.length ? filtered.map(s => (
            <div
              key={s.id}
              data-testid={`setting-row-${s.id}`}
              className="flex flex-col sm:flex-row sm:items-start sm:justify-between pb-4 border-b border-zinc-200 dark:border-zinc-700 last:border-b-0"
            >
              <div className="mb-2 sm:mb-0 sm:mr-4 flex-1">
                <label htmlFor={s.id} className={`font-medium block ${s.id === 'resetData' ? 'text-red-600 dark:text-red-400' : ''}`}>
                  {s.label}
                </label>
                <p className="text-sm text-zinc-600 dark:text-zinc-400">{s.desc}</p>
              </div>
              <div className="flex-shrink-0 flex items-center mt-1 sm:mt-0">
                {React.cloneElement(s.control, { id: s.id })}
              </div>
            </div>
          )) : (
            <p
              data-testid="settings-no-results"
              className="text-zinc-500 dark:text-zinc-400 text-center py-6"
            >
              No settings found matching your search.
            </p>
          )}
        </div>

        {/* Footer */}
        <div className="mt-6 pt-4 border-t dark:border-zinc-600 flex justify-end flex-shrink-0">
          <button
            data-testid="settings-close-button-footer"
            onClick={onClose}
            className="px-5 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500"
          >
            Close
          </button>
        </div>
      </div>
    </div>
  );
}

--- src\components\TaskItem.jsx ---
import React from "react";

const TaskItem = ({ task, onToggle }) => {
  if (!task) return null;
  return (
    <div className="p-4">
      <label className="flex items-center space-x-2">
        <input
          type="checkbox"
          checked={task.completed}
          onChange={e => onToggle(e.target.checked)}
          className="form-checkbox"
        />
        <span className={task.completed ? "line-through text-gray-500" : ""}>
          {task.label}
        </span>
      </label>
    </div>
  );
};

export default TaskItem;

--- src\components\Tree.jsx ---
// src/components/Tree.jsx
import React, { useRef, useState, useEffect, useCallback } from "react";
import { sortItems, isSelfOrDescendant } from "../utils/treeUtils";
// --- MODIFICATION: Import MoreVertical icon ---
import { MoreVertical } from "lucide-react";
// --- END MODIFICATION ---

const INDENT_SIZE = 16; // Pixels for indentation per level

const Tree = ({
  items,
  selectedItemId,
  onSelect,
  inlineRenameId,
  inlineRenameValue,
  setInlineRenameValue,
  onAttemptRename,
  cancelInlineRename,
  expandedFolders,
  onToggleExpand,
  onToggleTask,
  draggedId,
  onDragStart,
  onDrop,
  onNativeContextMenu, // Renamed prop for clarity
  onShowItemMenu, // --- MODIFICATION: New prop for button click ---
  onRename,
  onDragEnd,
  uiError,
  setUiError,
}) => {
  const navRef = useRef(null);
  const [dragOverId, setDragOverId] = useState(null);
  const [localRenameError, setLocalRenameError] = useState("");

  // --- Callbacks (refocusTree, getVisible, findParent, handleKeyDown, drag/drop handlers) remain the same ---
  const refocusTree = useCallback(() => {
    /* ... */ requestAnimationFrame(() => {
      navRef.current?.focus({ preventScroll: true });
    });
  }, []);
  useEffect(() => {
    if (inlineRenameId) {
      setLocalRenameError("");
    }
  }, [uiError, inlineRenameId]);
  const getVisible = useCallback((nodes, currentExpandedFolders) => {
    let out = [];
    const currentNodes = Array.isArray(nodes) ? nodes : [];
    sortItems(currentNodes).forEach((it) => {
      out.push(it);
      if (
        it.type === "folder" &&
        Array.isArray(it.children) &&
        currentExpandedFolders[it.id]
      ) {
        out = out.concat(getVisible(it.children, currentExpandedFolders));
      }
    });
    return out;
  }, []);
  const findParent = useCallback((nodes, childId, parent = null) => {
    const currentNodes = Array.isArray(nodes) ? nodes : [];
    for (const it of currentNodes) {
      if (it.id === childId) return parent;
      if (Array.isArray(it.children)) {
        const p = findParent(it.children, childId, it);
        if (p) return p;
      }
    }
    return null;
  }, []);
  const handleKeyDown = useCallback(
    (e) => {
      /* ... keyboard nav logic ... */
      const activeElement = document.activeElement;
      const isRenameInputFocused = activeElement?.closest(
        `li[data-item-id="${inlineRenameId}"] input`
      );
      if (isRenameInputFocused) {
        if (e.key === "Enter" || e.key === "Escape") {
          /* handled by input */
        }
        return;
      }
      const treeNav = navRef.current;
      const isTreeAreaFocused =
        treeNav &&
        (treeNav === activeElement ||
          treeNav.contains(activeElement) ||
          activeElement === document.body);
      if (
        !isTreeAreaFocused &&
        !(activeElement === document.body && selectedItemId)
      )
        return;
      const visibleItems = getVisible(items, expandedFolders);
      const currentIndex = visibleItems.findIndex(
        (it) => it.id === selectedItemId
      );
      const currentItem =
        currentIndex !== -1 ? visibleItems[currentIndex] : null;
      let nextItemId = null;
      switch (e.key) {
        case "ArrowDown":
          e.preventDefault();
          if (visibleItems.length === 0) break;
          nextItemId =
            currentIndex < visibleItems.length - 1
              ? visibleItems[currentIndex + 1].id
              : currentIndex === -1
              ? visibleItems[0].id
              : null;
          if (nextItemId) onSelect(nextItemId);
          break;
        case "ArrowUp":
          e.preventDefault();
          if (visibleItems.length === 0) break;
          nextItemId =
            currentIndex > 0
              ? visibleItems[currentIndex - 1].id
              : currentIndex === -1
              ? visibleItems[0].id
              : null;
          if (nextItemId) onSelect(nextItemId);
          break;
        case "ArrowRight":
          e.preventDefault();
          if (currentItem) {
            if (currentItem.type === "folder") {
              if (!expandedFolders[currentItem.id]) {
                onToggleExpand(currentItem.id, true);
              } else if (
                Array.isArray(currentItem.children) &&
                currentItem.children.length > 0
              ) {
                const sortedChildren = sortItems(currentItem.children);
                if (sortedChildren.length > 0) {
                  onSelect(sortedChildren[0].id);
                }
              }
            }
          }
          break;
        case "ArrowLeft":
          e.preventDefault();
          if (currentItem) {
            if (
              currentItem.type === "folder" &&
              expandedFolders[currentItem.id]
            ) {
              onToggleExpand(currentItem.id, false);
            } else {
              const parent = findParent(items, currentItem.id);
              if (parent) {
                onSelect(parent.id);
              }
            }
          }
          break;
        case " ":
          e.preventDefault();
          if (currentItem && currentItem.type === "task") {
            onToggleTask(currentItem.id, !currentItem.completed);
          }
          break;
        default:
          break;
      }
    },
    [
      items,
      expandedFolders,
      selectedItemId,
      onSelect,
      onToggleExpand,
      findParent,
      getVisible,
      onToggleTask,
      inlineRenameId,
    ]
  );
  const handleDragOver = useCallback(
    (e, item) => {
      e.preventDefault();
      e.stopPropagation();
      if (
        item?.type === "folder" &&
        item.id !== draggedId &&
        !isSelfOrDescendant(items, draggedId, item.id)
      ) {
        setDragOverId(item.id);
      } else {
        setDragOverId(null);
      }
    },
    [draggedId, items]
  );
  const handleDragLeave = useCallback((e) => {
    e.preventDefault();
    e.stopPropagation();
    setDragOverId(null);
  }, []);
  const handleItemDrop = useCallback(
    (e, targetItem) => {
      e.preventDefault();
      e.stopPropagation();
      const currentDragOverId = dragOverId;
      setDragOverId(null);
      if (
        targetItem?.id === currentDragOverId &&
        targetItem?.type === "folder" &&
        targetItem.id !== draggedId
      ) {
        onDrop(targetItem.id);
      }
    },
    [dragOverId, draggedId, onDrop]
  );

  const renderItems = useCallback(
    (nodes, depth = 0) => (
      <ul className="list-none p-0 m-0">
        {(Array.isArray(nodes) ? sortItems(nodes) : []).map((item) => {
          const isBeingDragged = item.id === draggedId;
          const isDragOverTarget = item.id === dragOverId;
          const isSelected = item.id === selectedItemId;
          const isRenaming = item.id === inlineRenameId;
          const hasError = isRenaming && (localRenameError || uiError);

          return (
            <li
              key={item.id}
              data-item-id={item.id}
              className={`group relative text-base md:text-sm ${
                isBeingDragged ? "opacity-40" : ""
              }`}
              draggable={!isRenaming}
              onDragStart={(e) => {
                if (isRenaming) {
                  e.preventDefault();
                  return;
                }
                e.stopPropagation();
                onDragStart(e, item.id);
              }}
              onDragOver={(e) => handleDragOver(e, item)}
              onDragLeave={handleDragLeave}
              onDrop={(e) => handleItemDrop(e, item)}
              onDragEnd={onDragEnd}
              // --- MODIFICATION: Use onNativeContextMenu for actual right-click/long-press ---
              onContextMenu={(e) => {
                if (draggedId || isRenaming) {
                  e.preventDefault();
                  return;
                }
                e.preventDefault();
                e.stopPropagation();
                onSelect(item.id); // Select item first
                onNativeContextMenu(e, item); // Call original handler
              }}
              // --- END MODIFICATION ---
            >
              {isDragOverTarget && (
                <div
                  data-testid="drag-over-indicator"
                  className="absolute inset-y-0 left-0 right-0 bg-blue-200 dark:bg-blue-800 opacity-30 rounded pointer-events-none z-0"
                  aria-hidden="true"
                ></div>
              )}
              <div
                className={`relative z-10 flex items-center cursor-pointer rounded py-1.5 sm:py-1 pr-1 ${
                  // Reduced right padding to make space for button
                  isSelected && !isRenaming
                    ? "bg-blue-600 text-white"
                    : "hover:bg-zinc-100 dark:hover:bg-zinc-700"
                } ${
                  isDragOverTarget
                    ? "bg-blue-100 dark:bg-blue-900 text-zinc-900 dark:text-zinc-100"
                    : ""
                }`}
                style={{
                  paddingLeft: `${depth * INDENT_SIZE + (depth > 0 ? 4 : 0)}px`,
                }}
                onClick={(e) => {
                  if (isBeingDragged || isRenaming) return;
                  e.stopPropagation();
                  onSelect(item.id);
                }}
                // Removed onDoubleClick here, rely on context menu or F2
                // onDoubleClick={(e) => { if (isRenaming) return; e.stopPropagation(); onRename(item); }}
              >
                {/* Expand/Collapse Button & Icon Area */}
                <div className="w-6 h-6 flex-shrink-0 flex items-center justify-center mr-1">
                  {item.type === "folder" ? (
                    <button
                      onClick={(e) => {
                        e.stopPropagation();
                        onToggleExpand(item.id);
                      }}
                      className={`flex items-center justify-center h-full w-full focus:outline-none text-xs rounded-sm p-0.5 ${
                        isSelected && !isRenaming
                          ? "text-white"
                          : "text-zinc-500 dark:text-zinc-400"
                      } hover:bg-black/10 dark:hover:bg-white/10`}
                      aria-expanded={!!expandedFolders[item.id]}
                      aria-label={
                        expandedFolders[item.id]
                          ? `Collapse ${item.label}`
                          : `Expand ${item.label}`
                      }
                      title={expandedFolders[item.id] ? `Collapse` : `Expand`}
                    >
                      {" "}
                      {expandedFolders[item.id] ? "▾" : "▸"}{" "}
                    </button>
                  ) : (
                    <span
                      className="inline-block w-full h-full"
                      aria-hidden="true"
                    >
                      &nbsp;
                    </span>
                  )}
                </div>
                {/* Item Icon */}
                <div className="w-6 h-6 flex-shrink-0 flex items-center justify-center mr-1.5 sm:mr-1">
                  {item.type === "folder" ? (
                    <span
                      className={`${
                        !item.children || item.children.length === 0
                          ? "opacity-50"
                          : ""
                      }`}
                      aria-hidden="true"
                    >
                      {" "}
                      {expandedFolders[item.id] ? "📂" : "📁"}{" "}
                    </span>
                  ) : item.type === "task" ? (
                    <button
                      onClick={(e) => {
                        e.stopPropagation();
                        onToggleTask(item.id, !item.completed);
                      }}
                      className="focus:outline-none flex items-center justify-center cursor-pointer w-full h-full"
                      aria-checked={!!item.completed}
                      role="checkbox"
                      aria-label={`Mark task ${item.label} as ${
                        item.completed ? "incomplete" : "complete"
                      }`}
                      title={`Mark as ${
                        item.completed ? "incomplete" : "complete"
                      }`}
                    >
                      {" "}
                      {item.completed ? "✅" : "⬜️"}{" "}
                    </button>
                  ) : (
                    <span aria-hidden="true">📝</span>
                  )}
                </div>
                {/* Label or Rename Input */}
                <div
                  className="flex-1 truncate relative"
                  style={{ minWidth: 0 }}
                >
                  {isRenaming ? (
                    <>
                      <input
                        type="text"
                        className={`w-full bg-white dark:bg-zinc-800 outline-none border px-1 py-0.5 text-base md:text-sm rounded ${
                          hasError
                            ? "border-red-500 text-red-700 dark:text-red-400"
                            : "border-blue-400 text-black dark:text-white"
                        }`}
                        value={inlineRenameValue}
                        onChange={(e) => {
                          setInlineRenameValue(e.target.value);
                          setLocalRenameError("");
                          if (setUiError) setUiError("");
                        }}
                        onClick={(e) => e.stopPropagation()}
                        onBlur={() => {
                          if (onAttemptRename) onAttemptRename();
                        }}
                        onKeyDown={(e) => {
                          if (e.key === "Enter") {
                            e.preventDefault();
                            if (onAttemptRename) onAttemptRename();
                          } else if (e.key === "Escape") {
                            e.preventDefault();
                            cancelInlineRename();
                            refocusTree();
                          }
                        }}
                        autoFocus
                        onFocus={(e) => e.target.select()}
                        aria-invalid={!!hasError}
                        aria-describedby={
                          hasError ? `${item.id}-rename-error` : undefined
                        }
                      />
                      {hasError && (
                        <span
                          id={`${item.id}-rename-error`}
                          className="absolute left-1 top-full mt-0.5 text-xs text-red-600 dark:text-red-400 whitespace-normal z-10"
                        >
                          {" "}
                          {localRenameError || uiError}{" "}
                        </span>
                      )}
                    </>
                  ) : (
                    <span
                      className={` ${
                        item.type === "task" && item.completed
                          ? "line-through text-zinc-500 dark:text-zinc-400"
                          : ""
                      }`}
                    >
                      {" "}
                      {item.label}{" "}
                    </span>
                  )}
                </div>
                {/* --- MODIFICATION: Add More Options Button --- */}
                <button
                  onClick={(e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    onSelect(item.id); // Ensure item is selected
                    onShowItemMenu(item, e.currentTarget); // Pass item and button element
                  }}
                  className={`ml-1 p-1 rounded hover:bg-black/10 dark:hover:bg-white/20 ${
                    isSelected && !isRenaming
                      ? "text-white"
                      : "text-zinc-500 dark:text-zinc-400"
                  } opacity-0 group-hover:opacity-100 focus:opacity-100`} // Show on hover/focus
                  aria-label={`More options for ${item.label}`}
                  title="More options"
                >
                  <MoreVertical className="w-4 h-4" />
                </button>
                {/* --- END MODIFICATION --- */}
              </div>
              {item.type === "folder" &&
                Array.isArray(item.children) &&
                expandedFolders[item.id] &&
                renderItems(item.children, depth + 1)}
            </li>
          );
        })}
      </ul>
    ),
    [
      items,
      selectedItemId,
      inlineRenameId,
      inlineRenameValue,
      expandedFolders,
      draggedId,
      dragOverId,
      onSelect,
      setInlineRenameValue,
      onAttemptRename,
      cancelInlineRename,
      onToggleExpand,
      onToggleTask,
      onDragStart,
      handleDragOver,
      handleDragLeave,
      handleItemDrop,
      onDrop,
      onNativeContextMenu,
      onShowItemMenu, // Use updated/new props
      onRename,
      onDragEnd,
      refocusTree,
      uiError,
      setUiError,
      localRenameError,
    ]
  );

  return (
    <nav
      ref={navRef}
      className="overflow-auto h-full p-1.5 sm:p-1 text-zinc-900 dark:text-zinc-100 focus:outline-none focus:ring-2 focus:ring-blue-400 rounded"
      tabIndex={0}
      onKeyDown={handleKeyDown}
      // --- MODIFICATION: Use onNativeContextMenu for empty area ---
      onContextMenu={(e) => {
        if (!draggedId && !inlineRenameId && e.target === navRef.current) {
          e.preventDefault();
          onSelect(null);
          onNativeContextMenu(e, null); // Show empty area menu via original handler
        } else if (draggedId || inlineRenameId) {
          e.preventDefault();
        }
      }}
      // --- END MODIFICATION ---
      aria-label="Notes and Tasks Tree"
    >
      {renderItems(items)}
    </nav>
  );
};

export default Tree;


--- src\contexts\SettingsContext.jsx ---
// src/contexts/SettingsContext.jsx
import React, { createContext, useState, useEffect, useContext, useCallback } from 'react';

const SETTINGS_STORAGE_KEY = "appSettings";

// Define default settings
export const defaultSettings = {
  theme: 'system', // 'light', 'dark', 'system'
  defaultSortOrder: 'foldersFirstAlpha', // e.g., 'foldersFirstAlpha', 'alpha', 'typeAlpha'
  autoExpandNewFolders: true,
  editorFontFamily: 'Arial',
  editorFontSize: '3', // Corresponds to HTML <font size="..."> values
  defaultExportFormat: 'json', // 'json', 'pdf'
};

// --- Available Options (for selects etc.) ---
export const themeOptions = [
    { value: 'system', label: 'System Default' },
    { value: 'light', label: 'Light' },
    { value: 'dark', label: 'Dark' },
];

export const sortOrderOptions = [
    { value: 'foldersFirstAlpha', label: 'Folders First, then Alpha' },
    { value: 'alpha', label: 'Alphabetical' },
    { value: 'typeAlpha', label: 'By Type, then Alpha' },
];

export const exportFormatOptions = [
    { value: 'json', label: 'JSON' },
    { value: 'pdf', label: 'PDF' },
];

// FONT_FAMILIES and FONT_SIZES from EditorPane (consider moving to a shared constants file)
export const editorFontFamilyOptions = [ "Arial", "Times New Roman", "Courier New", "Georgia", "Verdana" ].map(f => ({ value: f, label: f }));
export const editorFontSizeOptions = ["1", "2", "3", "4", "5", "6", "7"].map(s => ({ value: s, label: `Size ${s}` }));
// --- End Options ---


// Create the context
export const SettingsContext = createContext();

// Create the provider component
export const SettingsProvider = ({ children }) => {
  const [settings, setSettings] = useState(() => {
    try {
      const stored = localStorage.getItem(SETTINGS_STORAGE_KEY);
      const parsed = stored ? JSON.parse(stored) : defaultSettings;
      // Ensure all keys from defaultSettings exist
      return { ...defaultSettings, ...parsed };
    } catch (error) {
      console.error("Failed to load settings from localStorage:", error);
      return defaultSettings;
    }
  });

  // Apply theme and persist settings on change
  useEffect(() => {
    try {
      // Apply theme
      const root = window.document.documentElement;
      root.classList.remove('light', 'dark');
      let effectiveTheme = settings.theme;
      if (settings.theme === 'system') {
        effectiveTheme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
      }
      root.classList.add(effectiveTheme);

      // Persist settings
      localStorage.setItem(SETTINGS_STORAGE_KEY, JSON.stringify(settings));
    } catch (error) {
      console.error("Failed to save settings or apply theme:", error);
    }
  }, [settings]);

  // Function to update a specific setting
  const updateSetting = useCallback((key, value) => {
    setSettings(prev => ({ ...prev, [key]: value }));
  }, []);

  // Function to reset all settings to default
  const resetSettings = useCallback(() => {
    if (window.confirm("Are you sure you want to reset all settings to their defaults?")) {
        localStorage.removeItem(SETTINGS_STORAGE_KEY);
        setSettings(defaultSettings); // Reset state to defaults
         // Consider if a page reload is needed here depending on how settings are consumed
         // window.location.reload();
    }
  }, []);

  // Function to reset application data (clears tree, expanded state, and settings)
  const resetApplicationData = useCallback(() => {
     if (window.confirm(
        "WARNING: This will permanently delete all your notes, tasks, and folders, and reset all settings. This action cannot be undone. Are you absolutely sure?"
     )) {
         try {
            // Use the keys directly for now. Ideally, import from constants.
            localStorage.removeItem("myNotesTasksTree");
            localStorage.removeItem("myNotesTasksTree_expanded");
            localStorage.removeItem(SETTINGS_STORAGE_KEY);
            // Reset state as well
            setSettings(defaultSettings);
            // Force reload to clear application state completely (including useTree)
            window.location.reload();
         } catch (error) {
            console.error("Failed to reset application data:", error);
            alert("An error occurred while trying to reset data.");
         }
     }
  }, []);

  const value = {
    settings,
    updateSetting,
    resetSettings,
    resetApplicationData,
  };

  return (
    <SettingsContext.Provider value={value}>
      {children}
    </SettingsContext.Provider>
  );
};

// Custom hook to use the settings context
export const useSettings = () => {
  const context = useContext(SettingsContext);
  if (context === undefined) {
    throw new Error('useSettings must be used within a SettingsProvider');
  }
  return context;
};

--- src\contexts\SettingsContext.jsx ---
// src/contexts/SettingsContext.jsx
import React, { createContext, useState, useEffect, useContext, useCallback } from 'react';

const SETTINGS_STORAGE_KEY = "appSettings";

// Define default settings
export const defaultSettings = {
  theme: 'system', // 'light', 'dark', 'system'
  defaultSortOrder: 'foldersFirstAlpha', // e.g., 'foldersFirstAlpha', 'alpha', 'typeAlpha'
  autoExpandNewFolders: true,
  editorFontFamily: 'Arial',
  editorFontSize: '3', // Corresponds to HTML <font size="..."> values
  defaultExportFormat: 'json', // 'json', 'pdf'
};

// --- Available Options (for selects etc.) ---
export const themeOptions = [
    { value: 'system', label: 'System Default' },
    { value: 'light', label: 'Light' },
    { value: 'dark', label: 'Dark' },
];

export const sortOrderOptions = [
    { value: 'foldersFirstAlpha', label: 'Folders First, then Alpha' },
    { value: 'alpha', label: 'Alphabetical' },
    { value: 'typeAlpha', label: 'By Type, then Alpha' },
];

export const exportFormatOptions = [
    { value: 'json', label: 'JSON' },
    { value: 'pdf', label: 'PDF' },
];

// FONT_FAMILIES and FONT_SIZES from EditorPane (consider moving to a shared constants file)
export const editorFontFamilyOptions = [ "Arial", "Times New Roman", "Courier New", "Georgia", "Verdana" ].map(f => ({ value: f, label: f }));
export const editorFontSizeOptions = ["1", "2", "3", "4", "5", "6", "7"].map(s => ({ value: s, label: `Size ${s}` }));
// --- End Options ---


// Create the context
export const SettingsContext = createContext();

// Create the provider component
export const SettingsProvider = ({ children }) => {
  const [settings, setSettings] = useState(() => {
    try {
      const stored = localStorage.getItem(SETTINGS_STORAGE_KEY);
      const parsed = stored ? JSON.parse(stored) : defaultSettings;
      // Ensure all keys from defaultSettings exist
      return { ...defaultSettings, ...parsed };
    } catch (error) {
      console.error("Failed to load settings from localStorage:", error);
      return defaultSettings;
    }
  });

  // Apply theme and persist settings on change
  useEffect(() => {
    try {
      // Apply theme
      const root = window.document.documentElement;
      root.classList.remove('light', 'dark');
      let effectiveTheme = settings.theme;
      if (settings.theme === 'system') {
        effectiveTheme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
      }
      root.classList.add(effectiveTheme);

      // Persist settings
      localStorage.setItem(SETTINGS_STORAGE_KEY, JSON.stringify(settings));
    } catch (error) {
      console.error("Failed to save settings or apply theme:", error);
    }
  }, [settings]);

  // Function to update a specific setting
  const updateSetting = useCallback((key, value) => {
    setSettings(prev => ({ ...prev, [key]: value }));
  }, []);

  // Function to reset all settings to default
  const resetSettings = useCallback(() => {
    if (window.confirm("Are you sure you want to reset all settings to their defaults?")) {
        localStorage.removeItem(SETTINGS_STORAGE_KEY);
        setSettings(defaultSettings); // Reset state to defaults
         // Consider if a page reload is needed here depending on how settings are consumed
         // window.location.reload();
    }
  }, []);

  // Function to reset application data (clears tree, expanded state, and settings)
  const resetApplicationData = useCallback(() => {
     if (window.confirm(
        "WARNING: This will permanently delete all your notes, tasks, and folders, and reset all settings. This action cannot be undone. Are you absolutely sure?"
     )) {
         try {
            // Use the keys directly for now. Ideally, import from constants.
            localStorage.removeItem("myNotesTasksTree");
            localStorage.removeItem("myNotesTasksTree_expanded");
            localStorage.removeItem(SETTINGS_STORAGE_KEY);
            // Reset state as well
            setSettings(defaultSettings);
            // Force reload to clear application state completely (including useTree)
            window.location.reload();
         } catch (error) {
            console.error("Failed to reset application data:", error);
            alert("An error occurred while trying to reset data.");
         }
     }
  }, []);

  const value = {
    settings,
    updateSetting,
    resetSettings,
    resetApplicationData,
  };

  return (
    <SettingsContext.Provider value={value}>
      {children}
    </SettingsContext.Provider>
  );
};

// Custom hook to use the settings context
export const useSettings = () => {
  const context = useContext(SettingsContext);
  if (context === undefined) {
    throw new Error('useSettings must be used within a SettingsProvider');
  }
  return context;
};

--- src\fonts\NotoSansHebrewBase64.js ---
export const notoSansHebrewBase64 = `
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AYwBjQESAZEBLAAwAY8BrAHSAYQBtgGyAU0BTAGrAaoBQAF4ASsBqQFuAUYBVQGTARMAlwCiAKMAqACrALUAtgC7AL0AxQDGAMgAzQDOANMA3ADdAN4A4QDmAOoA8wD0APkA+gD/ARoBFgEbARABvgFTAQMBFQEfAS8BOQFLAU4BWgFeAWYBaAFqAXABdAF7AYoBkgGdAaMBrgG3AcEBwgHHAcgBzgEYARcBGQERAEIBSgEoAa0BqAEzAS4BhQFWAaABiQEyAYsBkAEmAYYBVwGUAJ0AmQCbAKEAnACgAJgApgCxAKwArgCvAMIAvgC/AMAAtADSANgA1QDWANsA1wFzANoA7gDrAOwA7QD7AOkBUgELAQQBBgEUAQkBDwEKASQBPwE6ATwBPQFjAV8BYAFhAUcBeQGCAXwBfQGIAX4BNQGHAbsBuAG5AboByQGxAcsAngEMAJoBBQCfAQ4ApAEgAKcBJQClASMAqQEwAKoBMQCyAUIAsAE+ALMBRQCtATsAtwFPALkBUQC4AVAAvAFbAMMBZADEAWUAwQFiAMcBaQDJAWsAywFtAMoBbADMAW8AzwF1ANEBdwDQAXYA2QGDANQBfwDfAZ4A4AGfAOIBpADkAaYA4wGlAOcBrwDwAb0A8gHAAO8BvADxAb8A9gHEAPwBygD9AQABzwECAdEBAQHQAOUBpwDoAbABKQEhARwBNwGhAYABswFcAVQBCAEqAbQBcQEdATgBNAGiAV0BIgEtAScBgQAUAFwAXQCQAI8AcgBYAJEASACJAHEAHgAfACEAUQBtAEoACQBBADoAQAA/ABIATgBuAIgARgAyABMAlAA8AF8AKAAkACYALQB1AFsASQBPAC4ALwBUAA8AZwA7AFUARwBkAGgAaQB7ADkARQBQAAMADAAiABAAKgB8AJIALABvAIoAFQA0ADcAFwA9ABgAQwBZAAoAGQBLABsAcwBSAFYAYABrAJYAfwCAAI0AHQAgAPgBxgD1AcMA9wHFAP4BzQFEAUMBlwGYAZYAjAAzAI4ACwCBAIIAgwCEAIUAHACGAIcACABlAGYAYgBjAAYABwAEAA0AIwARACsAfQCTAHAAiwAWADUAOABEAFoAGgBMAHQAUwBXAGEAbAB+AA4ANgBNAAUAAAAjAaoAAwABBAkAAACaBPYAAwABBAkAAQAgBNYAAwABBAkAAgAOBMgAAwABBAkAAwBCBIYAAwABBAkABAAwBFYAAwABBAkABQAaBDwAAwABBAkABgAsBBAAAwABBAkABwBEA8wAAwABBAkACAAUA7gAAwABBAkACQAUA6QAAwABBAkACgAsA3gAAwABBAkACwA+AzoAAwABBAkADAAqAxAAAwABBAkADQEiAe4AAwABBAkADgA2AbgAAwABBAkAGQAcAZwAAwABBAkBAAAMAZAAAwABBAkBAQAKAYYAAwABBAkBJgAaAWwAAwABBAkBJwB2APYAAwABBAkBKAAiANQAAwABBAkBKQAaALoAAwABBAkBKwAIALIAAwABBAkBLAAUAJ4AAwABBAkBLQAKAJQAAwABBAkBLgAOBMgAAwABBAkBLwAMAIgAAwABBAkBMAAQAHgAAwABBAkBMQAIAHAAAwABBAkBMgASAF4AAwABBAkBMwAKAFQAAwABBAkBNAAcADgAAwABBAkBNQASACYAAwABBAkBNgAaAAwAAwABBAkBNwAMAAAATgBvAHIAbQBhAGwAUwBlAG0AaQBDAG8AbgBkAGUAbgBzAGUAZABDAG8AbgBkAGUAbgBzAGUAZABFAHgAdAByAGEAQwBvAG4AZABlAG4AcwBlAGQAQgBsAGEAYwBrAEUAeAB0AHIAYQBCAG8AbABkAEIAbwBsAGQAUwBlAG0AaQBCAG8AbABkAE0AZQBkAGkAdQBtAEwAaQBnAGgAdABFAHgAdAByAGEATABpAGcAaAB0AFQAaABpAG4AaQBvAHQAYQAgAGEAZABzAGMAcgBpAHAAdABBAGMAYwBlAG4AdABlAGQAIABHAHIAZQBlAGsAIABTAEMAVABpAHQAbABpAG4AZwAgAEEAbAB0AGUAcgBuAGEAdABlAHMAIABJACAAYQBuAGQAIABKACAAZgBvAHIAIAB0AGkAdABsAGkAbgBnACAAYQBuAGQAIABhAGwAbAAgAGMAYQBwACAAcwBlAHQAdABpAG4AZwBzAGYAbABvAHIAaQBuACAAcwB5AG0AYgBvAGwAVwBpAGQAdABoAFcAZQBpAGcAaAB0AE4AbwB0AG8AUwBhAG4AcwBIAGUAYgByAGUAdwBoAHQAdABwAHMAOgAvAC8AbwBwAGUAbgBmAG8AbgB0AGwAaQBjAGUAbgBzAGUALgBvAHIAZwBUAGgAaQBzACAARgBvAG4AdAAgAFMAbwBmAHQAdwBhAHIAZQAgAGkAcwAgAGwAaQBjAGUAbgBzAGUAZAAgAHUAbgBkAGUAcgAgAHQAaABlACAAUwBJAEwAIABPAHAAZQBuACAARgBvAG4AdAAgAEwAaQBjAGUAbgBzAGUALAAgAFYAZQByAHMAaQBvAG4AIAAxAC4AMQAuACAAVABoAGkAcwAgAGwAaQBjAGUAbgBzAGUAIABpAHMAIABhAHYAYQBpAGwAYQBiAGwAZQAgAHcAaQB0AGgAIABhACAARgBBAFEAIABhAHQAOgAgAGgAdAB0AHAAcwA6AC8ALwBvAHAAZQBuAGYAbwBuAHQAbABpAGMAZQBuAHMAZQAuAG8AcgBnAGgAdAB0AHAAcwA6AC8ALwBoAGEAZgBvAG4AdABpAGEALgBjAG8AbQAvAGgAdAB0AHAAOgAvAC8AdwB3AHcALgBnAG8AbwBnAGwAZQAuAGMAbwBtAC8AZwBlAHQALwBuAG8AdABvAC8ARABlAHMAaQBnAG4AZQBkACAAYgB5ACAAQgBlAG4AIABOAGEAdABoAGEAbgBCAGUAbgAgAE4AYQB0AGgAYQBuAEcAbwBvAGcAbABlACAATABMAEMATgBvAHQAbwAgAGkAcwAgAGEAIAB0AHIAYQBkAGUAbQBhAHIAawAgAG8AZgAgAEcAbwBvAGcAbABlACAASQBuAGMALgBOAG8AdABvAFMAYQBuAHMASABlAGIAcgBlAHcALQBSAGUAZwB1AGwAYQByAFYAZQByAHMAaQBvAG4AIAAzAC4AMAAwADEATgBvAHQAbwAgAFMAYQBuAHMAIABIAGUAYgByAGUAdwAgAFIAZQBnAHUAbABhAHIAMwAuADAAMAAxADsARwBPAE8ARwA7AE4AbwB0AG8AUwBhAG4AcwBIAGUAYgByAGUAdwAtAFIAZQBnAHUAbABhAHIAUgBlAGcAdQBsAGEAcgBOAG8AdABvACAAUwBhAG4AcwAgAEgAZQBiAHIAZQB3AEMAbwBwAHkAcgBpAGcAaAB0ACAAMgAwADIANAAgAFQAaABlACAATgBvAHQAbwAgAFAAcgBvAGoAZQBjAHQAIABBAHUAdABoAG8AcgBzACAAKABoAHQAdABwAHMAOgAvAC8AZwBpAHQAaAB1AGIALgBjAG8AbQAvAG4AbwB0AG8AZgBvAG4AdABzAC8AaABlAGIAcgBlAHcAKQAAAfQAMgEEAAAAAAAAAngAJAJ4ACQCgwATAngAJAJ4ACQCOQAwAAAANwJRACYCRgAiAjwAKQI8ACkCNQApAAAANwIeACYCHgAmAAAANwAAADIAAAA3AiEAKwIhACsCrAAxAUkALAJsADACbAAwAhEAHAMaACEAugASAAAAMgAAADIBbQASAAAAMgF2ABcBdgAXAAAANAAAADQAAAA0AAAANgAAADcAAAA9AnMANQJzADUClgAsAAAANwAAADcAAAA3AUEAIQFBACEAAAA4AAAAMgIDAC0CAwAtAgMALQIKACICCgAiAAAANwAAADIBRAAiAAAAMgKUAC8ClAAvAAAAMgAAADIAAAAyAQoAAAF7ADABewAwAY0ATwAAADICDQDlAAAAMgAAADQAAAA3AlkANQJZADUCWQA1AAAAMgAAADQAAAA0AAAAMgJzAEACcwBAAAAANwAAADQCCwAoAgsAKAAAADUCgwAsAoMALAAAADcAAAA1AAAAMgMYAFQAAAA2AtoAQALaAEAC2gBAAtoAQAAAADcC2gBAAtoAQAAAADQAAAA3APYARQEOAAACrQAjAq0AIwAAADIAAAAyAnoAOQJ6ADkAAAAzAAAAMgIsACsCLAArAAAANgAA/+4AAP+VAAD/7gAA/y4CUgAwAAAANwEtACYBLQALAS0AJgJNACYCWgAmAvkAJgKiACEDHwAvAqcAHQKEAAgCpgAnA0wAJgAAADcAAAAyAScAJgEnABABMgAmAlcAJgJkACYAAAAyAAAANQAAADIBSgAqAUr/9gAAADIAAAAAAnkAJgJ5AAADQP/+AnkAAAJ5AAACeQAAAnkAAAJ5AAACeQAAAnkAAAJ5AAACeQAAAnwAXQJzADsCcwA7AnMAOwJzADsCcwA7AsQAXQLEAF0CxAAQAiYAXQImAF0CJgBdAiYAXQImAF0CJgBdAiYAXQImAF0CJgBdAsQAEAH+AF0C2AA7AtgAOwLYADsC2AA7AsUAWwLZAF0C3wAAAVYAMwFWADMBVgAKAVYAFwFWADMBVgAzAVYAGgFWADMBFP+lAl4AXQJeAF0CFwBdAhcASAIXAF0CFwBdAiEAAQN2AF0C7QBdAu0AXQLtAF0C7QBdAu0AXQMCADsDmQA7AwIAOwMCADsDAgA7AwIAOwMCADsDAgA7AwIAOwJTAF0DAgA7AmcAXQJnAF0CZwBdAiwANAIsADQCLAA0AiwANAIsADQCGQALAhkACwIZAAsCUQBdAtkAVwLZAFcC2QBXAtkAVwLZAFcC2QBXAtkAVwLZAFcC2QBXAmQAAAOlABoDpQAaA6UAGgOlABoDpQAaAk3//wI1AAACNQAAAjUAAAI1AAACNQAAAk4AIgJOACICTgAiAk4AIgIpACwCKQAsAikALAIpACwBOAAoAAD+6wIpACwDcgAsAikALAIpACwC4gA1AikALAIpACwCKQAaAkAANAIiAC8DdQAwAikALAJeAFABbwAJAg0A5QF1ABwBdQAjAT0ATAE9ABgBfQAoAAD/aQF+AGIB8QA1AfEANQGUACgAAP9cAfEANQHxADUB8QA1AOUADwAA/5QCQABNAZQAKAAA/1MA9gBFAOYAIgAA/8QDPQAwAl4ANQJeADUCZAA1AaoAOAJJAJMAAP9rAkAAMwI9ADIAvQAoAAD/ygI5ADUCOQA1AjkANQI5ADUCOQA1AjkANQI5ADUCQAA0AukARQI5ADUD6AAnAfQAJwI5ADUCQAAzAksANAJAACYA+ABFAPgARgFGAA8CQABAAkAAFgJeADUCXgA1Al4ANQJeADUCdABQATgAKAAA/hgCQAA0AfMAHgHzAB4BIAAeASAAHgJhAFECZQAKAcoAKAAA/4IA+wBIAPsAPgD7/90A+//qAPsAUQD7AAoA+//sAPsAEgD7/84A+//OAhMAUQITAFEA+wBSAPsAPQD7AFIA+wBBAkAANAEeAAEDjABRAAD/bQFBACECQABGAmEAUQJhAFECYQBRAmEAUQJAAC4CYQBRAowAGAJWADUCVgA1AlYANQJWADUDzAA1APUAKAAA/60CVgA1AlYANQJAAE8BXgAjAW8AIAJhADUCVgA1AfT//QJeAFICiwBOASYAKAEmACEDUwAsAPYARQD2AEUCQAAzAl4AMwHAABgBwAAhAY0ARAGsACEBYQASAWEAEQCtABIArQARAPIAIQDZAEQBmgBSAZoAUgGaADIDPQAwATAAKAAA/4wB4AApAeAAKQHgACkB4AApAeAAKQH/AD4A+QAiAkAAMwJAADcBbwAKAkAALQF0ABABdAAQAXQAEAJeAFICQAAqAbUAKAAA/gQC0AAGAkAAMAJhAEwCYQBMAmEATAJhAEwCYQBMAmEATAJhAEwBsP/+AmEATAJhAEwB8gAAAwEADwMBAA8DAQAPAwEADwMBAA8CGAASAfAAAAHwAAAB8AAAAfAAAAJAABEB8AAAAdsAIwHbACMB2wAjAdsAIwJAADQB6QC4AekAtwF1ACgAAgAAAAAAAP+cADIAAAAAAAAAAAAAAAAAAAAAAAAAAAHWAAABAgEDAQQBBQEGAQcBCAEJAQoBCwEMAQ0BDgEPARABEQESARMBFAEVARYBFwEYARkBGgEbARwBHQEeAR8BIAEhASIBIwEkASUBJgEnASgBKQEqASsBLAEtAS4BLwEwABABMQEyATMBNAE1ATYBNwE4ATkBOgE7ATwBPQE+AT8BQAFBAUIBQwFEAUUBRgFHAUgBSQFKAUsBTAFNAU4BTwFQAVEBUgFTAVQBVQFWAVcBWAFZAVoBWwFcAV0BXgFfAWABYQFiAWMBZAFlAWYBZwFoAWkAAwFqAWsBbAFtAW4BbwFwAXEBcgFzAXQBdQF2AXcBeAF5AXoBewF8AX0BfgF/AYABgQGCAYMBhAGFAYYBhwGIAYkBigGLAYwBjQGOAY8BkAGRAZIBkwGUAZUAJACQAMkBlgDHAGIArQGXAZgAYwCuACUAJgD9AP8AZAGZACcBmgGbACgAZQGcAMgAygGdAMsBngGfAOkAKQAqAPgBoAGhAaIAKwGjACwAzADNAM4A+gDPAaQBpQAtAC4BpgAvAacBqAGpAOIAMAAxAaoBqwGsAGYAMgCwANAA0QBnANMBrQCRAK8AMwA0ADUBrgGvADYBsADkAPsBsQA3AbIBswDtADgA1ADVAGgA1gG0AbUBtgG3ADkAOgG4AbkBugG7ADsAPADrAbwAuwG9AD0BvgDmAb8ARABpAcAAawCNAcEAbACgAGoBwgAJAcMAbgBBAGEADQAjAG0ARQA/AF8AXgBgAD4AQADbAcQAhwBGAP4A4QHFAQAAbwHGAN4BxwCEANgByAAdAA8ByQCLAEcBygEBAIMAjgHLALgABwDcAcwASABwAc0AcgBzAc4AcQAbAKsBzwCzALIB0AAgAOoB0QAEAKMASQAYABcASgD5AdIB0wCJAEMB1AAhAKkAqgC+AL8ASwHVAN8B1gBMAHQAdgB3ANcAdQHXAdgATQHZAE4B2gBPAdsB3AHdAB8A4wBQAd4A7wDwAFEB3wHgAeEAHAB4AAYAUgB5AHsAfACxAOAB4gB6AeMAFACdAJ4AoQB9AeQAUwCIAAsADAAIABEAwwAOAFQAIgCiAAUAxQC0ALUAtgC3AMQACgBVAeUB5gCKAN0B5wBWAegA5QD8AekAhgAeABoAGQASAIUAVwHqAesA7gAWANkB7ACMABUAWAB+AIAAgQB/Ae0B7gBCAe8B8ABZAFoB8QHyAfMB9ABbAFwA7AH1ALoAlgH2AF0B9wDnAfgAEwH5AfoB+wJDUgROVUxMB3VuaTA1RDAHdW5pRkIzMAd1bmlGQjRGB3VuaUZCMkUHdW5pRkIyRgd1bmlGQjI5B3VuaTA1QTIHdW5pMDVFMgd1bmlGQjIwB3VuaTA1RDEHdW5pRkIzMQd1bmlGQjRDB3VuaTA1QkMHdW5pMDVEMwd1bmlGQjMzB3VuaTA1QTcHdW5pMDVBRAd1bmkwNTkxB3VuaTA1REEHdW5pRkIzQQd1bmkwNUREB3VuaTA1REYHdW5pMDVFMwd1bmlGQjQzB3VuaTA1RTUHdW5pRkIyNgd1bmkwNUYzB3VuaTA1OUMHdW5pMDU5RAd1bmkwNUY0B3VuaTA1OUUHdW5pMDVEMgd1bmlGQjMyB3VuaTA1QjIPdW5pMDVCMjIwMEQwNUJEB3VuaTA1QjMPdW5pMDVCMzIwMEQwNUJEB3VuaTA1QjEPdW5pMDVCMTIwMEQwNUJEB3VuaTA1RDQHdW5pRkIzNAd1bmkwNUQ3B3VuaTA1QjQHdW5pMDVCOQd1bmkwNUJBB3VuaTIwMTAHdW5pMDVBQwd1bmlGQjFFB3VuaTA1REIHdW5pRkIzQgd1bmlGQjREB3VuaTA1REMHdW5pRkIzQwd1bmkwNUM1B3VuaTA1QTQHdW5pMDVCRQd1bmkwNUFGB3VuaTA1REUHdW5pRkIzRQd1bmkwNUE2B3VuaTA1QTUHdW5pMDVBMwd1bmkwMEEwB3VuaTA1RTAHdW5pRkI0MAd1bmkwNUM2B3VuaTA1QUIHdW5pMDVDMAd1bmkwNTk5B3VuaTA1QjcHdW5pMDVBMQd1bmkwNUU0B3VuaUZCNDQHdW5pRkI0RQd1bmkwNUE4B3VuaTA1QjgHdW5pMDVDNwd1bmkwNTlGB3VuaTA1RTcHdW5pRkI0Nwd1bmkwNUJCB3VuaTA1QkYHdW5pMDVFOAd1bmlGQjQ4B3VuaTA1OTcHdW5pMDVFMQd1bmlGQjQxB3VuaTA1QjYHdW5pMDU5Mgd1bmkwNTkzB3VuaTIwQUEHdW5pMDVCMAd1bmkwNUU5B3VuaUZCNDkHdW5pRkIyQwd1bmlGQjJEB3VuaTA1QzEHdW5pRkIyQQd1bmlGQjJCB3VuaTA1QkQHdW5pMDVDMgd1bmkwNUMzB3VuaTA1RUEHdW5pRkI0QQd1bmkwNUEwB3VuaTA1QTkHdW5pMDVEOAd1bmlGQjM4B3VuaTA1OUIHdW5pMDU5Ngd1bmkwNUU2B3VuaUZCNDYHdW5pMDVCNQd1bmkyMDBDB3VuaTIwMEQHdW5pMjAwRQd1bmkyMDBGB3VuaTI1Q0MHdW5pMDVDNAd1bmkwNUQ1B3VuaUZCMzUHdW5pRkI0Qgd1bmkwNUYwB3VuaTA1RjEHdW5pRkIyMQd1bmlGQjIyB3VuaUZCMjMHdW5pRkIyNAd1bmlGQjI1B3VuaUZCMjcHdW5pRkIyOAd1bmkwNUFBB3VuaTA1OUEHdW5pMDVEOQd1bmlGQjM5B3VuaUZCMUQHdW5pMDVGMgd1bmlGQjFGB3VuaTA1OTUHdW5pMDU5NAd1bmkwNTk4B3VuaTA1RDYHdW5pRkIzNgd1bmkwNUFFB3VuaTAzNEYLeW9keW9keW9kaGIGQWJyZXZlB0FtYWNyb24HQW9nb25lawpDZG90YWNjZW50BkRjYXJvbgZEY3JvYXQGRWNhcm9uCkVkb3RhY2NlbnQHRW1hY3JvbgdFb2dvbmVrB3VuaTAxMjIKR2RvdGFjY2VudAd1bmkxRTlFBEhiYXIHSW1hY3JvbgdJb2dvbmVrB3VuaTAxMzYGTGFjdXRlBkxjYXJvbgd1bmkwMTNCBk5hY3V0ZQZOY2Fyb24HdW5pMDE0NQ1PaHVuZ2FydW1sYXV0BlJhY3V0ZQZSY2Fyb24GU2FjdXRlB3VuaTAyMTgGVGNhcm9uB3VuaTAyMUENVWh1bmdhcnVtbGF1dAdVbWFjcm9uB1VvZ29uZWsFVXJpbmcGV2FjdXRlC1djaXJjdW1mbGV4CVdkaWVyZXNpcwZXZ3JhdmULWWNpcmN1bWZsZXgGWWdyYXZlBlphY3V0ZQpaZG90YWNjZW50BmFicmV2ZQlhY3V0ZWNvbWIHYW1hY3Jvbgdhb2dvbmVrB3VuaTAzMDYHdW5pMDMwQwpjZG90YWNjZW50B3VuaTAzMjcHdW5pMDMwMgd1bmkw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`;

--- src\fonts\NotoSansHebrewBase64.js ---
export const notoSansHebrewBase64 = `
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AYwBjQESAZEBLAAwAY8BrAHSAYQBtgGyAU0BTAGrAaoBQAF4ASsBqQFuAUYBVQGTARMAlwCiAKMAqACrALUAtgC7AL0AxQDGAMgAzQDOANMA3ADdAN4A4QDmAOoA8wD0APkA+gD/ARoBFgEbARABvgFTAQMBFQEfAS8BOQFLAU4BWgFeAWYBaAFqAXABdAF7AYoBkgGdAaMBrgG3AcEBwgHHAcgBzgEYARcBGQERAEIBSgEoAa0BqAEzAS4BhQFWAaABiQEyAYsBkAEmAYYBVwGUAJ0AmQCbAKEAnACgAJgApgCxAKwArgCvAMIAvgC/AMAAtADSANgA1QDWANsA1wFzANoA7gDrAOwA7QD7AOkBUgELAQQBBgEUAQkBDwEKASQBPwE6ATwBPQFjAV8BYAFhAUcBeQGCAXwBfQGIAX4BNQGHAbsBuAG5AboByQGxAcsAngEMAJoBBQCfAQ4ApAEgAKcBJQClASMAqQEwAKoBMQCyAUIAsAE+ALMBRQCtATsAtwFPALkBUQC4AVAAvAFbAMMBZADEAWUAwQFiAMcBaQDJAWsAywFtAMoBbADMAW8AzwF1ANEBdwDQAXYA2QGDANQBfwDfAZ4A4AGfAOIBpADkAaYA4wGlAOcBrwDwAb0A8gHAAO8BvADxAb8A9gHEAPwBygD9AQABzwECAdEBAQHQAOUBpwDoAbABKQEhARwBNwGhAYABswFcAVQBCAEqAbQBcQEdATgBNAGiAV0BIgEtAScBgQAUAFwAXQCQAI8AcgBYAJEASACJAHEAHgAfACEAUQBtAEoACQBBADoAQAA/ABIATgBuAIgARgAyABMAlAA8AF8AKAAkACYALQB1AFsASQBPAC4ALwBUAA8AZwA7AFUARwBkAGgAaQB7ADkARQBQAAMADAAiABAAKgB8AJIALABvAIoAFQA0ADcAFwA9ABgAQwBZAAoAGQBLABsAcwBSAFYAYABrAJYAfwCAAI0AHQAgAPgBxgD1AcMA9wHFAP4BzQFEAUMBlwGYAZYAjAAzAI4ACwCBAIIAgwCEAIUAHACGAIcACABlAGYAYgBjAAYABwAEAA0AIwARACsAfQCTAHAAiwAWADUAOABEAFoAGgBMAHQAUwBXAGEAbAB+AA4ANgBNAAUAAAAjAaoAAwABBAkAAACaBPYAAwABBAkAAQAgBNYAAwABBAkAAgAOBMgAAwABBAkAAwBCBIYAAwABBAkABAAwBFYAAwABBAkABQAaBDwAAwABBAkABgAsBBAAAwABBAkABwBEA8wAAwABBAkACAAUA7gAAwABBAkACQAUA6QAAwABBAkACgAsA3gAAwABBAkACwA+AzoAAwABBAkADAAqAxAAAwABBAkADQEiAe4AAwABBAkADgA2AbgAAwABBAkAGQAcAZwAAwABBAkBAAAMAZAAAwABBAkBAQAKAYYAAwABBAkBJgAaAWwAAwABBAkBJwB2APYAAwABBAkBKAAiANQAAwABBAkBKQAaALoAAwABBAkBKwAIALIAAwABBAkBLAAUAJ4AAwABBAkBLQAKAJQAAwABBAkBLgAOBMgAAwABBAkBLwAMAIgAAwABBAkBMAAQAHgAAwABBAkBMQAIAHAAAwABBAkBMgASAF4AAwABBAkBMwAKAFQAAwABBAkBNAAcADgAAwABBAkBNQASACYAAwABBAkBNgAaAAwAAwABBAkBNwAMAAAATgBvAHIAbQBhAGwAUwBlAG0AaQBDAG8AbgBkAGUAbgBzAGUAZABDAG8AbgBkAGUAbgBzAGUAZABFAHgAdAByAGEAQwBvAG4AZABlAG4AcwBlAGQAQgBsAGEAYwBrAEUAeAB0AHIAYQBCAG8AbABkAEIAbwBsAGQAUwBlAG0AaQBCAG8AbABkAE0AZQBkAGkAdQBtAEwAaQBnAGgAdABFAHgAdAByAGEATABpAGcAaAB0AFQAaABpAG4AaQBvAHQAYQAgAGEAZABzAGMAcgBpAHAAdABBAGMAYwBlAG4AdABlAGQAIABHAHIAZQBlAGsAIABTAEMAVABpAHQAbABpAG4AZwAgAEEAbAB0AGUAcgBuAGEAdABlAHMAIABJACAAYQBuAGQAIABKACAAZgBvAHIAIAB0AGkAdABsAGkAbgBnACAAYQBuAGQAIABhAGwAbAAgAGMAYQBwACAAcwBlAHQAdABpAG4AZwBzAGYAbABvAHIAaQBuACAAcwB5AG0AYgBvAGwAVwBpAGQAdABoAFcAZQBpAGcAaAB0AE4AbwB0AG8AUwBhAG4AcwBIAGUAYgByAGUAdwBoAHQAdABwAHMAOgAvAC8AbwBwAGUAbgBmAG8AbgB0AGwAaQBjAGUAbgBzAGUALgBvAHIAZwBUAGgAaQBzACAARgBvAG4AdAAgAFMAbwBmAHQAdwBhAHIAZQAgAGkAcwAgAGwAaQBjAGUAbgBzAGUAZAAgAHUAbgBkAGUAcgAgAHQAaABlACAAUwBJAEwAIABPAHAAZQBuACAARgBvAG4AdAAgAEwAaQBjAGUAbgBzAGUALAAgAFYAZQByAHMAaQBvAG4AIAAxAC4AMQAuACAAVABoAGkAcwAgAGwAaQBjAGUAbgBzAGUAIABpAHMAIABhAHYAYQBpAGwAYQBiAGwAZQAgAHcAaQB0AGgAIABhACAARgBBAFEAIABhAHQAOgAgAGgAdAB0AHAAcwA6AC8ALwBvAHAAZQBuAGYAbwBuAHQAbABpAGMAZQBuAHMAZQAuAG8AcgBnAGgAdAB0AHAAcwA6AC8ALwBoAGEAZgBvAG4AdABpAGEALgBjAG8AbQAvAGgAdAB0AHAAOgAvAC8AdwB3AHcALgBnAG8AbwBnAGwAZQAuAGMAbwBtAC8AZwBlAHQALwBuAG8AdABvAC8ARABlAHMAaQBnAG4AZQBkACAAYgB5ACAAQgBlAG4AIABOAGEAdABoAGEAbgBCAGUAbgAgAE4AYQB0AGgAYQBuAEcAbwBvAGcAbABlACAATABMAEMATgBvAHQAbwAgAGkAcwAgAGEAIAB0AHIAYQBkAGUAbQBhAHIAawAgAG8AZgAgAEcAbwBvAGcAbABlACAASQBuAGMALgBOAG8AdABvAFMAYQBuAHMASABlAGIAcgBlAHcALQBSAGUAZwB1AGwAYQByAFYAZQByAHMAaQBvAG4AIAAzAC4AMAAwADEATgBvAHQAbwAgAFMAYQBuAHMAIABIAGUAYgByAGUAdwAgAFIAZQBnAHUAbABhAHIAMwAuADAAMAAxADsARwBPAE8ARwA7AE4AbwB0AG8AUwBhAG4AcwBIAGUAYgByAGUAdwAtAFIAZQBnAHUAbABhAHIAUgBlAGcAdQBsAGEAcgBOAG8AdABvACAAUwBhAG4AcwAgAEgAZQBiAHIAZQB3AEMAbwBwAHkAcgBpAGcAaAB0ACAAMgAwADIANAAgAFQAaABlACAATgBvAHQAbwAgAFAAcgBvAGoAZQBjAHQAIABBAHUAdABoAG8AcgBzACAAKABoAHQAdABwAHMAOgAvAC8AZwBpAHQAaAB1AGIALgBjAG8AbQAvAG4AbwB0AG8AZgBvAG4AdABzAC8AaABlAGIAcgBlAHcAKQAAAfQAMgEEAAAAAAAAAngAJAJ4ACQCgwATAngAJAJ4ACQCOQAwAAAANwJRACYCRgAiAjwAKQI8ACkCNQApAAAANwIeACYCHgAmAAAANwAAADIAAAA3AiEAKwIhACsCrAAxAUkALAJsADACbAAwAhEAHAMaACEAugASAAAAMgAAADIBbQASAAAAMgF2ABcBdgAXAAAANAAAADQAAAA0AAAANgAAADcAAAA9AnMANQJzADUClgAsAAAANwAAADcAAAA3AUEAIQFBACEAAAA4AAAAMgIDAC0CAwAtAgMALQIKACICCgAiAAAANwAAADIBRAAiAAAAMgKUAC8ClAAvAAAAMgAAADIAAAAyAQoAAAF7ADABewAwAY0ATwAAADICDQDlAAAAMgAAADQAAAA3AlkANQJZADUCWQA1AAAAMgAAADQAAAA0AAAAMgJzAEACcwBAAAAANwAAADQCCwAoAgsAKAAAADUCgwAsAoMALAAAADcAAAA1AAAAMgMYAFQAAAA2AtoAQALaAEAC2gBAAtoAQAAAADcC2gBAAtoAQAAAADQAAAA3APYARQEOAAACrQAjAq0AIwAAADIAAAAyAnoAOQJ6ADkAAAAzAAAAMgIsACsCLAArAAAANgAA/+4AAP+VAAD/7gAA/y4CUgAwAAAANwEtACYBLQALAS0AJgJNACYCWgAmAvkAJgKiACEDHwAvAqcAHQKEAAgCpgAnA0wAJgAAADcAAAAyAScAJgEnABABMgAmAlcAJgJkACYAAAAyAAAANQAAADIBSgAqAUr/9gAAADIAAAAAAnkAJgJ5AAADQP/+AnkAAAJ5AAACeQAAAnkAAAJ5AAACeQAAAnkAAAJ5AAACeQAAAnwAXQJzADsCcwA7AnMAOwJzADsCcwA7AsQAXQLEAF0CxAAQAiYAXQImAF0CJgBdAiYAXQImAF0CJgBdAiYAXQImAF0CJgBdAsQAEAH+AF0C2AA7AtgAOwLYADsC2AA7AsUAWwLZAF0C3wAAAVYAMwFWADMBVgAKAVYAFwFWADMBVgAzAVYAGgFWADMBFP+lAl4AXQJeAF0CFwBdAhcASAIXAF0CFwBdAiEAAQN2AF0C7QBdAu0AXQLtAF0C7QBdAu0AXQMCADsDmQA7AwIAOwMCADsDAgA7AwIAOwMCADsDAgA7AwIAOwJTAF0DAgA7AmcAXQJnAF0CZwBdAiwANAIsADQCLAA0AiwANAIsADQCGQALAhkACwIZAAsCUQBdAtkAVwLZAFcC2QBXAtkAVwLZAFcC2QBXAtkAVwLZAFcC2QBXAmQAAAOlABoDpQAaA6UAGgOlABoDpQAaAk3//wI1AAACNQAAAjUAAAI1AAACNQAAAk4AIgJOACICTgAiAk4AIgIpACwCKQAsAikALAIpACwBOAAoAAD+6wIpACwDcgAsAikALAIpACwC4gA1AikALAIpACwCKQAaAkAANAIiAC8DdQAwAikALAJeAFABbwAJAg0A5QF1ABwBdQAjAT0ATAE9ABgBfQAoAAD/aQF+AGIB8QA1AfEANQGUACgAAP9cAfEANQHxADUB8QA1AOUADwAA/5QCQABNAZQAKAAA/1MA9gBFAOYAIgAA/8QDPQAwAl4ANQJeADUCZAA1AaoAOAJJAJMAAP9rAkAAMwI9ADIAvQAoAAD/ygI5ADUCOQA1AjkANQI5ADUCOQA1AjkANQI5ADUCQAA0AukARQI5ADUD6AAnAfQAJwI5ADUCQAAzAksANAJAACYA+ABFAPgARgFGAA8CQABAAkAAFgJeADUCXgA1Al4ANQJeADUCdABQATgAKAAA/hgCQAA0AfMAHgHzAB4BIAAeASAAHgJhAFECZQAKAcoAKAAA/4IA+wBIAPsAPgD7/90A+//qAPsAUQD7AAoA+//sAPsAEgD7/84A+//OAhMAUQITAFEA+wBSAPsAPQD7AFIA+wBBAkAANAEeAAEDjABRAAD/bQFBACECQABGAmEAUQJhAFECYQBRAmEAUQJAAC4CYQBRAowAGAJWADUCVgA1AlYANQJWADUDzAA1APUAKAAA/60CVgA1AlYANQJAAE8BXgAjAW8AIAJhADUCVgA1AfT//QJeAFICiwBOASYAKAEmACEDUwAsAPYARQD2AEUCQAAzAl4AMwHAABgBwAAhAY0ARAGsACEBYQASAWEAEQCtABIArQARAPIAIQDZAEQBmgBSAZoAUgGaADIDPQAwATAAKAAA/4wB4AApAeAAKQHgACkB4AApAeAAKQH/AD4A+QAiAkAAMwJAADcBbwAKAkAALQF0ABABdAAQAXQAEAJeAFICQAAqAbUAKAAA/gQC0AAGAkAAMAJhAEwCYQBMAmEATAJhAEwCYQBMAmEATAJhAEwBsP/+AmEATAJhAEwB8gAAAwEADwMBAA8DAQAPAwEADwMBAA8CGAASAfAAAAHwAAAB8AAAAfAAAAJAABEB8AAAAdsAIwHbACMB2wAjAdsAIwJAADQB6QC4AekAtwF1ACgAAgAAAAAAAP+cADIAAAAAAAAAAAAAAAAAAAAAAAAAAAHWAAABAgEDAQQBBQEGAQcBCAEJAQoBCwEMAQ0BDgEPARABEQESARMBFAEVARYBFwEYARkBGgEbARwBHQEeAR8BIAEhASIBIwEkASUBJgEnASgBKQEqASsBLAEtAS4BLwEwABABMQEyATMBNAE1ATYBNwE4ATkBOgE7ATwBPQE+AT8BQAFBAUIBQwFEAUUBRgFHAUgBSQFKAUsBTAFNAU4BTwFQAVEBUgFTAVQBVQFWAVcBWAFZAVoBWwFcAV0BXgFfAWABYQFiAWMBZAFlAWYBZwFoAWkAAwFqAWsBbAFtAW4BbwFwAXEBcgFzAXQBdQF2AXcBeAF5AXoBewF8AX0BfgF/AYABgQGCAYMBhAGFAYYBhwGIAYkBigGLAYwBjQGOAY8BkAGRAZIBkwGUAZUAJACQAMkBlgDHAGIArQGXAZgAYwCuACUAJgD9AP8AZAGZACcBmgGbACgAZQGcAMgAygGdAMsBngGfAOkAKQAqAPgBoAGhAaIAKwGjACwAzADNAM4A+gDPAaQBpQAtAC4BpgAvAacBqAGpAOIAMAAxAaoBqwGsAGYAMgCwANAA0QBnANMBrQCRAK8AMwA0ADUBrgGvADYBsADkAPsBsQA3AbIBswDtADgA1ADVAGgA1gG0AbUBtgG3ADkAOgG4AbkBugG7ADsAPADrAbwAuwG9AD0BvgDmAb8ARABpAcAAawCNAcEAbACgAGoBwgAJAcMAbgBBAGEADQAjAG0ARQA/AF8AXgBgAD4AQADbAcQAhwBGAP4A4QHFAQAAbwHGAN4BxwCEANgByAAdAA8ByQCLAEcBygEBAIMAjgHLALgABwDcAcwASABwAc0AcgBzAc4AcQAbAKsBzwCzALIB0AAgAOoB0QAEAKMASQAYABcASgD5AdIB0wCJAEMB1AAhAKkAqgC+AL8ASwHVAN8B1gBMAHQAdgB3ANcAdQHXAdgATQHZAE4B2gBPAdsB3AHdAB8A4wBQAd4A7wDwAFEB3wHgAeEAHAB4AAYAUgB5AHsAfACxAOAB4gB6AeMAFACdAJ4AoQB9AeQAUwCIAAsADAAIABEAwwAOAFQAIgCiAAUAxQC0ALUAtgC3AMQACgBVAeUB5gCKAN0B5wBWAegA5QD8AekAhgAeABoAGQASAIUAVwHqAesA7gAWANkB7ACMABUAWAB+AIAAgQB/Ae0B7gBCAe8B8ABZAFoB8QHyAfMB9ABbAFwA7AH1ALoAlgH2AF0B9wDnAfgAEwH5AfoB+wJDUgROVUxMB3VuaTA1RDAHdW5pRkIzMAd1bmlGQjRGB3VuaUZCMkUHdW5pRkIyRgd1bmlGQjI5B3VuaTA1QTIHdW5pMDVFMgd1bmlGQjIwB3VuaTA1RDEHdW5pRkIzMQd1bmlGQjRDB3VuaTA1QkMHdW5pMDVEMwd1bmlGQjMzB3VuaTA1QTcHdW5pMDVBRAd1bmkwNTkxB3VuaTA1REEHdW5pRkIzQQd1bmkwNUREB3VuaTA1REYHdW5pMDVFMwd1bmlGQjQzB3VuaTA1RTUHdW5pRkIyNgd1bmkwNUYzB3VuaTA1OUMHdW5pMDU5RAd1bmkwNUY0B3VuaTA1OUUHdW5pMDVEMgd1bmlGQjMyB3VuaTA1QjIPdW5pMDVCMjIwMEQwNUJEB3VuaTA1QjMPdW5pMDVCMzIwMEQwNUJEB3VuaTA1QjEPdW5pMDVCMTIwMEQwNUJEB3VuaTA1RDQHdW5pRkIzNAd1bmkwNUQ3B3VuaTA1QjQHdW5pMDVCOQd1bmkwNUJBB3VuaTIwMTAHdW5pMDVBQwd1bmlGQjFFB3VuaTA1REIHdW5pRkIzQgd1bmlGQjREB3VuaTA1REMHdW5pRkIzQwd1bmkwNUM1B3VuaTA1QTQHdW5pMDVCRQd1bmkwNUFGB3VuaTA1REUHdW5pRkIzRQd1bmkwNUE2B3VuaTA1QTUHdW5pMDVBMwd1bmkwMEEwB3VuaTA1RTAHdW5pRkI0MAd1bmkwNUM2B3VuaTA1QUIHdW5pMDVDMAd1bmkwNTk5B3VuaTA1QjcHdW5pMDVBMQd1bmkwNUU0B3VuaUZCNDQHdW5pRkI0RQd1bmkwNUE4B3VuaTA1QjgHdW5pMDVDNwd1bmkwNTlGB3VuaTA1RTcHdW5pRkI0Nwd1bmkwNUJCB3VuaTA1QkYHdW5pMDVFOAd1bmlGQjQ4B3VuaTA1OTcHdW5pMDVFMQd1bmlGQjQxB3VuaTA1QjYHdW5pMDU5Mgd1bmkwNTkzB3VuaTIwQUEHdW5pMDVCMAd1bmkwNUU5B3VuaUZCNDkHdW5pRkIyQwd1bmlGQjJEB3VuaTA1QzEHdW5pRkIyQQd1bmlGQjJCB3VuaTA1QkQHdW5pMDVDMgd1bmkwNUMzB3VuaTA1RUEHdW5pRkI0QQd1bmkwNUEwB3VuaTA1QTkHdW5pMDVEOAd1bmlGQjM4B3VuaTA1OUIHdW5pMDU5Ngd1bmkwNUU2B3VuaUZCNDYHdW5pMDVCNQd1bmkyMDBDB3VuaTIwMEQHdW5pMjAwRQd1bmkyMDBGB3VuaTI1Q0MHdW5pMDVDNAd1bmkwNUQ1B3VuaUZCMzUHdW5pRkI0Qgd1bmkwNUYwB3VuaTA1RjEHdW5pRkIyMQd1bmlGQjIyB3VuaUZCMjMHdW5pRkIyNAd1bmlGQjI1B3VuaUZCMjcHdW5pRkIyOAd1bmkwNUFBB3VuaTA1OUEHdW5pMDVEOQd1bmlGQjM5B3VuaUZCMUQHdW5pMDVGMgd1bmlGQjFGB3VuaTA1OTUHdW5pMDU5NAd1bmkwNTk4B3VuaTA1RDYHdW5pRkIzNgd1bmkwNUFFB3VuaTAzNEYLeW9keW9keW9kaGIGQWJyZXZlB0FtYWNyb24HQW9nb25lawpDZG90YWNjZW50BkRjYXJvbgZEY3JvYXQGRWNhcm9uCkVkb3RhY2NlbnQHRW1hY3JvbgdFb2dvbmVrB3VuaTAxMjIKR2RvdGFjY2VudAd1bmkxRTlFBEhiYXIHSW1hY3JvbgdJb2dvbmVrB3VuaTAxMzYGTGFjdXRlBkxjYXJvbgd1bmkwMTNCBk5hY3V0ZQZOY2Fyb24HdW5pMDE0NQ1PaHVuZ2FydW1sYXV0BlJhY3V0ZQZSY2Fyb24GU2FjdXRlB3VuaTAyMTgGVGNhcm9uB3VuaTAyMUENVWh1bmdhcnVtbGF1dAdVbWFjcm9uB1VvZ29uZWsFVXJpbmcGV2FjdXRlC1djaXJjdW1mbGV4CVdkaWVyZXNpcwZXZ3JhdmULWWNpcmN1bWZsZXgGWWdyYXZlBlphY3V0ZQpaZG90YWNjZW50BmFicmV2ZQlhY3V0ZWNvbWIHYW1hY3Jvbgdhb2dvbmVrB3VuaTAzMDYHdW5pMDMwQwpjZG90YWNjZW50B3VuaTAzMjcHdW5pMDMwMgd1bmkw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`;

--- src\hooks\useTree.jsx ---
// src/hooks/useTree.jsx
import React, { useState, useEffect, useCallback, useMemo } from "react";
import { LOCAL_STORAGE_KEY } from "../utils/constants";
import {
  sortItems,
  handleDrop as treeHandleDropUtil,
  deleteItemRecursive,
  renameItemRecursive,
  insertItemRecursive,
  isSelfOrDescendant,
  findItemById,
  findParentAndSiblings,
  hasSiblingWithName,
  getItemPath,
} from "../utils/treeUtils";
import { jsPDF } from "jspdf";
import * as bidiNS from "unicode-bidirectional";
import { notoSansHebrewBase64 } from "../fonts/NotoSansHebrewBase64";
import { useSettings } from "../contexts/SettingsContext";
import { itemMatches } from "../utils/searchUtils";
import { useUndoRedo } from "./useUndoRedo";

const API_BASE_URL =
  process.env.VITE_API_BASE_URL || "http://localhost:5001/api";

const getAuthToken = () => {
  return localStorage.getItem("userToken");
};

const embeddingLevels = bidiNS.embeddingLevels || bidiNS.getEmbeddingLevels;
const reorder = bidiNS.reorder || bidiNS.getReorderedString;

function htmlToPlainTextWithNewlines(html) {
  if (!html) return "";
  let text = html;
  text = text.replace(
    /<(div|p|h[1-6]|li|blockquote|pre|tr|hr)[^>]*>/gi,
    "\n$&"
  );
  text = text.replace(/<br\s*\/?>/gi, "\n");
  text = text.replace(/<[^>]+>/g, "");
  try {
    const tempDiv = document.createElement("div");
    tempDiv.innerHTML = text;
    text = tempDiv.textContent || tempDiv.innerText || "";
  } catch (e) {
    console.error("Error decoding HTML entities for PDF export:", e);
  }
  return text.trim().replace(/(\r\n|\r|\n){2,}/g, "\n");
}

export const assignNewIds = (item, isDuplication = false) => {
  // Ensure this line is correct
  const newItem = { ...item };
  if (
    isDuplication ||
    !item.id ||
    item.id.startsWith("temp-") ||
    item.id.startsWith("client-")
  ) {
    newItem.id = `client-${Date.now().toString(36)}-${Math.random()
      .toString(36)
      .substring(2, 9)}`;
  }
  if (item.type === "folder") {
    newItem.children = Array.isArray(item.children)
      ? item.children.map((child) => assignNewIds(child, isDuplication))
      : [];
  }
  return newItem;
};

export const useTree = () => {
  const EXPANDED_KEY = `${LOCAL_STORAGE_KEY}_expanded`;
  const { settings } = useSettings();

  const initialTreeState = (() => {
    try {
      const stored = localStorage.getItem(LOCAL_STORAGE_KEY);
      const parsed = stored ? JSON.parse(stored) : [];
      return Array.isArray(parsed) ? parsed : [];
    } catch (error) {
      console.error("Failed to load tree from localStorage:", error);
      return [];
    }
  })();

  const {
    state: tree,
    setState: setTreeWithUndo,
    resetState: resetTreeHistory,
    undo: undoTreeChange,
    redo: redoTreeChange,
    canUndo: canUndoTree,
    canRedo: canRedoTree,
  } = useUndoRedo(initialTreeState);

  const [selectedItemId, setSelectedItemId] = useState(null);
  const [contextMenu, setContextMenu] = useState({
    visible: false,
    x: 0,
    y: 0,
    item: null,
    isEmptyArea: false,
  });
  const [expandedFolders, setExpandedFolders] = useState(() => {
    try {
      const stored = localStorage.getItem(EXPANDED_KEY);
      return stored ? JSON.parse(stored) : {};
    } catch {
      return {};
    }
  });
  const [draggedId, setDraggedId] = useState(null);
  const [clipboardItem, setClipboardItem] = useState(null);
  const [clipboardMode, setClipboardMode] = useState(null);
  const [cutItemId, setCutItemId] = useState(null);
  const [isFetchingTree, setIsFetchingTree] = useState(false); // For loading state

  const selectedItem = useMemo(
    () => findItemById(tree, selectedItemId),
    [tree, selectedItemId]
  );

  const fetchUserTreeInternal = useCallback(
    async (token) => {
      if (!token) {
        console.log(
          "fetchUserTreeInternal: No token provided, clearing/resetting tree."
        );
        resetTreeHistory([]); // Or load from localStorage if preferred for logged-out
        setIsFetchingTree(false);
        return;
      }
      setIsFetchingTree(true);
      console.log(
        "fetchUserTreeInternal: Token found, fetching tree from server."
      );
      try {
        const response = await fetch(`${API_BASE_URL}/items/tree`, {
          headers: { Authorization: `Bearer ${token}` },
        });
        console.log(
          "fetchUserTreeInternal: fetchTreeFromServer response status:",
          response.status
        );
        if (!response.ok) {
          const errorData = await response
            .json()
            .catch(() => ({ error: "Failed to parse error response" }));
          if (response.status === 401) {
            console.error(
              "fetchUserTreeInternal: Unauthorized (401). Token might be invalid."
            );
            localStorage.removeItem("userToken"); // Critical: remove invalid token
            // Consider calling a global logout handler if App.jsx passes one down
          } else {
            console.error(
              "fetchUserTreeInternal: Server error fetching tree:",
              response.status,
              errorData
            );
          }
          resetTreeHistory([]); // Clear tree on error
          setIsFetchingTree(false);
          return; // Explicitly return on error
        }
        const data = await response.json();
        if (data && Array.isArray(data.notesTree)) {
          console.log(
            "fetchUserTreeInternal: Successfully fetched tree, resetting local state."
          );
          resetTreeHistory(data.notesTree);
        } else {
          console.warn(
            "fetchUserTreeInternal: Fetched tree data is not in expected format, using empty tree."
          );
          resetTreeHistory([]);
        }
      } catch (error) {
        console.error(
          "fetchUserTreeInternal: Network or other error fetching tree:",
          error
        );
        resetTreeHistory([]); // Clear tree on error
      } finally {
        setIsFetchingTree(false);
      }
    },
    [resetTreeHistory]
  ); // API_BASE_URL is stable

  // Effect for initial load and when token changes (e.g., after login)
  // This will be triggered by App.jsx calling fetchUserTree after login.
  // For initial load, App.jsx will also call this if a token is found.
  // The useEffect that was here before is effectively replaced by App.jsx controlling the fetch.

  useEffect(() => {
    // Persist tree to localStorage
    try {
      if (Array.isArray(tree))
        localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(tree));
    } catch (error) {
      console.error("Failed to save tree to localStorage:", error);
    }
  }, [tree]);

  useEffect(() => {
    // Persist expanded folders
    try {
      localStorage.setItem(EXPANDED_KEY, JSON.stringify(expandedFolders));
    } catch (error) {
      console.error("Failed to save expanded folders:", error);
    }
  }, [expandedFolders]);

  const selectItemById = useCallback((id) => setSelectedItemId(id), []);
  const replaceTree = useCallback(
    (newTreeData) => {
      if (Array.isArray(newTreeData)) {
        resetTreeHistory(newTreeData);
        setSelectedItemId(null);
        setExpandedFolders({});
        return { success: true };
      }
      console.error("replaceTree failed: Data is not an array.", newTreeData);
      return { success: false, error: "Import failed: Invalid data format." };
    },
    [resetTreeHistory]
  );

  const expandFolderPath = useCallback(
    /* ... (Your existing robust expandFolderPath) ... */
    (itemIdToExpand) => {
      if (!itemIdToExpand) return;
      const pathIds = [];
      const findPathRecursive = (nodes, targetId, currentPathSegmentsIds) => {
        for (const node of nodes) {
          if (!node || !node.id) continue;
          if (node.id === targetId) {
            pathIds.push(...currentPathSegmentsIds, node.id);
            return true;
          }
          if (node.type === "folder" && Array.isArray(node.children)) {
            if (
              findPathRecursive(node.children, targetId, [
                ...currentPathSegmentsIds,
                node.id,
              ])
            ) {
              return true;
            }
          }
        }
        return false;
      };
      findPathRecursive(tree, itemIdToExpand, []);
      setExpandedFolders((prev) => {
        const next = { ...prev };
        let changed = false;
        pathIds.forEach((id) => {
          const item = findItemById(tree, id);
          if (item && item.type === "folder" && !next[id]) {
            next[id] = true;
            changed = true;
          }
        });
        const targetItem = findItemById(tree, itemIdToExpand);
        if (
          targetItem &&
          targetItem.type === "folder" &&
          !next[itemIdToExpand]
        ) {
          next[itemIdToExpand] = true;
          changed = true;
        }
        return changed ? next : prev;
      });
    },
    [tree]
  );

  const toggleFolderExpand = useCallback((id, forceState) => {
    if (!id) return;
    setExpandedFolders((prev) => ({
      ...prev,
      [id]: forceState !== undefined ? Boolean(forceState) : !prev[id],
    }));
  }, []);

  const addItem = useCallback(
    /* ... (Your existing addItem with API calls) ... */
    async (newItemData, parentId) => {
      const trimmedLabel = newItemData?.label?.trim();
      if (!trimmedLabel) return { success: false, error: "Label is required." };
      if (!["folder", "note", "task"].includes(newItemData.type))
        return { success: false, error: "Invalid item type." };
      const token = getAuthToken();
      if (!token) return { success: false, error: "Authentication required." };
      const payload = { label: trimmedLabel, type: newItemData.type };
      if (newItemData.type === "note" || newItemData.type === "task")
        payload.content = newItemData.content || "";
      if (newItemData.type === "task")
        payload.completed = !!newItemData.completed;
      try {
        const endpoint = parentId
          ? `${API_BASE_URL}/items/${parentId}`
          : `${API_BASE_URL}/items`;
        const response = await fetch(endpoint, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            Authorization: `Bearer ${token}`,
          },
          body: JSON.stringify(payload),
        });
        const responseData = await response.json();
        if (!response.ok)
          return {
            success: false,
            error:
              responseData.error || `Failed to add item: ${response.status}`,
          };
        const createdItemFromServer = responseData;
        const newTreeState = insertItemRecursive(
          tree,
          parentId,
          createdItemFromServer
        );
        setTreeWithUndo(newTreeState);
        if (parentId && settings.autoExpandNewFolders) {
          setTimeout(() => expandFolderPath(parentId), 0);
        } else if (
          !parentId &&
          createdItemFromServer.type === "folder" &&
          settings.autoExpandNewFolders
        ) {
          setTimeout(() => expandFolderPath(createdItemFromServer.id), 0);
        } // Expand new root folder
        return { success: true, item: createdItemFromServer };
      } catch (error) {
        console.error("addItem API error:", error);
        return { success: false, error: "Network error adding item." };
      }
    },
    [tree, setTreeWithUndo, expandFolderPath, settings.autoExpandNewFolders]
  );

  const updateNoteContent = useCallback(
    /* ... (Your existing updateNoteContent with API calls) ... */
    async (itemId, content) => {
      const token = getAuthToken();
      if (!token) return { success: false, error: "Authentication required." };
      try {
        const response = await fetch(`${API_BASE_URL}/items/${itemId}`, {
          method: "PATCH",
          headers: {
            "Content-Type": "application/json",
            Authorization: `Bearer ${token}`,
          },
          body: JSON.stringify({ content }),
        });
        const updatedItemFromServer = await response.json();
        if (!response.ok)
          return {
            success: false,
            error: updatedItemFromServer.error || "Failed to update note.",
          };
        const mapRecursive = (items, id, serverUpdates) =>
          items.map((i) =>
            i.id === id
              ? { ...i, ...serverUpdates }
              : Array.isArray(i.children)
              ? { ...i, children: mapRecursive(i.children, id, serverUpdates) }
              : i
          );
        const newTreeState = mapRecursive(tree, itemId, updatedItemFromServer);
        setTreeWithUndo(newTreeState);
        return { success: true, item: updatedItemFromServer };
      } catch (error) {
        console.error("updateNoteContent API error:", error);
        return { success: false, error: "Network error updating note." };
      }
    },
    [tree, setTreeWithUndo]
  );

  const updateTask = useCallback(
    /* ... (Your existing updateTask with API calls) ... */
    async (taskId, clientUpdates) => {
      const token = getAuthToken();
      if (!token) return { success: false, error: "Authentication required." };
      try {
        const response = await fetch(`${API_BASE_URL}/items/${taskId}`, {
          method: "PATCH",
          headers: {
            "Content-Type": "application/json",
            Authorization: `Bearer ${token}`,
          },
          body: JSON.stringify(clientUpdates),
        });
        const updatedItemFromServer = await response.json();
        if (!response.ok)
          return {
            success: false,
            error: updatedItemFromServer.error || "Failed to update task.",
          };
        const mapRecursiveTask = (items, id, serverUpdates) =>
          items.map((i) =>
            i.id === id && i.type === "task"
              ? { ...i, ...serverUpdates }
              : Array.isArray(i.children)
              ? {
                  ...i,
                  children: mapRecursiveTask(i.children, id, serverUpdates),
                }
              : i
          );
        const newTreeState = mapRecursiveTask(
          tree,
          taskId,
          updatedItemFromServer
        );
        setTreeWithUndo(newTreeState);
        return { success: true, item: updatedItemFromServer };
      } catch (error) {
        console.error("updateTask API error:", error);
        return { success: false, error: "Network error updating task." };
      }
    },
    [tree, setTreeWithUndo]
  );

  const renameItem = useCallback(
    /* ... (Your existing renameItem with API calls) ... */
    async (itemId, newLabel) => {
      const trimmedLabel = newLabel?.trim();
      if (!trimmedLabel || !itemId)
        return { success: false, error: "Invalid ID or name." };
      const token = getAuthToken();
      if (!token) return { success: false, error: "Authentication required." };
      const { parentArray } = findParentAndSiblings(tree, itemId);
      if (hasSiblingWithName(parentArray || [], trimmedLabel, itemId)) {
        return {
          success: false,
          error: `Item "${trimmedLabel}" already exists.`,
        };
      }
      try {
        const response = await fetch(`${API_BASE_URL}/items/${itemId}`, {
          method: "PATCH",
          headers: {
            "Content-Type": "application/json",
            Authorization: `Bearer ${token}`,
          },
          body: JSON.stringify({ label: trimmedLabel }),
        });
        const updatedItemFromServer = await response.json();
        if (!response.ok)
          return {
            success: false,
            error: updatedItemFromServer.error || "Rename failed.",
          };
        const newTreeState = renameItemRecursive(
          tree,
          itemId,
          updatedItemFromServer.label
        );
        setTreeWithUndo(newTreeState);
        return { success: true, item: updatedItemFromServer };
      } catch (error) {
        console.error("renameItem API error:", error);
        return { success: false, error: "Network error renaming." };
      }
    },
    [tree, setTreeWithUndo]
  );

  const deleteItem = useCallback(
    /* ... (Your existing deleteItem with API calls) ... */
    async (idToDelete) => {
      if (!idToDelete) return { success: false, error: "No ID for deletion." };
      const token = getAuthToken();
      if (!token) return { success: false, error: "Authentication required." };
      try {
        const response = await fetch(`${API_BASE_URL}/items/${idToDelete}`, {
          method: "DELETE",
          headers: { Authorization: `Bearer ${token}` },
        });
        if (!response.ok && response.status !== 404) {
          const errorData = await response.json().catch(() => ({}));
          return {
            success: false,
            error: errorData.error || "Delete failed on server.",
          };
        }
        const newTreeState = deleteItemRecursive(tree, idToDelete);
        setTreeWithUndo(newTreeState);
        if (selectedItemId === idToDelete) setSelectedItemId(null);
        setExpandedFolders((prev) => {
          const next = { ...prev };
          if (prev.hasOwnProperty(idToDelete)) delete next[idToDelete];
          return next;
        });
        // setContextMenu((m) => (m.visible ? { ...m, visible: false } : m)); // Usually handled by App.jsx
        return { success: true };
      } catch (error) {
        console.error("deleteItem API error:", error);
        return { success: false, error: "Network error deleting." };
      }
    },
    [tree, selectedItemId, setTreeWithUndo /* setContextMenu not a direct dep*/]
  );

  const duplicateItem = useCallback(
    /* ... (Your existing duplicateItem, ensure it calls addItem for DB persistence) ... */
    async (itemId) => {
      const itemToDuplicate = findItemById(tree, itemId);
      if (!itemToDuplicate)
        return { success: false, error: "Item to duplicate not found." };
      const { parent } = findParentAndSiblings(tree, itemId);
      const parentId = parent?.id ?? null;
      let newDuplicate = assignNewIds(structuredClone(itemToDuplicate), true);
      let baseName = itemToDuplicate.label;
      let newLabel = `${baseName} (copy)`;
      let counter = 1;
      const targetSiblings = parentId
        ? findItemById(tree, parentId)?.children || []
        : tree;
      while (hasSiblingWithName(targetSiblings, newLabel, null)) {
        counter++;
        newLabel = `${baseName} (copy ${counter})`;
      }
      newDuplicate.label = newLabel;
      const result = await addItem(newDuplicate, parentId);
      if (result.success && result.item) {
        if (parentId && settings.autoExpandNewFolders) {
          setTimeout(() => expandFolderPath(parentId), 0);
        }
        return { success: true, item: result.item };
      } else {
        return {
          success: false,
          error: result.error || "Failed to save duplicated item.",
        };
      }
    },
    [tree, addItem, settings.autoExpandNewFolders, expandFolderPath]
  );

  const handleDrop = useCallback(
    /* ... (Your existing handleDrop, still mostly client-side for DB) ... */
    async (targetFolderId, droppedItemId) => {
      console.warn(
        "useTree: handleDrop (moving items) is client-side for DB persistence. Needs server endpoint."
      );
      const currentDraggedId = droppedItemId || draggedId;
      setDraggedId(null);
      if (!currentDraggedId || targetFolderId === currentDraggedId)
        return { success: false, error: "Invalid drop." };
      const itemToDrop = findItemById(tree, currentDraggedId);
      const targetFolder = findItemById(tree, targetFolderId);
      if (!itemToDrop || !targetFolder || targetFolder.type !== "folder")
        return { success: false, error: "Invalid item or target folder." };
      if (
        itemToDrop.type === "folder" &&
        isSelfOrDescendant(tree, itemToDrop.id, targetFolderId)
      ) {
        return {
          success: false,
          error: "Cannot drop folder into itself or one of its descendants.",
        };
      }
      if (
        hasSiblingWithName(targetFolder.children || [], itemToDrop.label, null)
      ) {
        return {
          success: false,
          error: `Item named "${itemToDrop.label}" already exists in the target folder.`,
        };
      }
      const newTreeState = treeHandleDropUtil(
        tree,
        targetFolderId,
        currentDraggedId
      );
      if (newTreeState) {
        setTreeWithUndo(newTreeState);
        if (settings.autoExpandNewFolders && targetFolderId) {
          setTimeout(() => expandFolderPath(targetFolderId), 0);
        }
        return {
          success: true,
          message:
            "Local drop successful. Server persistence for item move not yet implemented.",
        };
      }
      return { success: false, error: "Local drop simulation failed." };
    },
    [
      tree,
      draggedId,
      setTreeWithUndo,
      settings.autoExpandNewFolders,
      expandFolderPath,
      treeHandleDropUtil,
    ]
  );

  const copyItem = useCallback(
    /* ... (Your existing copyItem) ... */
    (itemId) => {
      const itemToCopy = findItemById(tree, itemId);
      if (itemToCopy) {
        try {
          const deepCopy = structuredClone(itemToCopy);
          setClipboardItem(deepCopy);
          setClipboardMode("copy");
          setCutItemId(null);
        } catch (e) {
          console.error("Error copying item:", e);
          setClipboardItem(null);
          setClipboardMode(null);
          setCutItemId(null);
        }
      }
    },
    [tree]
  );

  const cutItem = useCallback(
    /* ... (Your existing cutItem) ... */
    (itemId) => {
      const itemToCut = findItemById(tree, itemId);
      if (itemToCut) {
        try {
          const deepCopy = structuredClone(itemToCut);
          setClipboardItem(deepCopy);
          setClipboardMode("cut");
          setCutItemId(itemId);
        } catch (e) {
          console.error("Error cutting item:", e);
          setClipboardItem(null);
          setClipboardMode(null);
          setCutItemId(null);
        }
      }
    },
    [tree]
  );

  const pasteItem = useCallback(
    /* ... (Your existing pasteItem, 'copy' uses addItem, 'cut' is client-side for DB) ... */
    async (targetFolderId) => {
      console.warn(
        "useTree: pasteItem: 'cut' persistence needs backend. 'copy' uses addItem."
      );
      if (!clipboardItem)
        return { success: false, error: "Clipboard is empty." };
      const targetParent = targetFolderId
        ? findItemById(tree, targetFolderId)
        : null;
      if (targetFolderId && (!targetParent || targetParent.type !== "folder")) {
        return {
          success: false,
          error: "Target for paste must be a valid folder or root.",
        };
      }
      if (
        clipboardItem.type === "folder" &&
        isSelfOrDescendant(tree, clipboardItem.id, targetFolderId)
      ) {
        return {
          success: false,
          error: "Cannot paste a folder into itself or one of its descendants.",
        };
      }
      const targetSiblings = targetFolderId
        ? targetParent?.children || []
        : tree;
      let itemToInsert = structuredClone(clipboardItem);
      if (clipboardMode === "copy") {
        itemToInsert = assignNewIds(itemToInsert, true);
        let baseName = itemToInsert.label;
        let newLabel = baseName;
        let copyCounter = 0;
        while (hasSiblingWithName(targetSiblings, newLabel, null)) {
          copyCounter++;
          newLabel = `${baseName} (copy${
            copyCounter > 1 ? ` ${copyCounter}` : ""
          })`;
        }
        itemToInsert.label = newLabel;
        const addResult = await addItem(itemToInsert, targetFolderId);
        if (
          addResult.success &&
          targetFolderId &&
          settings.autoExpandNewFolders
        )
          expandFolderPath(targetFolderId);
        return addResult;
      } else if (clipboardMode === "cut" && cutItemId) {
        if (
          cutItemId === targetFolderId &&
          findParentAndSiblings(tree, cutItemId)?.parent?.id === targetFolderId
        ) {
          setClipboardItem(null);
          setClipboardMode(null);
          setCutItemId(null);
          return {
            success: true,
            item: itemToInsert,
            message: "Item 'pasted' in the same location.",
          };
        }
        if (
          findParentAndSiblings(tree, cutItemId)?.parent?.id !==
            targetFolderId &&
          hasSiblingWithName(targetSiblings, itemToInsert.label, null)
        ) {
          // Check if name exists unless it's the same item not changing name context
          return {
            success: false,
            error: `An item named "${itemToInsert.label}" already exists in the target folder.`,
          };
        }
        console.warn(
          "Cut & Paste: Persistence of item move not fully implemented on backend. Simulating client-side."
        );
        let tempTree = deleteItemRecursive(tree, cutItemId);
        tempTree = insertItemRecursive(tempTree, targetFolderId, itemToInsert);
        setTreeWithUndo(tempTree);
        setClipboardItem(null);
        setClipboardMode(null);
        setCutItemId(null);
        if (targetFolderId && settings.autoExpandNewFolders)
          expandFolderPath(targetFolderId);
        return {
          success: true,
          item: itemToInsert,
          message:
            "Item moved locally. Server persistence for move needs to be implemented.",
        };
      }
      return { success: false, error: "Invalid paste operation." };
    },
    [
      tree,
      clipboardItem,
      clipboardMode,
      cutItemId,
      setTreeWithUndo,
      settings.autoExpandNewFolders,
      expandFolderPath,
      addItem,
    ]
  );

  const handleExport = useCallback(
    /* ... (Your existing handleExport, no DB interaction) ... */
    (target, format) => {
      let dataToExport;
      let fileName;
      const currentSelectedItem = findItemById(tree, selectedItemId);
      if (target === "selected") {
        if (!currentSelectedItem) {
          alert("No item selected.");
          return;
        }
        dataToExport = currentSelectedItem;
        fileName = `${currentSelectedItem.label}-export`;
      } else {
        dataToExport = tree;
        fileName = "tree-export";
      }
      if (format === "json") {
        try {
          const jsonStr = JSON.stringify(dataToExport, null, 2);
          const blob = new Blob([jsonStr], { type: "application/json" });
          const url = URL.createObjectURL(blob);
          const a = document.createElement("a");
          a.href = url;
          a.download = fileName + ".json";
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(url);
        } catch (error) {
          console.error("JSON export failed:", error);
          alert("Failed to export JSON.");
        }
      } else if (format === "pdf") {
        /* ... your PDF logic ... */
      }
    },
    [tree, selectedItemId]
  );

  // ** MODIFIED handleImport to use PUT for both "entire" and "selected" (by sending full tree) **
  const handleImport = useCallback(
    async (file, importTargetOption) => {
      return new Promise((resolveOuter) => {
        if (!file || file.type !== "application/json") {
          resolveOuter({ success: false, error: "Please select a JSON file." });
          return;
        }
        const reader = new FileReader();
        reader.onload = async (e) => {
          try {
            const importedData = JSON.parse(e.target.result);
            const token = getAuthToken();
            if (!token) {
              resolveOuter({
                success: false,
                error: "Authentication required to save imported data.",
              });
              return;
            }

            let processedTreeForServer;

            if (importTargetOption === "entire") {
              processedTreeForServer = Array.isArray(importedData)
                ? importedData.map((i) =>
                    assignNewIds(structuredClone(i), true)
                  )
                : [assignNewIds(structuredClone(i), true)];
              console.log(
                "Attempting to save entire imported tree to server (from 'entire' option):",
                processedTreeForServer.length,
                "items"
              );
            } else {
              // "selected" - import under an item
              const currentSel = findItemById(tree, selectedItemId);
              if (currentSel && currentSel.type === "folder") {
                const itemsToInsert = Array.isArray(importedData)
                  ? importedData.map((i) =>
                      assignNewIds(structuredClone(i), true)
                    )
                  : [assignNewIds(structuredClone(importedData), true)];

                let tempTree = [...tree]; // Start with a fresh copy of the current tree
                itemsToInsert.forEach((it) => {
                  if (!it.label || !it.type || !it.id) {
                    console.warn(
                      "Skipping invalid item during import under selected:",
                      it
                    );
                    return;
                  }
                  // Ensure no name conflicts before inserting
                  const parentForInsert = findItemById(tempTree, currentSel.id); // Find parent in potentially modified tempTree
                  const siblingsForInsert = parentForInsert?.children || [];
                  if (hasSiblingWithName(siblingsForInsert, it.label, null)) {
                    // Handle name conflict, e.g., by renaming 'it' or skipping
                    console.warn(
                      `Name conflict for "${it.label}" under "${currentSel.label}". Skipping item or implement renaming.`
                    );
                    // For now, skip: (or you could try to auto-rename 'it.label' here)
                    // return; // Or, if you must insert, it might overwrite or backend might reject
                  }
                  tempTree = insertItemRecursive(tempTree, currentSel.id, it);
                });
                processedTreeForServer = tempTree;
                console.log(
                  "Attempting to save modified tree (import under selected) to server:",
                  processedTreeForServer.length,
                  "root items"
                );
              } else {
                resolveOuter({
                  success: false,
                  error: "Target for import must be a selected folder.",
                });
                return;
              }
            }

            const response = await fetch(`${API_BASE_URL}/items/tree`, {
              method: "PUT",
              headers: {
                "Content-Type": "application/json",
                Authorization: `Bearer ${token}`,
              },
              body: JSON.stringify({ newTree: processedTreeForServer }),
            });
            const responseData = await response.json();

            if (!response.ok) {
              console.error("Server error saving imported tree:", responseData);
              resolveOuter({
                success: false,
                error:
                  responseData.error ||
                  "Failed to save imported tree to server.",
              });
              return;
            }

            replaceTree(responseData.notesTree || processedTreeForServer);

            if (
              importTargetOption === "selected" &&
              selectedItemId &&
              settings.autoExpandNewFolders
            ) {
              expandFolderPath(selectedItemId);
            } else if (
              importTargetOption === "entire" &&
              responseData.notesTree?.length > 0 &&
              responseData.notesTree[0].type === "folder" &&
              settings.autoExpandNewFolders
            ) {
              expandFolderPath(responseData.notesTree[0].id); // Expand first root folder if any
            }

            resolveOuter({
              success: true,
              message:
                responseData.message || "Data imported and saved successfully.",
            });
          } catch (err) {
            console.error("Import processing error:", err);
            resolveOuter({
              success: false,
              error: `Import error: ${err.message}`,
            });
          }
        };
        reader.onerror = () => {
          console.error("File read error during import.");
          resolveOuter({ success: false, error: "File read error." });
        };
        reader.readAsText(file);
      });
    },
    [
      tree,
      selectedItemId,
      replaceTree,
      settings.autoExpandNewFolders,
      expandFolderPath,
    ]
  );

  const searchItems = useCallback(
    (query, opts) => {
      // Your existing searchItems
      if (!query) return [];
      const results = [];
      const currentTree = tree || [];
      const walk = (nodes, currentPathSegments = []) => {
        if (!Array.isArray(nodes)) return;
        nodes.forEach((it) => {
          if (!it || typeof it.label !== "string") return;
          const itemPath = [...currentPathSegments, it.label].join(" / ");
          if (itemMatches(it, query, opts)) {
            results.push({ ...it, path: itemPath });
          }
          if (it.type === "folder" && Array.isArray(it.children)) {
            walk(it.children, [...currentPathSegments, it.label]);
          }
        });
      };
      walk(currentTree, []);
      return results;
    },
    [tree]
  );

  return {
    tree,
    selectedItem,
    selectedItemId,
    contextMenu,
    expandedFolders,
    draggedId,
    clipboardItem,
    clipboardMode,
    cutItemId,
    setContextMenu,
    setDraggedId,
    selectItemById,
    toggleFolderExpand,
    updateNoteContent,
    updateTask,
    addItem,
    renameItem,
    deleteItem,
    duplicateItem,
    handleDrop,
    copyItem,
    cutItem,
    pasteItem,
    handleExport,
    handleImport,
    searchItems,
    getItemPath,
    expandFolderPath,
    undoTreeChange,
    redoTreeChange,
    canUndoTree,
    canRedoTree,
    resetState: resetTreeHistory,
    fetchUserTree: fetchUserTreeInternal, // Expose the internal fetch function
    isFetchingTree, // Expose loading state
  };
};


--- src\hooks\useUndoRedo.js ---
// src/hooks/useUndoRedo.js
import { useState, useCallback } from 'react';

const MAX_HISTORY_SIZE = 50; // Max number of states to keep in history

export const useUndoRedo = (initialPresent) => {
    const [history, setHistory] = useState({
        past: [],
        present: initialPresent,
        future: [],
    });

    const canUndo = history.past.length > 0;
    const canRedo = history.future.length > 0;

    const setPresentState = useCallback((newPresent) => {
        setHistory(h => {
            const newPast = [...h.past, h.present];
            // Limit history size
            if (newPast.length > MAX_HISTORY_SIZE) {
                newPast.shift(); // Remove the oldest state
            }
            return {
                past: newPast,
                present: newPresent,
                future: [], // Clear future on new action
            };
        });
    }, []);

    const undo = useCallback(() => {
        if (!canUndo) return;
        setHistory(h => {
            const newFuture = [h.present, ...h.future];
            const newPresent = h.past[h.past.length - 1];
            const newPast = h.past.slice(0, h.past.length - 1);
            return {
                past: newPast,
                present: newPresent,
                future: newFuture,
            };
        });
    }, [canUndo]);

    const redo = useCallback(() => {
        if (!canRedo) return;
        setHistory(h => {
            const newPast = [...h.past, h.present];
            const newPresent = h.future[0];
            const newFuture = h.future.slice(1);
            return {
                past: newPast,
                present: newPresent,
                future: newFuture,
            };
        });
    }, [canRedo]);

    // This function is used when you load data (e.g., from localStorage or import)
    // to reset the history with a new present state.
    const resetHistory = useCallback((newInitialPresent) => {
        setHistory({
            past: [],
            present: newInitialPresent,
            future: [],
        });
    }, []);


    return {
        state: history.present,
        setState: setPresentState, // Renamed for clarity when using the hook
        resetState: resetHistory, // For initializing or resetting the state entirely
        undo,
        redo,
        canUndo,
        canRedo,
        // Expose past and future if needed for debugging or more complex scenarios
        // pastStates: history.past,
        // futureStates: history.future,
    };
};

--- src\hooks\useTree.jsx ---
// src/hooks/useTree.jsx
import React, { useState, useEffect, useCallback, useMemo } from "react";
import { LOCAL_STORAGE_KEY } from "../utils/constants";
import {
  sortItems,
  handleDrop as treeHandleDropUtil,
  deleteItemRecursive,
  renameItemRecursive,
  insertItemRecursive,
  isSelfOrDescendant,
  findItemById,
  findParentAndSiblings,
  hasSiblingWithName,
  getItemPath,
} from "../utils/treeUtils";
import { jsPDF } from "jspdf";
import * as bidiNS from "unicode-bidirectional";
import { notoSansHebrewBase64 } from "../fonts/NotoSansHebrewBase64";
import { useSettings } from "../contexts/SettingsContext";
import { itemMatches } from "../utils/searchUtils";
import { useUndoRedo } from "./useUndoRedo";

const API_BASE_URL =
  process.env.VITE_API_BASE_URL || "http://localhost:5001/api";

const getAuthToken = () => {
  return localStorage.getItem("userToken");
};

const embeddingLevels = bidiNS.embeddingLevels || bidiNS.getEmbeddingLevels;
const reorder = bidiNS.reorder || bidiNS.getReorderedString;

function htmlToPlainTextWithNewlines(html) {
  if (!html) return "";
  let text = html;
  text = text.replace(
    /<(div|p|h[1-6]|li|blockquote|pre|tr|hr)[^>]*>/gi,
    "\n$&"
  );
  text = text.replace(/<br\s*\/?>/gi, "\n");
  text = text.replace(/<[^>]+>/g, "");
  try {
    const tempDiv = document.createElement("div");
    tempDiv.innerHTML = text;
    text = tempDiv.textContent || tempDiv.innerText || "";
  } catch (e) {
    console.error("Error decoding HTML entities for PDF export:", e);
  }
  return text.trim().replace(/(\r\n|\r|\n){2,}/g, "\n");
}

export const assignNewIds = (item, isDuplication = false) => {
  // Ensure this line is correct
  const newItem = { ...item };
  if (
    isDuplication ||
    !item.id ||
    item.id.startsWith("temp-") ||
    item.id.startsWith("client-")
  ) {
    newItem.id = `client-${Date.now().toString(36)}-${Math.random()
      .toString(36)
      .substring(2, 9)}`;
  }
  if (item.type === "folder") {
    newItem.children = Array.isArray(item.children)
      ? item.children.map((child) => assignNewIds(child, isDuplication))
      : [];
  }
  return newItem;
};

export const useTree = () => {
  const EXPANDED_KEY = `${LOCAL_STORAGE_KEY}_expanded`;
  const { settings } = useSettings();

  const initialTreeState = (() => {
    try {
      const stored = localStorage.getItem(LOCAL_STORAGE_KEY);
      const parsed = stored ? JSON.parse(stored) : [];
      return Array.isArray(parsed) ? parsed : [];
    } catch (error) {
      console.error("Failed to load tree from localStorage:", error);
      return [];
    }
  })();

  const {
    state: tree,
    setState: setTreeWithUndo,
    resetState: resetTreeHistory,
    undo: undoTreeChange,
    redo: redoTreeChange,
    canUndo: canUndoTree,
    canRedo: canRedoTree,
  } = useUndoRedo(initialTreeState);

  const [selectedItemId, setSelectedItemId] = useState(null);
  const [contextMenu, setContextMenu] = useState({
    visible: false,
    x: 0,
    y: 0,
    item: null,
    isEmptyArea: false,
  });
  const [expandedFolders, setExpandedFolders] = useState(() => {
    try {
      const stored = localStorage.getItem(EXPANDED_KEY);
      return stored ? JSON.parse(stored) : {};
    } catch {
      return {};
    }
  });
  const [draggedId, setDraggedId] = useState(null);
  const [clipboardItem, setClipboardItem] = useState(null);
  const [clipboardMode, setClipboardMode] = useState(null);
  const [cutItemId, setCutItemId] = useState(null);
  const [isFetchingTree, setIsFetchingTree] = useState(false); // For loading state

  const selectedItem = useMemo(
    () => findItemById(tree, selectedItemId),
    [tree, selectedItemId]
  );

  const fetchUserTreeInternal = useCallback(
    async (token) => {
      if (!token) {
        console.log(
          "fetchUserTreeInternal: No token provided, clearing/resetting tree."
        );
        resetTreeHistory([]); // Or load from localStorage if preferred for logged-out
        setIsFetchingTree(false);
        return;
      }
      setIsFetchingTree(true);
      console.log(
        "fetchUserTreeInternal: Token found, fetching tree from server."
      );
      try {
        const response = await fetch(`${API_BASE_URL}/items/tree`, {
          headers: { Authorization: `Bearer ${token}` },
        });
        console.log(
          "fetchUserTreeInternal: fetchTreeFromServer response status:",
          response.status
        );
        if (!response.ok) {
          const errorData = await response
            .json()
            .catch(() => ({ error: "Failed to parse error response" }));
          if (response.status === 401) {
            console.error(
              "fetchUserTreeInternal: Unauthorized (401). Token might be invalid."
            );
            localStorage.removeItem("userToken"); // Critical: remove invalid token
            // Consider calling a global logout handler if App.jsx passes one down
          } else {
            console.error(
              "fetchUserTreeInternal: Server error fetching tree:",
              response.status,
              errorData
            );
          }
          resetTreeHistory([]); // Clear tree on error
          setIsFetchingTree(false);
          return; // Explicitly return on error
        }
        const data = await response.json();
        if (data && Array.isArray(data.notesTree)) {
          console.log(
            "fetchUserTreeInternal: Successfully fetched tree, resetting local state."
          );
          resetTreeHistory(data.notesTree);
        } else {
          console.warn(
            "fetchUserTreeInternal: Fetched tree data is not in expected format, using empty tree."
          );
          resetTreeHistory([]);
        }
      } catch (error) {
        console.error(
          "fetchUserTreeInternal: Network or other error fetching tree:",
          error
        );
        resetTreeHistory([]); // Clear tree on error
      } finally {
        setIsFetchingTree(false);
      }
    },
    [resetTreeHistory]
  ); // API_BASE_URL is stable

  // Effect for initial load and when token changes (e.g., after login)
  // This will be triggered by App.jsx calling fetchUserTree after login.
  // For initial load, App.jsx will also call this if a token is found.
  // The useEffect that was here before is effectively replaced by App.jsx controlling the fetch.

  useEffect(() => {
    // Persist tree to localStorage
    try {
      if (Array.isArray(tree))
        localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(tree));
    } catch (error) {
      console.error("Failed to save tree to localStorage:", error);
    }
  }, [tree]);

  useEffect(() => {
    // Persist expanded folders
    try {
      localStorage.setItem(EXPANDED_KEY, JSON.stringify(expandedFolders));
    } catch (error) {
      console.error("Failed to save expanded folders:", error);
    }
  }, [expandedFolders]);

  const selectItemById = useCallback((id) => setSelectedItemId(id), []);
  const replaceTree = useCallback(
    (newTreeData) => {
      if (Array.isArray(newTreeData)) {
        resetTreeHistory(newTreeData);
        setSelectedItemId(null);
        setExpandedFolders({});
        return { success: true };
      }
      console.error("replaceTree failed: Data is not an array.", newTreeData);
      return { success: false, error: "Import failed: Invalid data format." };
    },
    [resetTreeHistory]
  );

  const expandFolderPath = useCallback(
    /* ... (Your existing robust expandFolderPath) ... */
    (itemIdToExpand) => {
      if (!itemIdToExpand) return;
      const pathIds = [];
      const findPathRecursive = (nodes, targetId, currentPathSegmentsIds) => {
        for (const node of nodes) {
          if (!node || !node.id) continue;
          if (node.id === targetId) {
            pathIds.push(...currentPathSegmentsIds, node.id);
            return true;
          }
          if (node.type === "folder" && Array.isArray(node.children)) {
            if (
              findPathRecursive(node.children, targetId, [
                ...currentPathSegmentsIds,
                node.id,
              ])
            ) {
              return true;
            }
          }
        }
        return false;
      };
      findPathRecursive(tree, itemIdToExpand, []);
      setExpandedFolders((prev) => {
        const next = { ...prev };
        let changed = false;
        pathIds.forEach((id) => {
          const item = findItemById(tree, id);
          if (item && item.type === "folder" && !next[id]) {
            next[id] = true;
            changed = true;
          }
        });
        const targetItem = findItemById(tree, itemIdToExpand);
        if (
          targetItem &&
          targetItem.type === "folder" &&
          !next[itemIdToExpand]
        ) {
          next[itemIdToExpand] = true;
          changed = true;
        }
        return changed ? next : prev;
      });
    },
    [tree]
  );

  const toggleFolderExpand = useCallback((id, forceState) => {
    if (!id) return;
    setExpandedFolders((prev) => ({
      ...prev,
      [id]: forceState !== undefined ? Boolean(forceState) : !prev[id],
    }));
  }, []);

  const addItem = useCallback(
    /* ... (Your existing addItem with API calls) ... */
    async (newItemData, parentId) => {
      const trimmedLabel = newItemData?.label?.trim();
      if (!trimmedLabel) return { success: false, error: "Label is required." };
      if (!["folder", "note", "task"].includes(newItemData.type))
        return { success: false, error: "Invalid item type." };
      const token = getAuthToken();
      if (!token) return { success: false, error: "Authentication required." };
      const payload = { label: trimmedLabel, type: newItemData.type };
      if (newItemData.type === "note" || newItemData.type === "task")
        payload.content = newItemData.content || "";
      if (newItemData.type === "task")
        payload.completed = !!newItemData.completed;
      try {
        const endpoint = parentId
          ? `${API_BASE_URL}/items/${parentId}`
          : `${API_BASE_URL}/items`;
        const response = await fetch(endpoint, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            Authorization: `Bearer ${token}`,
          },
          body: JSON.stringify(payload),
        });
        const responseData = await response.json();
        if (!response.ok)
          return {
            success: false,
            error:
              responseData.error || `Failed to add item: ${response.status}`,
          };
        const createdItemFromServer = responseData;
        const newTreeState = insertItemRecursive(
          tree,
          parentId,
          createdItemFromServer
        );
        setTreeWithUndo(newTreeState);
        if (parentId && settings.autoExpandNewFolders) {
          setTimeout(() => expandFolderPath(parentId), 0);
        } else if (
          !parentId &&
          createdItemFromServer.type === "folder" &&
          settings.autoExpandNewFolders
        ) {
          setTimeout(() => expandFolderPath(createdItemFromServer.id), 0);
        } // Expand new root folder
        return { success: true, item: createdItemFromServer };
      } catch (error) {
        console.error("addItem API error:", error);
        return { success: false, error: "Network error adding item." };
      }
    },
    [tree, setTreeWithUndo, expandFolderPath, settings.autoExpandNewFolders]
  );

  const updateNoteContent = useCallback(
    /* ... (Your existing updateNoteContent with API calls) ... */
    async (itemId, content) => {
      const token = getAuthToken();
      if (!token) return { success: false, error: "Authentication required." };
      try {
        const response = await fetch(`${API_BASE_URL}/items/${itemId}`, {
          method: "PATCH",
          headers: {
            "Content-Type": "application/json",
            Authorization: `Bearer ${token}`,
          },
          body: JSON.stringify({ content }),
        });
        const updatedItemFromServer = await response.json();
        if (!response.ok)
          return {
            success: false,
            error: updatedItemFromServer.error || "Failed to update note.",
          };
        const mapRecursive = (items, id, serverUpdates) =>
          items.map((i) =>
            i.id === id
              ? { ...i, ...serverUpdates }
              : Array.isArray(i.children)
              ? { ...i, children: mapRecursive(i.children, id, serverUpdates) }
              : i
          );
        const newTreeState = mapRecursive(tree, itemId, updatedItemFromServer);
        setTreeWithUndo(newTreeState);
        return { success: true, item: updatedItemFromServer };
      } catch (error) {
        console.error("updateNoteContent API error:", error);
        return { success: false, error: "Network error updating note." };
      }
    },
    [tree, setTreeWithUndo]
  );

  const updateTask = useCallback(
    /* ... (Your existing updateTask with API calls) ... */
    async (taskId, clientUpdates) => {
      const token = getAuthToken();
      if (!token) return { success: false, error: "Authentication required." };
      try {
        const response = await fetch(`${API_BASE_URL}/items/${taskId}`, {
          method: "PATCH",
          headers: {
            "Content-Type": "application/json",
            Authorization: `Bearer ${token}`,
          },
          body: JSON.stringify(clientUpdates),
        });
        const updatedItemFromServer = await response.json();
        if (!response.ok)
          return {
            success: false,
            error: updatedItemFromServer.error || "Failed to update task.",
          };
        const mapRecursiveTask = (items, id, serverUpdates) =>
          items.map((i) =>
            i.id === id && i.type === "task"
              ? { ...i, ...serverUpdates }
              : Array.isArray(i.children)
              ? {
                  ...i,
                  children: mapRecursiveTask(i.children, id, serverUpdates),
                }
              : i
          );
        const newTreeState = mapRecursiveTask(
          tree,
          taskId,
          updatedItemFromServer
        );
        setTreeWithUndo(newTreeState);
        return { success: true, item: updatedItemFromServer };
      } catch (error) {
        console.error("updateTask API error:", error);
        return { success: false, error: "Network error updating task." };
      }
    },
    [tree, setTreeWithUndo]
  );

  const renameItem = useCallback(
    /* ... (Your existing renameItem with API calls) ... */
    async (itemId, newLabel) => {
      const trimmedLabel = newLabel?.trim();
      if (!trimmedLabel || !itemId)
        return { success: false, error: "Invalid ID or name." };
      const token = getAuthToken();
      if (!token) return { success: false, error: "Authentication required." };
      const { parentArray } = findParentAndSiblings(tree, itemId);
      if (hasSiblingWithName(parentArray || [], trimmedLabel, itemId)) {
        return {
          success: false,
          error: `Item "${trimmedLabel}" already exists.`,
        };
      }
      try {
        const response = await fetch(`${API_BASE_URL}/items/${itemId}`, {
          method: "PATCH",
          headers: {
            "Content-Type": "application/json",
            Authorization: `Bearer ${token}`,
          },
          body: JSON.stringify({ label: trimmedLabel }),
        });
        const updatedItemFromServer = await response.json();
        if (!response.ok)
          return {
            success: false,
            error: updatedItemFromServer.error || "Rename failed.",
          };
        const newTreeState = renameItemRecursive(
          tree,
          itemId,
          updatedItemFromServer.label
        );
        setTreeWithUndo(newTreeState);
        return { success: true, item: updatedItemFromServer };
      } catch (error) {
        console.error("renameItem API error:", error);
        return { success: false, error: "Network error renaming." };
      }
    },
    [tree, setTreeWithUndo]
  );

  const deleteItem = useCallback(
    /* ... (Your existing deleteItem with API calls) ... */
    async (idToDelete) => {
      if (!idToDelete) return { success: false, error: "No ID for deletion." };
      const token = getAuthToken();
      if (!token) return { success: false, error: "Authentication required." };
      try {
        const response = await fetch(`${API_BASE_URL}/items/${idToDelete}`, {
          method: "DELETE",
          headers: { Authorization: `Bearer ${token}` },
        });
        if (!response.ok && response.status !== 404) {
          const errorData = await response.json().catch(() => ({}));
          return {
            success: false,
            error: errorData.error || "Delete failed on server.",
          };
        }
        const newTreeState = deleteItemRecursive(tree, idToDelete);
        setTreeWithUndo(newTreeState);
        if (selectedItemId === idToDelete) setSelectedItemId(null);
        setExpandedFolders((prev) => {
          const next = { ...prev };
          if (prev.hasOwnProperty(idToDelete)) delete next[idToDelete];
          return next;
        });
        // setContextMenu((m) => (m.visible ? { ...m, visible: false } : m)); // Usually handled by App.jsx
        return { success: true };
      } catch (error) {
        console.error("deleteItem API error:", error);
        return { success: false, error: "Network error deleting." };
      }
    },
    [tree, selectedItemId, setTreeWithUndo /* setContextMenu not a direct dep*/]
  );

  const duplicateItem = useCallback(
    /* ... (Your existing duplicateItem, ensure it calls addItem for DB persistence) ... */
    async (itemId) => {
      const itemToDuplicate = findItemById(tree, itemId);
      if (!itemToDuplicate)
        return { success: false, error: "Item to duplicate not found." };
      const { parent } = findParentAndSiblings(tree, itemId);
      const parentId = parent?.id ?? null;
      let newDuplicate = assignNewIds(structuredClone(itemToDuplicate), true);
      let baseName = itemToDuplicate.label;
      let newLabel = `${baseName} (copy)`;
      let counter = 1;
      const targetSiblings = parentId
        ? findItemById(tree, parentId)?.children || []
        : tree;
      while (hasSiblingWithName(targetSiblings, newLabel, null)) {
        counter++;
        newLabel = `${baseName} (copy ${counter})`;
      }
      newDuplicate.label = newLabel;
      const result = await addItem(newDuplicate, parentId);
      if (result.success && result.item) {
        if (parentId && settings.autoExpandNewFolders) {
          setTimeout(() => expandFolderPath(parentId), 0);
        }
        return { success: true, item: result.item };
      } else {
        return {
          success: false,
          error: result.error || "Failed to save duplicated item.",
        };
      }
    },
    [tree, addItem, settings.autoExpandNewFolders, expandFolderPath]
  );

  const handleDrop = useCallback(
    /* ... (Your existing handleDrop, still mostly client-side for DB) ... */
    async (targetFolderId, droppedItemId) => {
      console.warn(
        "useTree: handleDrop (moving items) is client-side for DB persistence. Needs server endpoint."
      );
      const currentDraggedId = droppedItemId || draggedId;
      setDraggedId(null);
      if (!currentDraggedId || targetFolderId === currentDraggedId)
        return { success: false, error: "Invalid drop." };
      const itemToDrop = findItemById(tree, currentDraggedId);
      const targetFolder = findItemById(tree, targetFolderId);
      if (!itemToDrop || !targetFolder || targetFolder.type !== "folder")
        return { success: false, error: "Invalid item or target folder." };
      if (
        itemToDrop.type === "folder" &&
        isSelfOrDescendant(tree, itemToDrop.id, targetFolderId)
      ) {
        return {
          success: false,
          error: "Cannot drop folder into itself or one of its descendants.",
        };
      }
      if (
        hasSiblingWithName(targetFolder.children || [], itemToDrop.label, null)
      ) {
        return {
          success: false,
          error: `Item named "${itemToDrop.label}" already exists in the target folder.`,
        };
      }
      const newTreeState = treeHandleDropUtil(
        tree,
        targetFolderId,
        currentDraggedId
      );
      if (newTreeState) {
        setTreeWithUndo(newTreeState);
        if (settings.autoExpandNewFolders && targetFolderId) {
          setTimeout(() => expandFolderPath(targetFolderId), 0);
        }
        return {
          success: true,
          message:
            "Local drop successful. Server persistence for item move not yet implemented.",
        };
      }
      return { success: false, error: "Local drop simulation failed." };
    },
    [
      tree,
      draggedId,
      setTreeWithUndo,
      settings.autoExpandNewFolders,
      expandFolderPath,
      treeHandleDropUtil,
    ]
  );

  const copyItem = useCallback(
    /* ... (Your existing copyItem) ... */
    (itemId) => {
      const itemToCopy = findItemById(tree, itemId);
      if (itemToCopy) {
        try {
          const deepCopy = structuredClone(itemToCopy);
          setClipboardItem(deepCopy);
          setClipboardMode("copy");
          setCutItemId(null);
        } catch (e) {
          console.error("Error copying item:", e);
          setClipboardItem(null);
          setClipboardMode(null);
          setCutItemId(null);
        }
      }
    },
    [tree]
  );

  const cutItem = useCallback(
    /* ... (Your existing cutItem) ... */
    (itemId) => {
      const itemToCut = findItemById(tree, itemId);
      if (itemToCut) {
        try {
          const deepCopy = structuredClone(itemToCut);
          setClipboardItem(deepCopy);
          setClipboardMode("cut");
          setCutItemId(itemId);
        } catch (e) {
          console.error("Error cutting item:", e);
          setClipboardItem(null);
          setClipboardMode(null);
          setCutItemId(null);
        }
      }
    },
    [tree]
  );

  const pasteItem = useCallback(
    /* ... (Your existing pasteItem, 'copy' uses addItem, 'cut' is client-side for DB) ... */
    async (targetFolderId) => {
      console.warn(
        "useTree: pasteItem: 'cut' persistence needs backend. 'copy' uses addItem."
      );
      if (!clipboardItem)
        return { success: false, error: "Clipboard is empty." };
      const targetParent = targetFolderId
        ? findItemById(tree, targetFolderId)
        : null;
      if (targetFolderId && (!targetParent || targetParent.type !== "folder")) {
        return {
          success: false,
          error: "Target for paste must be a valid folder or root.",
        };
      }
      if (
        clipboardItem.type === "folder" &&
        isSelfOrDescendant(tree, clipboardItem.id, targetFolderId)
      ) {
        return {
          success: false,
          error: "Cannot paste a folder into itself or one of its descendants.",
        };
      }
      const targetSiblings = targetFolderId
        ? targetParent?.children || []
        : tree;
      let itemToInsert = structuredClone(clipboardItem);
      if (clipboardMode === "copy") {
        itemToInsert = assignNewIds(itemToInsert, true);
        let baseName = itemToInsert.label;
        let newLabel = baseName;
        let copyCounter = 0;
        while (hasSiblingWithName(targetSiblings, newLabel, null)) {
          copyCounter++;
          newLabel = `${baseName} (copy${
            copyCounter > 1 ? ` ${copyCounter}` : ""
          })`;
        }
        itemToInsert.label = newLabel;
        const addResult = await addItem(itemToInsert, targetFolderId);
        if (
          addResult.success &&
          targetFolderId &&
          settings.autoExpandNewFolders
        )
          expandFolderPath(targetFolderId);
        return addResult;
      } else if (clipboardMode === "cut" && cutItemId) {
        if (
          cutItemId === targetFolderId &&
          findParentAndSiblings(tree, cutItemId)?.parent?.id === targetFolderId
        ) {
          setClipboardItem(null);
          setClipboardMode(null);
          setCutItemId(null);
          return {
            success: true,
            item: itemToInsert,
            message: "Item 'pasted' in the same location.",
          };
        }
        if (
          findParentAndSiblings(tree, cutItemId)?.parent?.id !==
            targetFolderId &&
          hasSiblingWithName(targetSiblings, itemToInsert.label, null)
        ) {
          // Check if name exists unless it's the same item not changing name context
          return {
            success: false,
            error: `An item named "${itemToInsert.label}" already exists in the target folder.`,
          };
        }
        console.warn(
          "Cut & Paste: Persistence of item move not fully implemented on backend. Simulating client-side."
        );
        let tempTree = deleteItemRecursive(tree, cutItemId);
        tempTree = insertItemRecursive(tempTree, targetFolderId, itemToInsert);
        setTreeWithUndo(tempTree);
        setClipboardItem(null);
        setClipboardMode(null);
        setCutItemId(null);
        if (targetFolderId && settings.autoExpandNewFolders)
          expandFolderPath(targetFolderId);
        return {
          success: true,
          item: itemToInsert,
          message:
            "Item moved locally. Server persistence for move needs to be implemented.",
        };
      }
      return { success: false, error: "Invalid paste operation." };
    },
    [
      tree,
      clipboardItem,
      clipboardMode,
      cutItemId,
      setTreeWithUndo,
      settings.autoExpandNewFolders,
      expandFolderPath,
      addItem,
    ]
  );

  const handleExport = useCallback(
    /* ... (Your existing handleExport, no DB interaction) ... */
    (target, format) => {
      let dataToExport;
      let fileName;
      const currentSelectedItem = findItemById(tree, selectedItemId);
      if (target === "selected") {
        if (!currentSelectedItem) {
          alert("No item selected.");
          return;
        }
        dataToExport = currentSelectedItem;
        fileName = `${currentSelectedItem.label}-export`;
      } else {
        dataToExport = tree;
        fileName = "tree-export";
      }
      if (format === "json") {
        try {
          const jsonStr = JSON.stringify(dataToExport, null, 2);
          const blob = new Blob([jsonStr], { type: "application/json" });
          const url = URL.createObjectURL(blob);
          const a = document.createElement("a");
          a.href = url;
          a.download = fileName + ".json";
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(url);
        } catch (error) {
          console.error("JSON export failed:", error);
          alert("Failed to export JSON.");
        }
      } else if (format === "pdf") {
        /* ... your PDF logic ... */
      }
    },
    [tree, selectedItemId]
  );

  // ** MODIFIED handleImport to use PUT for both "entire" and "selected" (by sending full tree) **
  const handleImport = useCallback(
    async (file, importTargetOption) => {
      return new Promise((resolveOuter) => {
        if (!file || file.type !== "application/json") {
          resolveOuter({ success: false, error: "Please select a JSON file." });
          return;
        }
        const reader = new FileReader();
        reader.onload = async (e) => {
          try {
            const importedData = JSON.parse(e.target.result);
            const token = getAuthToken();
            if (!token) {
              resolveOuter({
                success: false,
                error: "Authentication required to save imported data.",
              });
              return;
            }

            let processedTreeForServer;

            if (importTargetOption === "entire") {
              processedTreeForServer = Array.isArray(importedData)
                ? importedData.map((i) =>
                    assignNewIds(structuredClone(i), true)
                  )
                : [assignNewIds(structuredClone(i), true)];
              console.log(
                "Attempting to save entire imported tree to server (from 'entire' option):",
                processedTreeForServer.length,
                "items"
              );
            } else {
              // "selected" - import under an item
              const currentSel = findItemById(tree, selectedItemId);
              if (currentSel && currentSel.type === "folder") {
                const itemsToInsert = Array.isArray(importedData)
                  ? importedData.map((i) =>
                      assignNewIds(structuredClone(i), true)
                    )
                  : [assignNewIds(structuredClone(importedData), true)];

                let tempTree = [...tree]; // Start with a fresh copy of the current tree
                itemsToInsert.forEach((it) => {
                  if (!it.label || !it.type || !it.id) {
                    console.warn(
                      "Skipping invalid item during import under selected:",
                      it
                    );
                    return;
                  }
                  // Ensure no name conflicts before inserting
                  const parentForInsert = findItemById(tempTree, currentSel.id); // Find parent in potentially modified tempTree
                  const siblingsForInsert = parentForInsert?.children || [];
                  if (hasSiblingWithName(siblingsForInsert, it.label, null)) {
                    // Handle name conflict, e.g., by renaming 'it' or skipping
                    console.warn(
                      `Name conflict for "${it.label}" under "${currentSel.label}". Skipping item or implement renaming.`
                    );
                    // For now, skip: (or you could try to auto-rename 'it.label' here)
                    // return; // Or, if you must insert, it might overwrite or backend might reject
                  }
                  tempTree = insertItemRecursive(tempTree, currentSel.id, it);
                });
                processedTreeForServer = tempTree;
                console.log(
                  "Attempting to save modified tree (import under selected) to server:",
                  processedTreeForServer.length,
                  "root items"
                );
              } else {
                resolveOuter({
                  success: false,
                  error: "Target for import must be a selected folder.",
                });
                return;
              }
            }

            const response = await fetch(`${API_BASE_URL}/items/tree`, {
              method: "PUT",
              headers: {
                "Content-Type": "application/json",
                Authorization: `Bearer ${token}`,
              },
              body: JSON.stringify({ newTree: processedTreeForServer }),
            });
            const responseData = await response.json();

            if (!response.ok) {
              console.error("Server error saving imported tree:", responseData);
              resolveOuter({
                success: false,
                error:
                  responseData.error ||
                  "Failed to save imported tree to server.",
              });
              return;
            }

            replaceTree(responseData.notesTree || processedTreeForServer);

            if (
              importTargetOption === "selected" &&
              selectedItemId &&
              settings.autoExpandNewFolders
            ) {
              expandFolderPath(selectedItemId);
            } else if (
              importTargetOption === "entire" &&
              responseData.notesTree?.length > 0 &&
              responseData.notesTree[0].type === "folder" &&
              settings.autoExpandNewFolders
            ) {
              expandFolderPath(responseData.notesTree[0].id); // Expand first root folder if any
            }

            resolveOuter({
              success: true,
              message:
                responseData.message || "Data imported and saved successfully.",
            });
          } catch (err) {
            console.error("Import processing error:", err);
            resolveOuter({
              success: false,
              error: `Import error: ${err.message}`,
            });
          }
        };
        reader.onerror = () => {
          console.error("File read error during import.");
          resolveOuter({ success: false, error: "File read error." });
        };
        reader.readAsText(file);
      });
    },
    [
      tree,
      selectedItemId,
      replaceTree,
      settings.autoExpandNewFolders,
      expandFolderPath,
    ]
  );

  const searchItems = useCallback(
    (query, opts) => {
      // Your existing searchItems
      if (!query) return [];
      const results = [];
      const currentTree = tree || [];
      const walk = (nodes, currentPathSegments = []) => {
        if (!Array.isArray(nodes)) return;
        nodes.forEach((it) => {
          if (!it || typeof it.label !== "string") return;
          const itemPath = [...currentPathSegments, it.label].join(" / ");
          if (itemMatches(it, query, opts)) {
            results.push({ ...it, path: itemPath });
          }
          if (it.type === "folder" && Array.isArray(it.children)) {
            walk(it.children, [...currentPathSegments, it.label]);
          }
        });
      };
      walk(currentTree, []);
      return results;
    },
    [tree]
  );

  return {
    tree,
    selectedItem,
    selectedItemId,
    contextMenu,
    expandedFolders,
    draggedId,
    clipboardItem,
    clipboardMode,
    cutItemId,
    setContextMenu,
    setDraggedId,
    selectItemById,
    toggleFolderExpand,
    updateNoteContent,
    updateTask,
    addItem,
    renameItem,
    deleteItem,
    duplicateItem,
    handleDrop,
    copyItem,
    cutItem,
    pasteItem,
    handleExport,
    handleImport,
    searchItems,
    getItemPath,
    expandFolderPath,
    undoTreeChange,
    redoTreeChange,
    canUndoTree,
    canRedoTree,
    resetState: resetTreeHistory,
    fetchUserTree: fetchUserTreeInternal, // Expose the internal fetch function
    isFetchingTree, // Expose loading state
  };
};


--- src\hooks\useUndoRedo.js ---
// src/hooks/useUndoRedo.js
import { useState, useCallback } from 'react';

const MAX_HISTORY_SIZE = 50; // Max number of states to keep in history

export const useUndoRedo = (initialPresent) => {
    const [history, setHistory] = useState({
        past: [],
        present: initialPresent,
        future: [],
    });

    const canUndo = history.past.length > 0;
    const canRedo = history.future.length > 0;

    const setPresentState = useCallback((newPresent) => {
        setHistory(h => {
            const newPast = [...h.past, h.present];
            // Limit history size
            if (newPast.length > MAX_HISTORY_SIZE) {
                newPast.shift(); // Remove the oldest state
            }
            return {
                past: newPast,
                present: newPresent,
                future: [], // Clear future on new action
            };
        });
    }, []);

    const undo = useCallback(() => {
        if (!canUndo) return;
        setHistory(h => {
            const newFuture = [h.present, ...h.future];
            const newPresent = h.past[h.past.length - 1];
            const newPast = h.past.slice(0, h.past.length - 1);
            return {
                past: newPast,
                present: newPresent,
                future: newFuture,
            };
        });
    }, [canUndo]);

    const redo = useCallback(() => {
        if (!canRedo) return;
        setHistory(h => {
            const newPast = [...h.past, h.present];
            const newPresent = h.future[0];
            const newFuture = h.future.slice(1);
            return {
                past: newPast,
                present: newPresent,
                future: newFuture,
            };
        });
    }, [canRedo]);

    // This function is used when you load data (e.g., from localStorage or import)
    // to reset the history with a new present state.
    const resetHistory = useCallback((newInitialPresent) => {
        setHistory({
            past: [],
            present: newInitialPresent,
            future: [],
        });
    }, []);


    return {
        state: history.present,
        setState: setPresentState, // Renamed for clarity when using the hook
        resetState: resetHistory, // For initializing or resetting the state entirely
        undo,
        redo,
        canUndo,
        canRedo,
        // Expose past and future if needed for debugging or more complex scenarios
        // pastStates: history.past,
        // futureStates: history.future,
    };
};

--- src\styles\index.css ---
/* src/styles/index.css */
@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {

  /*
    1. Set a responsive base font size.
       This makes 1rem roughly equivalent to 16px on most desktop browsers
       but allows for better scaling based on user preferences and device settings.
       Mobile devices might use a slightly larger physical pixel size for 1rem
       due to the viewport meta tag, improving readability.
  */
  html {
    font-size: 100%;
    /* Or 16px as a starting point if you prefer explicit base */
    -webkit-text-size-adjust: 100%;
    /* Prevent font scaling in landscape on iOS */
  }

  body {
    @apply bg-white dark:bg-zinc-900 text-zinc-900 dark:text-zinc-100;
    /*
      2. Apply a sensible default font family.
         Tailwind's default sans-serif stack is usually good.
         Ensure this is what you want for the overall UI, not just prose content.
    */
    font-family: ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";
    /*
      3. Consider a slightly larger base line-height for better readability,
         especially on mobile. Tailwind's `leading-normal` is 1.5.
         This can be overridden by specific utilities.
    */
    @apply leading-normal;
  }

  /*
    4. Customize Tailwind Typography Plugin defaults if needed.
       The `.prose` class is applied in your EditorPane.
       You might want to ensure its base font size is responsive or suitable for mobile.
       By default, `prose-sm` (which you use) has a 0.875rem (14px) base font size.
       This might be okay for content on mobile, but test thoroughly.

       If you need to globally adjust prose defaults for mobile, you could do:
  */
  /*
  .prose {
    @apply text-base; // Example: Make base prose text 1rem (16px)
  }
  .prose-sm {
    @apply text-sm; // Ensure prose-sm still works if you want smaller specific sections
                    // This would be 0.875rem (14px) if base is 1rem.
  }

  You can also target specific elements within .prose:
  .prose h1 {
    @apply text-2xl sm:text-3xl; // Responsive heading sizes
  }
  */

  /*
    If you find the default prose font sizes too small on mobile,
    and you apply `.prose` or `.prose-sm` directly in your JSX,
    you can make the component itself responsive with Tailwind classes:

    e.g., in EditorPane.jsx:
    className="editor-pane prose prose-sm md:prose ..."
    This would apply `prose` (base size) on small screens and `prose-sm` on medium and up.
    Or even just `prose md:prose-sm` if `prose` (base) is your desired mobile size.
  */
}

/*
  Scrollbar styles from your previous configuration.
  These are generally fine and don't directly impact font/resolution,
  but keeping them here for completeness of the file.
*/
@layer utilities {
  .custom-scrollbar::-webkit-scrollbar {
    width: 8px;
  }

  .custom-scrollbar::-webkit-scrollbar-track {
    background: transparent;
  }

  .custom-scrollbar::-webkit-scrollbar-thumb {
    /* Tailwind zinc-400 */
    background-color: #a1a1aa;
    border-radius: 20px;
    /* Creates padding around thumb */
    border: 3px solid transparent;
    background-clip: content-box;
  }

  .dark .custom-scrollbar::-webkit-scrollbar-thumb {
    /* Tailwind zinc-600 */
    background-color: #52525b;
  }

  .custom-scrollbar::-webkit-scrollbar-thumb:hover {
    /* Tailwind zinc-500 */
    background-color: #71717a;
  }

  .dark .custom-scrollbar::-webkit-scrollbar-thumb:hover {
    /* Tailwind zinc-500 */
    background-color: #71717a;
  }

  /* Firefox scrollbar styling (optional but recommended) */
  .custom-scrollbar {
    scrollbar-width: thin;
    /* Tailwind zinc-400 / zinc-600 */
    scrollbar-color: #a1a1aa transparent;
  }

  .dark .custom-scrollbar {
    scrollbar-color: #52525b transparent;
  }
}

/*
  Styles for code formatting within the editor.
  These are generally fine and relate to specific elements, not base typography.
  Ensure the font sizes (text-sm) used here are readable on mobile within the editor context.
  If `text-sm` (0.875rem) becomes too small because the base `rem` value is effectively small on mobile,
  you might need to use responsive prefixes here too (e.g., `text-base md:text-sm`).
*/
.editor-pane code:not(pre > code) {
  /* Style for inline code */
  @apply bg-zinc-200 dark:bg-zinc-700 px-1 py-0.5 rounded font-mono text-sm text-red-600 dark:text-red-400;
}

.editor-pane pre {
  /* Style for code blocks */
  @apply bg-zinc-100 dark:bg-zinc-900 p-3 my-2 rounded overflow-auto font-mono text-sm block;
  white-space: pre;
  /* Important for preserving whitespace */
}

.editor-pane pre code {
  /* Style for code specifically within a pre block */
  @apply bg-transparent p-0 font-mono text-sm text-inherit dark:text-inherit;
  white-space: pre;
  /* Inherit whitespace preservation */
}

.editor-pane .shell-command {
  @apply bg-black dark:bg-black text-green-400 dark:text-green-300 p-3 my-2 rounded overflow-auto font-mono text-sm block;
  white-space: pre;
}

.editor-pane .shell-command::before {
  content: "$ ";
  color: #9ca3af;
  /* gray-400 */
}

.editor-pane {
  white-space: pre-wrap;
}

/* Ensure prose styles don't override code block styles too much */
.dark .prose-invert pre {
  @apply bg-zinc-900;
}

.prose pre {
  @apply bg-zinc-100;
}

.prose code:not(pre > code) {
  @apply bg-zinc-200 dark:bg-zinc-700 text-red-600 dark:text-red-400 px-1 py-0.5;
  font-weight: normal;
}

.prose code::before,
.prose code::after {
  content: none;
}

--- src\styles\index.css ---
/* src/styles/index.css */
@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {

  /*
    1. Set a responsive base font size.
       This makes 1rem roughly equivalent to 16px on most desktop browsers
       but allows for better scaling based on user preferences and device settings.
       Mobile devices might use a slightly larger physical pixel size for 1rem
       due to the viewport meta tag, improving readability.
  */
  html {
    font-size: 100%;
    /* Or 16px as a starting point if you prefer explicit base */
    -webkit-text-size-adjust: 100%;
    /* Prevent font scaling in landscape on iOS */
  }

  body {
    @apply bg-white dark:bg-zinc-900 text-zinc-900 dark:text-zinc-100;
    /*
      2. Apply a sensible default font family.
         Tailwind's default sans-serif stack is usually good.
         Ensure this is what you want for the overall UI, not just prose content.
    */
    font-family: ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";
    /*
      3. Consider a slightly larger base line-height for better readability,
         especially on mobile. Tailwind's `leading-normal` is 1.5.
         This can be overridden by specific utilities.
    */
    @apply leading-normal;
  }

  /*
    4. Customize Tailwind Typography Plugin defaults if needed.
       The `.prose` class is applied in your EditorPane.
       You might want to ensure its base font size is responsive or suitable for mobile.
       By default, `prose-sm` (which you use) has a 0.875rem (14px) base font size.
       This might be okay for content on mobile, but test thoroughly.

       If you need to globally adjust prose defaults for mobile, you could do:
  */
  /*
  .prose {
    @apply text-base; // Example: Make base prose text 1rem (16px)
  }
  .prose-sm {
    @apply text-sm; // Ensure prose-sm still works if you want smaller specific sections
                    // This would be 0.875rem (14px) if base is 1rem.
  }

  You can also target specific elements within .prose:
  .prose h1 {
    @apply text-2xl sm:text-3xl; // Responsive heading sizes
  }
  */

  /*
    If you find the default prose font sizes too small on mobile,
    and you apply `.prose` or `.prose-sm` directly in your JSX,
    you can make the component itself responsive with Tailwind classes:

    e.g., in EditorPane.jsx:
    className="editor-pane prose prose-sm md:prose ..."
    This would apply `prose` (base size) on small screens and `prose-sm` on medium and up.
    Or even just `prose md:prose-sm` if `prose` (base) is your desired mobile size.
  */
}

/*
  Scrollbar styles from your previous configuration.
  These are generally fine and don't directly impact font/resolution,
  but keeping them here for completeness of the file.
*/
@layer utilities {
  .custom-scrollbar::-webkit-scrollbar {
    width: 8px;
  }

  .custom-scrollbar::-webkit-scrollbar-track {
    background: transparent;
  }

  .custom-scrollbar::-webkit-scrollbar-thumb {
    /* Tailwind zinc-400 */
    background-color: #a1a1aa;
    border-radius: 20px;
    /* Creates padding around thumb */
    border: 3px solid transparent;
    background-clip: content-box;
  }

  .dark .custom-scrollbar::-webkit-scrollbar-thumb {
    /* Tailwind zinc-600 */
    background-color: #52525b;
  }

  .custom-scrollbar::-webkit-scrollbar-thumb:hover {
    /* Tailwind zinc-500 */
    background-color: #71717a;
  }

  .dark .custom-scrollbar::-webkit-scrollbar-thumb:hover {
    /* Tailwind zinc-500 */
    background-color: #71717a;
  }

  /* Firefox scrollbar styling (optional but recommended) */
  .custom-scrollbar {
    scrollbar-width: thin;
    /* Tailwind zinc-400 / zinc-600 */
    scrollbar-color: #a1a1aa transparent;
  }

  .dark .custom-scrollbar {
    scrollbar-color: #52525b transparent;
  }
}

/*
  Styles for code formatting within the editor.
  These are generally fine and relate to specific elements, not base typography.
  Ensure the font sizes (text-sm) used here are readable on mobile within the editor context.
  If `text-sm` (0.875rem) becomes too small because the base `rem` value is effectively small on mobile,
  you might need to use responsive prefixes here too (e.g., `text-base md:text-sm`).
*/
.editor-pane code:not(pre > code) {
  /* Style for inline code */
  @apply bg-zinc-200 dark:bg-zinc-700 px-1 py-0.5 rounded font-mono text-sm text-red-600 dark:text-red-400;
}

.editor-pane pre {
  /* Style for code blocks */
  @apply bg-zinc-100 dark:bg-zinc-900 p-3 my-2 rounded overflow-auto font-mono text-sm block;
  white-space: pre;
  /* Important for preserving whitespace */
}

.editor-pane pre code {
  /* Style for code specifically within a pre block */
  @apply bg-transparent p-0 font-mono text-sm text-inherit dark:text-inherit;
  white-space: pre;
  /* Inherit whitespace preservation */
}

.editor-pane .shell-command {
  @apply bg-black dark:bg-black text-green-400 dark:text-green-300 p-3 my-2 rounded overflow-auto font-mono text-sm block;
  white-space: pre;
}

.editor-pane .shell-command::before {
  content: "$ ";
  color: #9ca3af;
  /* gray-400 */
}

.editor-pane {
  white-space: pre-wrap;
}

/* Ensure prose styles don't override code block styles too much */
.dark .prose-invert pre {
  @apply bg-zinc-900;
}

.prose pre {
  @apply bg-zinc-100;
}

.prose code:not(pre > code) {
  @apply bg-zinc-200 dark:bg-zinc-700 text-red-600 dark:text-red-400 px-1 py-0.5;
  font-weight: normal;
}

.prose code::before,
.prose code::after {
  content: none;
}

--- src\utils\constants.js ---
export const LOCAL_STORAGE_KEY = "myNotesTasksTree";

--- src\utils\searchUtils.js ---
export function escapeRegex(str) {
  return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

/**
 * Finds the first match of a query in text based on options.
 * @param {string} text The text to search within.
 * @param {string} query The search query.
 * @param {object} opts Search options (caseSensitive, wholeWord, useRegex).
 * @returns {object|null} An object { matchedString, startIndex } or null if no match.
 */
export function matchText(text, query, opts) {
  if (!query || text == null || typeof text !== 'string') return null;
  const flags = opts.caseSensitive ? '' : 'i';
  try {
    let pattern;
    if (opts.useRegex) {
      pattern = query;
    } else {
      // Use the (now exported) escapeRegex function
      const safe = escapeRegex(query);
      pattern = opts.wholeWord ? `\\b${safe}\\b` : safe;
    }
    const re = new RegExp(pattern, flags);
    const matchResult = re.exec(text);

    if (matchResult) {
      return {
        matchedString: matchResult[0],
        startIndex: matchResult.index,
      };
    }
    return null;
  } catch (e) {
    // console.error("Regex error in matchText:", e, query, text);
    return null;
  }
}

/**
 * Checks if an item matches the search query based on its type and relevant fields.
 * For folders, checks only the label.
 * For notes/tasks, checks label and content.
 * @param {object} item The item to check.
 * @param {string} query The search query.
 * @param {object} opts Search options.
 * @returns {boolean} True if the item is a match, false otherwise.
 */
export function itemMatches(item, query, opts) {
  if (!item || !query) return false;

  // Check label (common to all types that might have one)
  if (typeof item.label === 'string' && matchText(item.label, query, opts) !== null) {
    return true;
  }

  // Check title if it exists and differs from label
  if (typeof item.title === 'string' && item.title !== item.label && matchText(item.title, query, opts) !== null) {
    return true;
  }

  // Check content only for notes and tasks
  if ((item.type === 'note' || item.type === 'task') && typeof item.content === 'string') {
    // Convert HTML content to plain text before matching
    // Note: This assumes a simple HTML structure or requires a more robust HTML-to-text conversion
    // For efficiency, this conversion might ideally happen once when indexing or preparing search data,
    // but for direct matching, we do it here.
    let plainTextContent = '';
    try {
      const tempDiv = document.createElement("div");
      tempDiv.innerHTML = item.content;
      plainTextContent = tempDiv.textContent || tempDiv.innerText || "";
    } catch (e) { /* Ignore potential errors during conversion for search */ }

    if (matchText(plainTextContent, query, opts) !== null) {
      return true;
    }
  }

  return false;
}

--- src\utils\treeUtils.js ---
// src/utils/treeUtils.js

/**
 * Sorts items: folders first, then notes, then tasks, then alphabetically by label.
 * Returns a new sorted array (the original array is not mutated).
 */
export const sortItems = (items) => {
  if (!Array.isArray(items)) return [];
  // Return empty array if input is not an array
  // Create a shallow copy before sorting to avoid mutating the original array
  return [...items].sort((a, b) => {
    // Basic type checks to prevent errors if items lack 'type' or 'label'
    const typeA = a?.type ?? '';
    const typeB = b?.type ?? '';
    const labelA = a?.label ?? '';
    const labelB = b?.label ?? '';

    // Sort folders before notes/tasks
    if (typeA === "folder" && typeB !== "folder") return -1;
    if (typeA !== "folder" && typeB === "folder") return 1;

    // Sort notes before tasks (if types are not folders)
    if (typeA === "note" && typeB === "task") return -1;
    if (typeA === "task" && typeB === "note") return 1;

    // If types are the same (or both not folder/note/task), sort by label (case-insensitive)
    return labelA.localeCompare(labelB, undefined, { sensitivity: "base" });
  });
};

/**
 * Recursively deletes an item (by id) from a tree structure.
 * Returns a new tree array.
 */
export const deleteItemRecursive = (items, idToDelete) => {
  // Ensure working with an array, return empty if input is invalid
  const baseItems = Array.isArray(items) ? items : [];
  if (!idToDelete) return baseItems; // Return original array if no ID provided

  // Filter out the item at the current level
  return baseItems
    .filter((it) => it.id !== idToDelete)
    .map((it) => {
      // If the item is a folder and has children, recursively process its children
      if (it.type === "folder" && Array.isArray(it.children)) {
        const updatedChildren = deleteItemRecursive(it.children, idToDelete);
        // Only return a new object if children array actually changed
        return updatedChildren !== it.children ? { ...it, children: updatedChildren } : it;
      }
      // Return the item as is if it's not the one to delete or has no children to process
      return it;
    });
};

/**
 * Recursively finds an item by its id.
 * Returns the item object or null if not found.
 */
export const findItemById = (nodes, id) => {
  // Basic validation
  if (!Array.isArray(nodes) || !id) return null;
  for (const item of nodes) {
    // Check if the current item is the one we're looking for
    if (item.id === id) return item;
    // If the item is a folder and has children, search recursively within its children
    if (item.type === "folder" && Array.isArray(item.children)) {
      const found = findItemById(item.children, id);
      // If found in children, return the result immediately
      if (found) return found;
    }
  }
  // Item not found in the current level or its descendants
  return null;
};
/**
 * Finds the parent object and the siblings array of an item identified by itemId.
 * Returns an object { parent: object | null, siblings: array }.
 * If itemId is null (meaning root), parent is null and siblings is the root array.
 * If itemId is not found, returns { parent: null, siblings: [] }.
 */
export const findParentAndSiblings = (tree, itemId) => {
  // Ensure the input tree is an array
  if (!Array.isArray(tree)) {
    console.error("findParentAndSiblings: Input 'tree' is not an array.");
    return { parent: null, siblings: [] };
  }

  // Handle the case where we want the context for the root level
  if (itemId === null) {
    return { parent: null, siblings: tree };
  }

  // Recursive helper function to search the tree
  const findRecursive = (nodes, idToFind, currentParent = null) => {
    // Ensure nodes is an array before iterating
    if (!Array.isArray(nodes)) return null;
    for (let i = 0; i < nodes.length; i++) {
      const item = nodes[i];
      // Check if the current item is the one we are looking for
      if (item.id === idToFind) {
        // Found the item. Return its parent and the array containing the item (siblings).
        return { parent: currentParent, siblings: nodes };
      }
      // If the item is a folder and has children, recurse into the children
      if (item.type === "folder" && Array.isArray(item.children) && item.children.length > 0) {
        // Pass the current item as the parent for the next level of recursion
        const foundInChildren = findRecursive(item.children, idToFind, item);
        // If found in the recursive call, return the result immediately
        if (foundInChildren) return foundInChildren;
      }
    }
    // Item not found in this branch of the tree
    return null;
  };

  // Start the recursive search from the root of the tree
  const result = findRecursive(tree, itemId, null);
  if (result) {
    // Item was found, return the result { parent, siblings }
    return result;
  } else {
    // Item not found anywhere in the tree
    console.warn(`findParentAndSiblings: Could not find item with id ${itemId}`);
    // Return a default object indicating not found
    return { parent: null, siblings: [] };
  }
};
/**
 * Recursively renames an item in the tree. (Internal logic).
 * Returns a new tree array with the item renamed.
 */
export const renameItemRecursive = (items, idToRename, newLabel) => {
  const baseItems = Array.isArray(items) ? items : [];
  const trimmedLabel = newLabel.trim(); // Ensure label is trimmed

  return baseItems.map((it) => {
    // If this is the item to rename, return a new object with the updated label
    if (it.id === idToRename) {
      return { ...it, label: trimmedLabel };
    }
    // If the item has children, recursively attempt to rename within the children
    if (Array.isArray(it.children)) {
      const updatedChildren = renameItemRecursive(it.children, idToRename, trimmedLabel);
      // Only create a new parent object if the children array actually changed
      return updatedChildren !== it.children ? { ...it, children: updatedChildren } : it;
    }
    // If not the item and has no children (or not a folder), return the item unchanged
    return it;
  });
};

/**
 * Recursively inserts an item into the tree structure.
 * If targetFolderId is null, the item is added to the root.
 * Ensures the children list of the target folder remains sorted.
 * Returns a new tree array.
 */
export const insertItemRecursive = (nodes, targetFolderId, itemToInsert) => {
  const baseNodes = Array.isArray(nodes) ? nodes : [];
  // Case 1: Add to root
  if (targetFolderId === null) {
    // Add the new item and sort the root level
    return sortItems([...baseNodes, itemToInsert]);
  }

  // Case 2: Add to a specific folder
  return baseNodes.map((node) => {
    // If this node is the target folder
    if (node.id === targetFolderId && node.type === "folder") {
      const currentChildren = Array.isArray(node.children) ? node.children : [];
      // Return a new folder object with the new item added and children sorted
      return {
        ...node,
        children: sortItems([...currentChildren, itemToInsert]),
      };
    }
    // If the node has children, recurse into them
    else if (Array.isArray(node.children)) {
      const updatedChildren = insertItemRecursive(node.children, targetFolderId, itemToInsert);
      // Only create a new node object if its children actually changed
      return updatedChildren !== node.children ? { ...node, children: updatedChildren } : node;
    }
    // If not the target and no children to recurse into, return the node unchanged
    return node;
  });
};

/**
 * Checks if a name conflicts with existing siblings (case-insensitive comparison).
 * excludeId is used during rename to avoid comparing an item with itself.
 */
export const hasSiblingWithName = (siblings, nameToCheck, excludeId = null) => {
  // Basic validation: ensure siblings is an array and nameToCheck is provided
  if (!Array.isArray(siblings) || !nameToCheck) return false;
  // Normalize the name to check (trim whitespace, convert to lowercase)
  const normalizedName = nameToCheck.trim().toLowerCase();
  // If the normalized name is empty, it cannot conflict
  if (!normalizedName) return false;
  // Check if 'some' sibling matches the criteria
  return siblings.some(sibling =>
    sibling &&                                  // Ensure sibling exists
    sibling.id !== excludeId &&                 // Don't compare item with itself if excludeId is given
    sibling.label &&                         // Ensure sibling has a label
    sibling.label.trim().toLowerCase() === normalizedName // Perform case-insensitive comparison
  );
};

/**
 * Checks if 'checkItemId' is the same as or an ancestor of 'potentialTargetId'.
 * Used to prevent dropping/pasting a folder into itself or its descendants.
 */
export const isSelfOrDescendant = (nodes, checkItemId, potentialTargetId) => {
  // Basic validation: requires both IDs
  if (!checkItemId || !potentialTargetId) return false;
  // An item is its own ancestor in this context
  if (checkItemId === potentialTargetId) return true;
  // Find the item that might be the ancestor
  const item = findItemById(nodes, checkItemId);
  // If the item isn't found, or it's not a folder, it can't be an ancestor
  if (!item || item.type !== "folder" || !Array.isArray(item.children)) return false;
  // Recursive helper to check children
  const checkChildren = (children) => {
    if (!Array.isArray(children)) return false;
    for (const child of children) {
      // If a child matches the target ID, then the target is a descendant
      if (child.id === potentialTargetId) return true;
      // If the child is a folder, recursively check its children
      if (child.type === "folder" && Array.isArray(child.children)) {
        if (checkChildren(child.children)) return true; // Found in sub-branch
      }
    }
    // Target not found in this branch
    return false;
  };

  // Start the check from the children of the potential ancestor item
  return checkChildren(item.children);
};
/**
 * Handles the drop operation validation and data preparation for drag-and-drop.
 * Returns a new tree structure if drop is valid, otherwise null.
 * Includes validation for target type, ancestor dropping, and name conflicts.
 */
export const handleDrop = (currentTree, targetId, draggedId) => {
  // --- Basic Validation ---
  if (!targetId || !draggedId || targetId === draggedId) {
    console.warn("Drop cancelled: Invalid IDs or target is the same as the dragged item.", { targetId, draggedId });
    return null;
  }

  // --- Find Items ---
  const targetItem = findItemById(currentTree, targetId);
  const draggedItemData = findItemById(currentTree, draggedId);
  // --- Target Validation ---
  if (!targetItem) {
    console.warn(`Drop cancelled: Target item ${targetId} could not be found.`);
    return null;
  }
  if (targetItem.type !== "folder") {
    console.warn(`Drop cancelled: Target item ${targetId} ('${targetItem.label}') is not a folder.`);
    return null;
  }

  // --- Dragged Item Validation ---
  if (!draggedItemData) {
    console.error(`Drop cancelled: Dragged item data for ${draggedId} not found.`);
    return null;
  }

  // --- Ancestor Check (Prevent dropping a folder into itself/descendant) ---
  if (draggedItemData.type === "folder" && isSelfOrDescendant(currentTree, draggedItemData.id, targetId)) {
    const errorMsg = `Cannot drop folder '${draggedItemData.label}' into itself or one of its subfolders.`;
    console.warn("Drop prevented: Ancestor check failed.", errorMsg);
    alert(errorMsg); // User feedback
    return null;
  }

  // --- Sibling Name Conflict Check (Prevent dropping if name exists in target) ---
  const targetSiblings = targetItem.children || [];
  if (hasSiblingWithName(targetSiblings, draggedItemData.label, null)) { // excludeId is null because it's a new item in this context
      const errorMsg = `Cannot move item: An item named '${draggedItemData.label}' already exists in the target folder '${targetItem.label}'.`;
      console.warn("Drop prevented: Name conflict.", errorMsg);
      alert(errorMsg); // User feedback
      return null;
  }


  // --- Drop Logic ---
  // 1. Deep copy the dragged item (using structuredClone if available, fallback to JSON)
  let draggedItemCopy;
  try {
    draggedItemCopy = typeof structuredClone === "function"
      ? structuredClone(draggedItemData)
      : JSON.parse(JSON.stringify(draggedItemData));
  } catch (error) {
    console.error("Failed to deep copy dragged item:", error, draggedItemData);
    return null; // Abort if copy fails
  }

  // 2. Remove the original dragged item recursively from a copy of the tree
  const treeWithoutDraggedItem = deleteItemRecursive(currentTree, draggedId);
  // Verify removal happened (optional but good practice)
   if (JSON.stringify(treeWithoutDraggedItem) === JSON.stringify(currentTree)) {
      console.error("Drop failed: Removal of dragged item did not change the tree structure.", { draggedId }); // This indicates the draggedId might not have been found, despite earlier checks.
      return null;
  }


  // 3. Insert the copy into the target folder recursively
  const finalTree = insertItemRecursive(treeWithoutDraggedItem, targetId, draggedItemCopy);
  // Verify insertion happened (optional but good practice)
    if (JSON.stringify(finalTree) === JSON.stringify(treeWithoutDraggedItem)) {
      console.error("Drop failed: Insertion of dragged item copy did not change the tree structure.", { targetId, draggedId }); // This indicates the targetId might not have been found during insertion.
      return null;
    }

  return finalTree; // Return the new tree structure
};

// ********** NEW FUNCTION **********
/**
 * Gets the hierarchical path labels for a given item ID.
 * Returns the path as a string (e.g., "Root / Folder A / Item B").
 */
export const getItemPath = (tree, itemId) => {
  const pathLabels = [];
  // Recursive function to find the item and build the path upwards
  const findPathRecursive = (nodes, idToFind, currentPath = []) => {
    if (!Array.isArray(nodes)) return false; // Base case: invalid node structure

    for (const item of nodes) {
      // Create the potential path including the current item
      const newPath = [...currentPath, item.label];

      // Check if the current item is the one we're looking for
      if (item.id === idToFind) {
        pathLabels.push(...newPath); // Store the found path
        return true; // Indicate found
      }

      // If the current item is a folder and has children, search recursively
      if (item.type === "folder" && Array.isArray(item.children) && item.children.length > 0) {
        if (findPathRecursive(item.children, idToFind, newPath)) {
          return true; // Indicate found in children
        }
      }
    }
    return false; // Item not found in this branch
  };

  // Start the search from the root of the tree
  findPathRecursive(tree, itemId);

  // Join the collected labels into a string path, or return an empty string if not found
  return pathLabels.join(' / ');
};
// ********** END NEW FUNCTION **********

--- src\utils\constants.js ---
export const LOCAL_STORAGE_KEY = "myNotesTasksTree";

--- src\utils\searchUtils.js ---
export function escapeRegex(str) {
  return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

/**
 * Finds the first match of a query in text based on options.
 * @param {string} text The text to search within.
 * @param {string} query The search query.
 * @param {object} opts Search options (caseSensitive, wholeWord, useRegex).
 * @returns {object|null} An object { matchedString, startIndex } or null if no match.
 */
export function matchText(text, query, opts) {
  if (!query || text == null || typeof text !== 'string') return null;
  const flags = opts.caseSensitive ? '' : 'i';
  try {
    let pattern;
    if (opts.useRegex) {
      pattern = query;
    } else {
      // Use the (now exported) escapeRegex function
      const safe = escapeRegex(query);
      pattern = opts.wholeWord ? `\\b${safe}\\b` : safe;
    }
    const re = new RegExp(pattern, flags);
    const matchResult = re.exec(text);

    if (matchResult) {
      return {
        matchedString: matchResult[0],
        startIndex: matchResult.index,
      };
    }
    return null;
  } catch (e) {
    // console.error("Regex error in matchText:", e, query, text);
    return null;
  }
}

/**
 * Checks if an item matches the search query based on its type and relevant fields.
 * For folders, checks only the label.
 * For notes/tasks, checks label and content.
 * @param {object} item The item to check.
 * @param {string} query The search query.
 * @param {object} opts Search options.
 * @returns {boolean} True if the item is a match, false otherwise.
 */
export function itemMatches(item, query, opts) {
  if (!item || !query) return false;

  // Check label (common to all types that might have one)
  if (typeof item.label === 'string' && matchText(item.label, query, opts) !== null) {
    return true;
  }

  // Check title if it exists and differs from label
  if (typeof item.title === 'string' && item.title !== item.label && matchText(item.title, query, opts) !== null) {
    return true;
  }

  // Check content only for notes and tasks
  if ((item.type === 'note' || item.type === 'task') && typeof item.content === 'string') {
    // Convert HTML content to plain text before matching
    // Note: This assumes a simple HTML structure or requires a more robust HTML-to-text conversion
    // For efficiency, this conversion might ideally happen once when indexing or preparing search data,
    // but for direct matching, we do it here.
    let plainTextContent = '';
    try {
      const tempDiv = document.createElement("div");
      tempDiv.innerHTML = item.content;
      plainTextContent = tempDiv.textContent || tempDiv.innerText || "";
    } catch (e) { /* Ignore potential errors during conversion for search */ }

    if (matchText(plainTextContent, query, opts) !== null) {
      return true;
    }
  }

  return false;
}

--- src\utils\treeUtils.js ---
// src/utils/treeUtils.js

/**
 * Sorts items: folders first, then notes, then tasks, then alphabetically by label.
 * Returns a new sorted array (the original array is not mutated).
 */
export const sortItems = (items) => {
  if (!Array.isArray(items)) return [];
  // Return empty array if input is not an array
  // Create a shallow copy before sorting to avoid mutating the original array
  return [...items].sort((a, b) => {
    // Basic type checks to prevent errors if items lack 'type' or 'label'
    const typeA = a?.type ?? '';
    const typeB = b?.type ?? '';
    const labelA = a?.label ?? '';
    const labelB = b?.label ?? '';

    // Sort folders before notes/tasks
    if (typeA === "folder" && typeB !== "folder") return -1;
    if (typeA !== "folder" && typeB === "folder") return 1;

    // Sort notes before tasks (if types are not folders)
    if (typeA === "note" && typeB === "task") return -1;
    if (typeA === "task" && typeB === "note") return 1;

    // If types are the same (or both not folder/note/task), sort by label (case-insensitive)
    return labelA.localeCompare(labelB, undefined, { sensitivity: "base" });
  });
};

/**
 * Recursively deletes an item (by id) from a tree structure.
 * Returns a new tree array.
 */
export const deleteItemRecursive = (items, idToDelete) => {
  // Ensure working with an array, return empty if input is invalid
  const baseItems = Array.isArray(items) ? items : [];
  if (!idToDelete) return baseItems; // Return original array if no ID provided

  // Filter out the item at the current level
  return baseItems
    .filter((it) => it.id !== idToDelete)
    .map((it) => {
      // If the item is a folder and has children, recursively process its children
      if (it.type === "folder" && Array.isArray(it.children)) {
        const updatedChildren = deleteItemRecursive(it.children, idToDelete);
        // Only return a new object if children array actually changed
        return updatedChildren !== it.children ? { ...it, children: updatedChildren } : it;
      }
      // Return the item as is if it's not the one to delete or has no children to process
      return it;
    });
};

/**
 * Recursively finds an item by its id.
 * Returns the item object or null if not found.
 */
export const findItemById = (nodes, id) => {
  // Basic validation
  if (!Array.isArray(nodes) || !id) return null;
  for (const item of nodes) {
    // Check if the current item is the one we're looking for
    if (item.id === id) return item;
    // If the item is a folder and has children, search recursively within its children
    if (item.type === "folder" && Array.isArray(item.children)) {
      const found = findItemById(item.children, id);
      // If found in children, return the result immediately
      if (found) return found;
    }
  }
  // Item not found in the current level or its descendants
  return null;
};
/**
 * Finds the parent object and the siblings array of an item identified by itemId.
 * Returns an object { parent: object | null, siblings: array }.
 * If itemId is null (meaning root), parent is null and siblings is the root array.
 * If itemId is not found, returns { parent: null, siblings: [] }.
 */
export const findParentAndSiblings = (tree, itemId) => {
  // Ensure the input tree is an array
  if (!Array.isArray(tree)) {
    console.error("findParentAndSiblings: Input 'tree' is not an array.");
    return { parent: null, siblings: [] };
  }

  // Handle the case where we want the context for the root level
  if (itemId === null) {
    return { parent: null, siblings: tree };
  }

  // Recursive helper function to search the tree
  const findRecursive = (nodes, idToFind, currentParent = null) => {
    // Ensure nodes is an array before iterating
    if (!Array.isArray(nodes)) return null;
    for (let i = 0; i < nodes.length; i++) {
      const item = nodes[i];
      // Check if the current item is the one we are looking for
      if (item.id === idToFind) {
        // Found the item. Return its parent and the array containing the item (siblings).
        return { parent: currentParent, siblings: nodes };
      }
      // If the item is a folder and has children, recurse into the children
      if (item.type === "folder" && Array.isArray(item.children) && item.children.length > 0) {
        // Pass the current item as the parent for the next level of recursion
        const foundInChildren = findRecursive(item.children, idToFind, item);
        // If found in the recursive call, return the result immediately
        if (foundInChildren) return foundInChildren;
      }
    }
    // Item not found in this branch of the tree
    return null;
  };

  // Start the recursive search from the root of the tree
  const result = findRecursive(tree, itemId, null);
  if (result) {
    // Item was found, return the result { parent, siblings }
    return result;
  } else {
    // Item not found anywhere in the tree
    console.warn(`findParentAndSiblings: Could not find item with id ${itemId}`);
    // Return a default object indicating not found
    return { parent: null, siblings: [] };
  }
};
/**
 * Recursively renames an item in the tree. (Internal logic).
 * Returns a new tree array with the item renamed.
 */
export const renameItemRecursive = (items, idToRename, newLabel) => {
  const baseItems = Array.isArray(items) ? items : [];
  const trimmedLabel = newLabel.trim(); // Ensure label is trimmed

  return baseItems.map((it) => {
    // If this is the item to rename, return a new object with the updated label
    if (it.id === idToRename) {
      return { ...it, label: trimmedLabel };
    }
    // If the item has children, recursively attempt to rename within the children
    if (Array.isArray(it.children)) {
      const updatedChildren = renameItemRecursive(it.children, idToRename, trimmedLabel);
      // Only create a new parent object if the children array actually changed
      return updatedChildren !== it.children ? { ...it, children: updatedChildren } : it;
    }
    // If not the item and has no children (or not a folder), return the item unchanged
    return it;
  });
};

/**
 * Recursively inserts an item into the tree structure.
 * If targetFolderId is null, the item is added to the root.
 * Ensures the children list of the target folder remains sorted.
 * Returns a new tree array.
 */
export const insertItemRecursive = (nodes, targetFolderId, itemToInsert) => {
  const baseNodes = Array.isArray(nodes) ? nodes : [];
  // Case 1: Add to root
  if (targetFolderId === null) {
    // Add the new item and sort the root level
    return sortItems([...baseNodes, itemToInsert]);
  }

  // Case 2: Add to a specific folder
  return baseNodes.map((node) => {
    // If this node is the target folder
    if (node.id === targetFolderId && node.type === "folder") {
      const currentChildren = Array.isArray(node.children) ? node.children : [];
      // Return a new folder object with the new item added and children sorted
      return {
        ...node,
        children: sortItems([...currentChildren, itemToInsert]),
      };
    }
    // If the node has children, recurse into them
    else if (Array.isArray(node.children)) {
      const updatedChildren = insertItemRecursive(node.children, targetFolderId, itemToInsert);
      // Only create a new node object if its children actually changed
      return updatedChildren !== node.children ? { ...node, children: updatedChildren } : node;
    }
    // If not the target and no children to recurse into, return the node unchanged
    return node;
  });
};

/**
 * Checks if a name conflicts with existing siblings (case-insensitive comparison).
 * excludeId is used during rename to avoid comparing an item with itself.
 */
export const hasSiblingWithName = (siblings, nameToCheck, excludeId = null) => {
  // Basic validation: ensure siblings is an array and nameToCheck is provided
  if (!Array.isArray(siblings) || !nameToCheck) return false;
  // Normalize the name to check (trim whitespace, convert to lowercase)
  const normalizedName = nameToCheck.trim().toLowerCase();
  // If the normalized name is empty, it cannot conflict
  if (!normalizedName) return false;
  // Check if 'some' sibling matches the criteria
  return siblings.some(sibling =>
    sibling &&                                  // Ensure sibling exists
    sibling.id !== excludeId &&                 // Don't compare item with itself if excludeId is given
    sibling.label &&                         // Ensure sibling has a label
    sibling.label.trim().toLowerCase() === normalizedName // Perform case-insensitive comparison
  );
};

/**
 * Checks if 'checkItemId' is the same as or an ancestor of 'potentialTargetId'.
 * Used to prevent dropping/pasting a folder into itself or its descendants.
 */
export const isSelfOrDescendant = (nodes, checkItemId, potentialTargetId) => {
  // Basic validation: requires both IDs
  if (!checkItemId || !potentialTargetId) return false;
  // An item is its own ancestor in this context
  if (checkItemId === potentialTargetId) return true;
  // Find the item that might be the ancestor
  const item = findItemById(nodes, checkItemId);
  // If the item isn't found, or it's not a folder, it can't be an ancestor
  if (!item || item.type !== "folder" || !Array.isArray(item.children)) return false;
  // Recursive helper to check children
  const checkChildren = (children) => {
    if (!Array.isArray(children)) return false;
    for (const child of children) {
      // If a child matches the target ID, then the target is a descendant
      if (child.id === potentialTargetId) return true;
      // If the child is a folder, recursively check its children
      if (child.type === "folder" && Array.isArray(child.children)) {
        if (checkChildren(child.children)) return true; // Found in sub-branch
      }
    }
    // Target not found in this branch
    return false;
  };

  // Start the check from the children of the potential ancestor item
  return checkChildren(item.children);
};
/**
 * Handles the drop operation validation and data preparation for drag-and-drop.
 * Returns a new tree structure if drop is valid, otherwise null.
 * Includes validation for target type, ancestor dropping, and name conflicts.
 */
export const handleDrop = (currentTree, targetId, draggedId) => {
  // --- Basic Validation ---
  if (!targetId || !draggedId || targetId === draggedId) {
    console.warn("Drop cancelled: Invalid IDs or target is the same as the dragged item.", { targetId, draggedId });
    return null;
  }

  // --- Find Items ---
  const targetItem = findItemById(currentTree, targetId);
  const draggedItemData = findItemById(currentTree, draggedId);
  // --- Target Validation ---
  if (!targetItem) {
    console.warn(`Drop cancelled: Target item ${targetId} could not be found.`);
    return null;
  }
  if (targetItem.type !== "folder") {
    console.warn(`Drop cancelled: Target item ${targetId} ('${targetItem.label}') is not a folder.`);
    return null;
  }

  // --- Dragged Item Validation ---
  if (!draggedItemData) {
    console.error(`Drop cancelled: Dragged item data for ${draggedId} not found.`);
    return null;
  }

  // --- Ancestor Check (Prevent dropping a folder into itself/descendant) ---
  if (draggedItemData.type === "folder" && isSelfOrDescendant(currentTree, draggedItemData.id, targetId)) {
    const errorMsg = `Cannot drop folder '${draggedItemData.label}' into itself or one of its subfolders.`;
    console.warn("Drop prevented: Ancestor check failed.", errorMsg);
    alert(errorMsg); // User feedback
    return null;
  }

  // --- Sibling Name Conflict Check (Prevent dropping if name exists in target) ---
  const targetSiblings = targetItem.children || [];
  if (hasSiblingWithName(targetSiblings, draggedItemData.label, null)) { // excludeId is null because it's a new item in this context
      const errorMsg = `Cannot move item: An item named '${draggedItemData.label}' already exists in the target folder '${targetItem.label}'.`;
      console.warn("Drop prevented: Name conflict.", errorMsg);
      alert(errorMsg); // User feedback
      return null;
  }


  // --- Drop Logic ---
  // 1. Deep copy the dragged item (using structuredClone if available, fallback to JSON)
  let draggedItemCopy;
  try {
    draggedItemCopy = typeof structuredClone === "function"
      ? structuredClone(draggedItemData)
      : JSON.parse(JSON.stringify(draggedItemData));
  } catch (error) {
    console.error("Failed to deep copy dragged item:", error, draggedItemData);
    return null; // Abort if copy fails
  }

  // 2. Remove the original dragged item recursively from a copy of the tree
  const treeWithoutDraggedItem = deleteItemRecursive(currentTree, draggedId);
  // Verify removal happened (optional but good practice)
   if (JSON.stringify(treeWithoutDraggedItem) === JSON.stringify(currentTree)) {
      console.error("Drop failed: Removal of dragged item did not change the tree structure.", { draggedId }); // This indicates the draggedId might not have been found, despite earlier checks.
      return null;
  }


  // 3. Insert the copy into the target folder recursively
  const finalTree = insertItemRecursive(treeWithoutDraggedItem, targetId, draggedItemCopy);
  // Verify insertion happened (optional but good practice)
    if (JSON.stringify(finalTree) === JSON.stringify(treeWithoutDraggedItem)) {
      console.error("Drop failed: Insertion of dragged item copy did not change the tree structure.", { targetId, draggedId }); // This indicates the targetId might not have been found during insertion.
      return null;
    }

  return finalTree; // Return the new tree structure
};

// ********** NEW FUNCTION **********
/**
 * Gets the hierarchical path labels for a given item ID.
 * Returns the path as a string (e.g., "Root / Folder A / Item B").
 */
export const getItemPath = (tree, itemId) => {
  const pathLabels = [];
  // Recursive function to find the item and build the path upwards
  const findPathRecursive = (nodes, idToFind, currentPath = []) => {
    if (!Array.isArray(nodes)) return false; // Base case: invalid node structure

    for (const item of nodes) {
      // Create the potential path including the current item
      const newPath = [...currentPath, item.label];

      // Check if the current item is the one we're looking for
      if (item.id === idToFind) {
        pathLabels.push(...newPath); // Store the found path
        return true; // Indicate found
      }

      // If the current item is a folder and has children, search recursively
      if (item.type === "folder" && Array.isArray(item.children) && item.children.length > 0) {
        if (findPathRecursive(item.children, idToFind, newPath)) {
          return true; // Indicate found in children
        }
      }
    }
    return false; // Item not found in this branch
  };

  // Start the search from the root of the tree
  findPathRecursive(tree, itemId);

  // Join the collected labels into a string path, or return an empty string if not found
  return pathLabels.join(' / ');
};
// ********** END NEW FUNCTION **********

--- src\.gitignore ---
# Node dependencies
node_modules/

# Logs
logs/
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# Runtime files
pids/
*.pid
*.seed
*.pid.lock

# Build output
dist/
build/

# Coverage reports
coverage/

# Environment variables
.env
.env.*.local

# Editor directories and settings
.vscode/
.idea/
*.suo
*.ntvs*
*.njsproj
*.sln

# OS generated files
.DS_Store
Thumbs.db
ehthumbs.db

# lockfiles (optional—keep if you want to track versioning)
# package-lock.json
# yarn.lock

# TypeScript build info
*.tsbuildinfo

# Next.js
.next/

# Gatsby
.cache/
public/

# Parcel bundler
.parcel-cache/

# Testing
jest.config.js
jest.local.js

# Misc
npm-debug.log*
yarn-error.log*

# ignore build output
dist/

--- src\App.jsx ---
// src/App.jsx
import React, { useState, useEffect, useCallback, useRef } from "react";
import Tree from "./components/Tree";
import FolderContents from "./components/FolderContents";
import ContentEditor from "./components/ContentEditor";
import ContextMenu from "./components/ContextMenu";
import AddDialog from "./components/AddDialog";
import AboutDialog from "./components/AboutDialog";
import ExportDialog from "./components/ExportDialog";
import ImportDialog from "./components/ImportDialog";
import SettingsDialog from "./components/SettingsDialog";
import { useTree } from "./hooks/useTree.jsx";
import { useSettings } from "./contexts/SettingsContext";
import {
  findItemById as findItemByIdUtil,
  findParentAndSiblings as findParentAndSiblingsUtil,
} from "./utils/treeUtils";
import { Panel, PanelGroup, PanelResizeHandle } from "react-resizable-panels";
import {
  Search as SearchIcon,
  Info,
  EllipsisVertical,
  XCircle,
  Settings as SettingsIcon,
  Undo,
  Redo,
  LogOut,
  FileJson,
} from "lucide-react";
import SearchResultsPane from "./components/SearchResultsPane";
import { matchText } from "./utils/searchUtils";
import { Sheet } from "react-modal-sheet";
import Login from "./components/Login";
import Register from "./components/Register";

function htmlToPlainTextWithNewlines(html) {
  /* ... (same as before) ... */
  if (!html) return "";
  let text = html;
  text = text.replace(
    /<(div|p|h[1-6]|li|blockquote|pre|tr|hr)[^>]*>/gi,
    "\n$&"
  );
  text = text.replace(/<br\s*\/?>/gi, "\n");
  text = text.replace(/<[^>]+>/g, "");
  try {
    const tempDiv = document.createElement("div");
    tempDiv.innerHTML = text;
    text = tempDiv.textContent || tempDiv.innerText || "";
  } catch (e) {
    /* ignore */
  }
  return text.replace(/(\r?\n|\r){2,}/g, "\n").trim();
}

const APP_HEADER_HEIGHT_CLASS = "h-14 sm:h-12";

const ErrorDisplay = ({ message, type = "error", onClose }) => {
  /* ... (same as before, with success styling) ... */
  if (!message) return null;
  useEffect(() => {
    const timer = setTimeout(() => onClose(), 5000);
    return () => clearTimeout(timer);
  }, [message, onClose]);
  const baseClasses =
    "fixed top-3 right-3 left-3 md:left-auto md:max-w-lg z-[100] px-4 py-3 rounded-lg shadow-xl flex justify-between items-center text-sm transition-all duration-300 ease-in-out";
  let typeClasses =
    type === "success"
      ? "bg-green-100 dark:bg-green-800/80 border border-green-400 dark:border-green-600 text-green-700 dark:text-green-200"
      : "bg-red-100 dark:bg-red-800/80 border border-red-400 dark:border-red-600 text-red-700 dark:text-red-200";
  const iconColor =
    type === "success"
      ? "text-green-500 hover:text-green-700 dark:text-green-300 dark:hover:text-green-100"
      : "text-red-500 hover:text-red-700 dark:text-red-300 dark:hover:text-red-100";
  return (
    <div className={`${baseClasses} ${typeClasses}`}>
      <span>{message}</span>
      <button
        onClick={onClose}
        className={`ml-3 -mr-1 -my-1 p-1 ${iconColor} rounded-full focus:outline-none focus:ring-2 focus:ring-current`}
        aria-label="Close message"
      >
        <XCircle className="w-5 h-5" />
      </button>
    </div>
  );
};

const App = () => {
  const { settings } = useSettings();
  const {
    tree,
    selectedItem,
    selectedItemId,
    selectItemById,
    contextMenu,
    setContextMenu,
    expandedFolders,
    toggleFolderExpand,
    expandFolderPath,
    getItemPath,
    updateNoteContent,
    updateTask,
    renameItem,
    deleteItem,
    draggedId,
    setDraggedId,
    handleDrop,
    clipboardItem,
    copyItem,
    cutItem,
    pasteItem,
    addItem,
    duplicateItem,
    handleExport,
    handleImport: handleImportFromHook, // Renamed to avoid conflict
    searchItems,
    undoTreeChange,
    redoTreeChange,
    canUndoTree,
    canRedoTree,
    resetState: resetTreeHistory,
    fetchUserTree,
    isFetchingTree, // Get these from useTree
  } = useTree();

  const [currentUser, setCurrentUser] = useState(null);
  const [isAuthCheckComplete, setIsAuthCheckComplete] = useState(false);
  const [currentView, setCurrentView] = useState("login");
  const [searchSheetOpen, setSearchSheetOpen] = useState(false);
  const [searchQuery, setSearchQuery] = useState("");
  const [searchOptions, setSearchOptions] = useState({
    caseSensitive: false,
    wholeWord: false,
    useRegex: false,
  });
  const [searchResults, setSearchResults] = useState([]);
  const [addDialogOpen, setAddDialogOpen] = useState(false);
  const [newItemType, setNewItemType] = useState("folder");
  const [newItemLabel, setNewItemLabel] = useState("");
  const [addDialogErrorMessage, setAddDialogErrorMessage] = useState("");
  const [parentItemForAdd, setParentItemForAdd] = useState(null);
  const [inlineRenameId, setInlineRenameId] = useState(null);
  const [inlineRenameValue, setInlineRenameValue] = useState("");
  const [aboutDialogOpen, setAboutDialogOpen] = useState(false);
  const [exportDialogState, setExportDialogState] = useState({
    isOpen: false,
    context: null,
  });
  const [importDialogState, setImportDialogState] = useState({
    isOpen: false,
    context: null,
  });
  const [settingsDialogOpen, setSettingsDialogOpen] = useState(false);
  const [topMenuOpen, setTopMenuOpen] = useState(false);
  const topMenuRef = useRef(null);
  const [uiMessage, setUiMessage] = useState("");
  const [uiMessageType, setUiMessageType] = useState("error");

  const showMessage = useCallback(
    (message, type = "error", duration = 5000) => {
      setUiMessage(message);
      setUiMessageType(type);
      // ErrorDisplay will auto-hide
    },
    []
  );

  const startInlineRename = useCallback(
    (item) => {
      if (!item || draggedId === item.id || inlineRenameId) return;
      showMessage("", "error");
      setInlineRenameId(item.id);
      setInlineRenameValue(item.label);
      setContextMenu((m) => ({ ...m, visible: false }));
    },
    [draggedId, inlineRenameId, showMessage]
  );

  const cancelInlineRename = useCallback(() => {
    setInlineRenameId(null);
    setInlineRenameValue("");
    showMessage("", "error");
    requestAnimationFrame(() =>
      document
        .querySelector('nav[aria-label="Notes and Tasks Tree"]')
        ?.focus({ preventScroll: true })
    );
  }, [showMessage]);

  const findItemByIdFromTree = useCallback(
    (id) => findItemByIdUtil(tree, id),
    [tree]
  );
  const findParentAndSiblingsFromTree = useCallback(
    (id) => findParentAndSiblingsUtil(tree, id),
    [tree]
  );

  const handleAttemptRename = useCallback(async () => {
    if (!inlineRenameId) return;
    const newLabel = inlineRenameValue.trim();
    const originalItem = findItemByIdFromTree(inlineRenameId);
    if (!newLabel) {
      showMessage("Name cannot be empty.", "error");
      return;
    }
    if (newLabel === originalItem?.label) {
      cancelInlineRename();
      return;
    }
    const result = await renameItem(inlineRenameId, newLabel);
    if (result.success) {
      cancelInlineRename();
      showMessage("Item renamed.", "success", 3000);
    } else {
      showMessage(result.error || "Rename failed.", "error");
    }
  }, [
    inlineRenameId,
    inlineRenameValue,
    renameItem,
    cancelInlineRename,
    findItemByIdFromTree,
    showMessage,
  ]);

  const openAddDialog = useCallback(
    (type, parent) => {
      setNewItemType(type);
      setParentItemForAdd(parent);
      setNewItemLabel("");
      setAddDialogErrorMessage("");
      showMessage("", "error");
      setAddDialogOpen(true);
      setContextMenu((m) => ({ ...m, visible: false }));
      setTopMenuOpen(false);
    },
    [showMessage]
  );

  const handleAdd = useCallback(async () => {
    const tl = newItemLabel.trim();
    if (!tl) {
      setAddDialogErrorMessage("Name cannot be empty.");
      return;
    }
    const newItemData = {
      type: newItemType,
      label: tl,
      ...(newItemType === "task" ? { completed: false, content: "" } : {}),
      ...(newItemType === "note" ? { content: "" } : {}),
    };
    const pid = parentItemForAdd?.id ?? null;
    const result = await addItem(newItemData, pid);
    if (result.success) {
      setAddDialogOpen(false);
      setNewItemLabel("");
      setParentItemForAdd(null);
      setAddDialogErrorMessage("");
      showMessage(`${newItemType} added.`, "success", 3000);
      if (result.item?.id) {
        selectItemById(result.item.id);
        if (result.item.type === "folder" && settings.autoExpandNewFolders) {
          if (pid) expandFolderPath(pid);
          else expandFolderPath(result.item.id);
        }
      }
    } else {
      setAddDialogErrorMessage(result.error || "Add operation failed.");
    }
  }, [
    newItemLabel,
    newItemType,
    parentItemForAdd,
    addItem,
    showMessage,
    selectItemById,
    settings.autoExpandNewFolders,
    expandFolderPath,
  ]);

  const handleToggleTask = useCallback(
    async (id, currentCompletedStatus) => {
      const result = await updateTask(id, {
        completed: !currentCompletedStatus,
      });
      if (!result.success)
        showMessage(result.error || "Failed to update task status.", "error");
      else showMessage("Task status updated.", "success", 2000);
    },
    [updateTask, showMessage]
  );

  const handleDragEnd = useCallback(() => setDraggedId(null), []);
  const openExportDialog = useCallback((context) => {
    setExportDialogState({ isOpen: true, context });
    setContextMenu((m) => ({ ...m, visible: false }));
    setTopMenuOpen(false);
  }, []);
  const openImportDialog = useCallback((context) => {
    setImportDialogState({ isOpen: true, context });
    setContextMenu((m) => ({ ...m, visible: false }));
    setTopMenuOpen(false);
  }, []);

  const handleFileImport = useCallback(
    async (file, importTargetOption) => {
      showMessage("", "error");
      const result = await handleImportFromHook(file, importTargetOption); // Use renamed hook function
      if (result && result.success) {
        showMessage(result.message || "Import successful!", "success");
        setTimeout(() => {
          setImportDialogState({ isOpen: false, context: null });
          showMessage("", "success");
        }, 1500);
        return {
          success: true,
          message: result.message || "Import successful!",
        };
      } else {
        showMessage(result?.error || "Import operation failed.", "error");
        return {
          success: false,
          error: result?.error || "Import operation failed.",
        };
      }
    },
    [handleImportFromHook, setImportDialogState, showMessage]
  );

  const handlePasteWrapper = useCallback(
    async (targetId) => {
      const result = await pasteItem(targetId);
      if (!result.success)
        showMessage(result.error || "Paste operation failed.", "error");
      else showMessage("Item pasted.", "success", 3000);
    },
    [pasteItem, showMessage]
  );

  const handleDeleteConfirm = useCallback(
    async (itemIdToDelete) => {
      if (itemIdToDelete) {
        const result = await deleteItem(itemIdToDelete);
        if (!result.success)
          showMessage(result.error || "Delete operation failed.", "error");
        else showMessage("Item deleted.", "success", 3000);
      }
      setContextMenu((m) => ({ ...m, visible: false }));
    },
    [deleteItem, showMessage]
  );

  const handleShowItemMenu = useCallback(
    (item, buttonElement) => {
      /* ... (as before) ... */
      if (!item || !buttonElement) return;
      const rect = buttonElement.getBoundingClientRect();
      let x = rect.left,
        y = rect.bottom + 2;
      const menuWidth = 190,
        menuHeight = item.type === "folder" ? 350 : 280;
      if (x + menuWidth > window.innerWidth - 10)
        x = window.innerWidth - menuWidth - 10;
      if (x < 10) x = 10;
      if (y + menuHeight > window.innerHeight - 10)
        y = rect.top - menuHeight - 2;
      if (y < 10) y = 10;
      selectItemById(item.id);
      setContextMenu({ visible: true, x, y, item, isEmptyArea: false });
    },
    [selectItemById]
  );

  const handleNativeContextMenu = useCallback(
    (event, item) => {
      /* ... (as before) ... */
      if (draggedId || inlineRenameId) {
        event.preventDefault();
        return;
      }
      event.preventDefault();
      event.stopPropagation();
      selectItemById(item?.id ?? null);
      let x = event.clientX,
        y = event.clientY;
      const menuWidth = 190,
        menuHeight = item ? (item.type === "folder" ? 350 : 280) : 180;
      if (x + menuWidth > window.innerWidth - 10)
        x = window.innerWidth - menuWidth - 10;
      if (x < 10) x = 10;
      if (y + menuHeight > window.innerHeight - 10)
        y = window.innerHeight - menuHeight - 10;
      if (y < 10) y = 10;
      setContextMenu({ visible: true, x, y, item, isEmptyArea: !item });
    },
    [draggedId, inlineRenameId, selectItemById]
  );

  useEffect(() => {
    // Handles initial auth check and tree loading
    const token = localStorage.getItem("userToken");
    if (token) {
      setCurrentUser({ token }); // Set minimal current user
      setCurrentView("app");
      if (fetchUserTree) fetchUserTree(token); // Pass token directly for clarity
    } else {
      setCurrentView("login");
      if (resetTreeHistory) resetTreeHistory([]);
    }
    setIsAuthCheckComplete(true);
  }, [fetchUserTree, resetTreeHistory]); // fetchUserTree and resetTreeHistory are stable

  const handleLoginSuccess = async (userData) => {
    setCurrentUser(userData); // userData from backend (token already set in localStorage by Login.jsx)
    setCurrentView("app");
    if (fetchUserTree) {
      await fetchUserTree(localStorage.getItem("userToken")); // Fetch tree using the new token
    }
  };

  const handleLogout = () => {
    localStorage.removeItem("userToken");
    setCurrentUser(null);
    if (resetTreeHistory) resetTreeHistory([]);
    showMessage("");
    setCurrentView("login");
  };

  useEffect(() => {
    /* ... (Global Keydown for Undo/Redo, Search Toggle - as before) ... */
    const handler = (e) => {
      const activeElement = document.activeElement;
      const isInput =
        activeElement &&
        (activeElement.tagName === "INPUT" ||
          activeElement.tagName === "TEXTAREA" ||
          activeElement.isContentEditable);
      const isRenameActive =
        !!inlineRenameId &&
        activeElement?.closest(`li[data-item-id="${inlineRenameId}"] input`) ===
          activeElement;
      if (
        (e.ctrlKey || e.metaKey) &&
        e.key.toLowerCase() === "z" &&
        !e.shiftKey
      ) {
        if (
          isInput &&
          !isRenameActive &&
          activeElement.id !== "tree-navigation-area" &&
          activeElement.id !== "global-search-input" &&
          !activeElement.classList.contains("editor-pane")
        )
          return;
        e.preventDefault();
        if (canUndoTree) undoTreeChange();
      } else if (
        (e.ctrlKey || e.metaKey) &&
        (e.key.toLowerCase() === "y" ||
          (e.shiftKey && e.key.toLowerCase() === "z"))
      ) {
        if (
          isInput &&
          !isRenameActive &&
          activeElement.id !== "tree-navigation-area" &&
          activeElement.id !== "global-search-input" &&
          !activeElement.classList.contains("editor-pane")
        )
          return;
        e.preventDefault();
        if (canRedoTree) redoTreeChange();
      } else if (
        (e.ctrlKey || e.metaKey) &&
        e.shiftKey &&
        e.key.toUpperCase() === "F"
      ) {
        if (isInput && activeElement.id === "global-search-input") return;
        e.preventDefault();
        setSearchSheetOpen((s) => !s);
      }
    };
    window.addEventListener("keydown", handler);
    return () => window.removeEventListener("keydown", handler);
  }, [
    canUndoTree,
    undoTreeChange,
    canRedoTree,
    redoTreeChange,
    inlineRenameId,
  ]);

  useEffect(() => {
    /* ... (Global Keydown for Tree Item Operations - as refined before) ... */
    const handleGlobalTreeOpsKeyDown = async (e) => {
      const activeEl = document.activeElement;
      const isRenameActive =
        !!inlineRenameId &&
        activeEl?.closest(`li[data-item-id="${inlineRenameId}"] input`) ===
          activeEl;
      if (isRenameActive && (e.key === "Enter" || e.key === "Escape")) return;
      const isStandardInputFocused =
        activeEl &&
        (activeEl.tagName === "INPUT" || activeEl.tagName === "TEXTAREA") &&
        activeEl.id !== "tree-navigation-area" &&
        !isRenameActive;
      const isContentEditorFocused =
        activeEl &&
        (activeEl.classList.contains("editor-pane") ||
          activeEl.closest(".editor-pane"));
      if (
        (isStandardInputFocused || isContentEditorFocused) &&
        !(
          (e.ctrlKey || e.metaKey) &&
          ["c", "x", "v"].includes(e.key.toLowerCase())
        )
      ) {
        if (e.key === "F2" && isContentEditorFocused) return;
        else if (e.key === "Delete" || e.key === "Backspace") return;
      }
      const treeNav = document.querySelector(
        'nav[aria-label="Notes and Tasks Tree"]'
      );
      const isTreeAreaLikelyFocused =
        treeNav &&
        (treeNav === activeEl ||
          treeNav.contains(activeEl) ||
          document.body === activeEl);
      if (
        e.key === "F2" &&
        selectedItemId &&
        !isRenameActive &&
        !isContentEditorFocused
      ) {
        if (isTreeAreaLikelyFocused || document.body === activeEl) {
          e.preventDefault();
          const item = findItemByIdFromTree(selectedItemId);
          if (item) startInlineRename(item);
        }
      } else if (
        (e.ctrlKey || e.metaKey) &&
        e.key.toLowerCase() === "c" &&
        selectedItemId &&
        !isRenameActive &&
        !isContentEditorFocused
      ) {
        e.preventDefault();
        copyItem(selectedItemId);
        showMessage("Item copied.", "success", 2000);
      } else if (
        (e.ctrlKey || e.metaKey) &&
        e.key.toLowerCase() === "x" &&
        selectedItemId &&
        !isRenameActive &&
        !isContentEditorFocused
      ) {
        e.preventDefault();
        cutItem(selectedItemId);
        showMessage("Item cut.", "success", 2000);
      } else if (
        (e.ctrlKey || e.metaKey) &&
        e.key.toLowerCase() === "v" &&
        clipboardItem &&
        !isRenameActive &&
        !isContentEditorFocused
      ) {
        e.preventDefault();
        const currentItem = findItemByIdFromTree(selectedItemId);
        const targetIdForPaste =
          currentItem?.type === "folder"
            ? selectedItemId
            : findParentAndSiblingsFromTree(selectedItemId)?.parent?.id ?? null;
        await handlePasteWrapper(targetIdForPaste);
      } else if (
        (e.key === "Delete" || e.key === "Backspace") &&
        selectedItemId &&
        !isRenameActive
      ) {
        if (
          isContentEditorFocused ||
          (isStandardInputFocused && activeEl.id !== "tree-navigation-area")
        )
          return;
        if (
          activeEl.id === "global-search-input" &&
          ((e.key === "Backspace" && searchQuery !== "") || e.key === "Delete")
        )
          return;
        if (isTreeAreaLikelyFocused || document.body === activeEl) {
          e.preventDefault();
          const item = findItemByIdFromTree(selectedItemId);
          if (
            item &&
            window.confirm(`Delete "${item.label}"? This cannot be undone.`)
          ) {
            await handleDeleteConfirm(selectedItemId);
          }
        }
      }
    };
    window.addEventListener("keydown", handleGlobalTreeOpsKeyDown);
    return () =>
      window.removeEventListener("keydown", handleGlobalTreeOpsKeyDown);
  }, [
    selectedItemId,
    inlineRenameId,
    tree,
    clipboardItem,
    searchQuery,
    copyItem,
    cutItem,
    pasteItem,
    deleteItem,
    startInlineRename,
    handlePasteWrapper,
    showMessage,
    findItemByIdFromTree,
    findParentAndSiblingsFromTree,
  ]);

  useEffect(() => {
    /* ... (Search Results processing - as before) ... */
    if (searchQuery && searchSheetOpen) {
      const currentSearchOpts = { ...searchOptions, useRegex: false };
      const rawHits = searchItems(searchQuery, currentSearchOpts);
      const CONTEXT_CHARS_BEFORE = 20,
        CONTEXT_CHARS_AFTER = 20,
        MAX_SNIPPET_LENGTH = 80;
      let resultCounter = 0;
      const processedResults = rawHits
        .map((hit) => {
          if (!hit || !hit.id) return null;
          const pathString = getItemPath(hit.id);
          const originalLabel =
            typeof hit.label === "string"
              ? hit.label
              : typeof hit.title === "string"
              ? hit.title
              : "";
          const originalContentHtml =
            typeof hit.content === "string" ? hit.content : "";
          const plainTextContent =
            htmlToPlainTextWithNewlines(originalContentHtml);
          let displaySnippetText = "",
            hlStartIndex = -1,
            hlEndIndex = -1,
            matchSrc = "";
          let pathLabelHlDetails = {
            start: -1,
            end: -1,
            originalMatchInLabel: "",
          };
          const labelMatchInfo = matchText(
            originalLabel,
            searchQuery,
            currentSearchOpts
          );
          if (labelMatchInfo) {
            matchSrc = "label";
            displaySnippetText = originalLabel;
            hlStartIndex = labelMatchInfo.startIndex;
            hlEndIndex =
              labelMatchInfo.startIndex + labelMatchInfo.matchedString.length;
            pathLabelHlDetails = {
              start: labelMatchInfo.startIndex,
              end: hlEndIndex,
              originalMatchInLabel: labelMatchInfo.matchedString,
            };
          }
          if (
            (hit.type === "note" || hit.type === "task") &&
            plainTextContent
          ) {
            const contentMatchInfo = matchText(
              plainTextContent,
              searchQuery,
              currentSearchOpts
            );
            if (contentMatchInfo) {
              if (matchSrc === "label") matchSrc = "label & content";
              else {
                matchSrc = "content";
                const { matchedString, startIndex: siInPlainText } =
                  contentMatchInfo;
                let snipStart = Math.max(
                  0,
                  siInPlainText - CONTEXT_CHARS_BEFORE
                );
                let snipEnd = Math.min(
                  plainTextContent.length,
                  siInPlainText + matchedString.length + CONTEXT_CHARS_AFTER
                );
                displaySnippetText = plainTextContent.substring(
                  snipStart,
                  snipEnd
                );
                hlStartIndex = siInPlainText - snipStart;
                hlEndIndex = hlStartIndex + matchedString.length;
                let preEll = snipStart > 0,
                  sufEll = snipEnd < plainTextContent.length;
                if (displaySnippetText.length > MAX_SNIPPET_LENGTH) {
                  const ovf = displaySnippetText.length - MAX_SNIPPET_LENGTH;
                  let redPre = Math.floor(ovf / 2);
                  if (hlStartIndex < redPre) redPre = hlStartIndex;
                  if (redPre > 0) {
                    displaySnippetText = displaySnippetText.substring(redPre);
                    hlStartIndex -= redPre;
                    hlEndIndex -= redPre;
                    preEll = true;
                  }
                  if (displaySnippetText.length > MAX_SNIPPET_LENGTH) {
                    const cutEnd =
                      displaySnippetText.length - MAX_SNIPPET_LENGTH;
                    displaySnippetText = displaySnippetText.substring(
                      0,
                      displaySnippetText.length - cutEnd
                    );
                    sufEll = true;
                  }
                  hlStartIndex = Math.max(0, hlStartIndex);
                  hlEndIndex = Math.min(displaySnippetText.length, hlEndIndex);
                  if (hlStartIndex >= hlEndIndex) {
                    hlStartIndex = -1;
                    hlEndIndex = -1;
                  }
                }
                if (preEll && !displaySnippetText.startsWith("..."))
                  displaySnippetText = "..." + displaySnippetText;
                if (sufEll && !displaySnippetText.endsWith("..."))
                  displaySnippetText = displaySnippetText + "...";
              }
            }
          }
          if (!matchSrc) {
            displaySnippetText = originalLabel;
            matchSrc = "unknown";
          }
          return {
            id: `${hit.id}-${matchSrc}-${resultCounter++}`,
            originalId: hit.id,
            ...hit,
            path: pathString,
            displaySnippetText,
            highlightStartIndexInSnippet: hlStartIndex,
            highlightEndIndexInSnippet: hlEndIndex,
            matchSource: matchSrc,
            pathLabelHighlight:
              pathLabelHlDetails.start !== -1 ? pathLabelHlDetails : undefined,
          };
        })
        .filter(Boolean);
      setSearchResults(
        processedResults.filter(
          (r) => r && r.matchSource && r.matchSource !== "unknown"
        )
      );
    } else {
      setSearchResults([]);
    }
  }, [
    searchQuery,
    searchOptions,
    searchItems,
    getItemPath,
    searchSheetOpen,
    tree,
    matchText,
  ]);

  useEffect(() => {
    /* ... (Top Menu Outside Click Handler - as before) ... */
    const handleClickOutside = (e) => {
      if (topMenuRef.current && !topMenuRef.current.contains(e.target))
        setTopMenuOpen(false);
    };
    document.addEventListener("mousedown", handleClickOutside);
    return () => document.removeEventListener("mousedown", handleClickOutside);
  }, []);

  if (!isAuthCheckComplete) {
    return (
      <div className="flex items-center justify-center min-h-screen bg-zinc-100 dark:bg-zinc-900 text-zinc-100">
        Loading application...
      </div>
    );
  }

  if (currentView === "login") {
    return (
      <Login
        onLoginSuccess={handleLoginSuccess}
        onSwitchToRegister={() => setCurrentView("register")}
      />
    );
  }
  if (currentView === "register") {
    return (
      <Register
        onRegisterSuccess={() => setCurrentView("login")}
        onSwitchToLogin={() => setCurrentView("login")}
      />
    );
  }

  // currentView === 'app'
  return (
    <div className="relative flex flex-col h-screen bg-zinc-100 dark:bg-zinc-900 text-zinc-900 dark:text-zinc-100 overflow-hidden">
      <ErrorDisplay
        message={uiMessage}
        type={uiMessageType}
        onClose={() => setUiMessage("")}
      />
      <header
        className={`fixed top-0 left-0 right-0 z-30 bg-white dark:bg-zinc-800/95 backdrop-blur-sm shadow-sm ${APP_HEADER_HEIGHT_CLASS}`}
      >
        {/* ... Header JSX as before ... */}
        <div className="container mx-auto px-2 sm:px-4 flex justify-between items-center h-full">
          <h1 className="font-semibold text-lg sm:text-xl md:text-2xl whitespace-nowrap overflow-hidden text-ellipsis mr-2 text-zinc-800 dark:text-zinc-100">
            Notes & Tasks
          </h1>
          <div
            className="flex items-center space-x-0.5 sm:space-x-1 relative"
            ref={topMenuRef}
          >
            <button
              onClick={undoTreeChange}
              disabled={!canUndoTree}
              title="Undo (Ctrl+Z)"
              className={`p-2 hover:bg-zinc-200 dark:hover:bg-zinc-700 rounded-full ${
                !canUndoTree
                  ? "opacity-40 cursor-not-allowed"
                  : "text-zinc-600 dark:text-zinc-300"
              }`}
            >
              {" "}
              <Undo className="w-5 h-5" />{" "}
            </button>
            <button
              onClick={redoTreeChange}
              disabled={!canRedoTree}
              title="Redo (Ctrl+Y)"
              className={`p-2 hover:bg-zinc-200 dark:hover:bg-zinc-700 rounded-full ${
                !canRedoTree
                  ? "opacity-40 cursor-not-allowed"
                  : "text-zinc-600 dark:text-zinc-300"
              }`}
            >
              {" "}
              <Redo className="w-5 h-5" />{" "}
            </button>
            <button
              onClick={() => setSearchSheetOpen((s) => !s)}
              title="Search (Ctrl+Shift+F)"
              className={`p-2 hover:bg-zinc-200 dark:hover:bg-zinc-700 rounded-full ${
                searchSheetOpen
                  ? "bg-blue-100 dark:bg-blue-700/50 text-blue-600 dark:text-blue-300"
                  : "text-zinc-600 dark:text-zinc-300"
              }`}
            >
              {" "}
              <SearchIcon className="w-5 h-5" />{" "}
            </button>
            <button
              onClick={() => setSettingsDialogOpen(true)}
              className="p-2 text-zinc-600 dark:text-zinc-300 hover:bg-zinc-200 dark:hover:bg-zinc-700 rounded-full"
              title="Settings"
            >
              {" "}
              <SettingsIcon className="w-5 h-5" />{" "}
            </button>
            <button
              onClick={() => setTopMenuOpen((p) => !p)}
              className="p-2 text-zinc-600 dark:text-zinc-300 hover:bg-zinc-200 dark:hover:bg-zinc-700 rounded-full"
              title="More actions"
            >
              {" "}
              <EllipsisVertical className="w-5 h-5" />{" "}
            </button>
            {topMenuOpen && (
              <div className="absolute top-full right-0 mt-2 w-56 bg-white dark:bg-zinc-800 border border-zinc-200 dark:border-zinc-700 rounded-md shadow-lg z-40 py-1">
                <button
                  onClick={() => {
                    openAddDialog("folder", null);
                    setTopMenuOpen(false);
                  }}
                  className="flex items-center gap-3 w-full px-4 py-2.5 text-sm text-left text-zinc-700 dark:text-zinc-200 hover:bg-zinc-100 dark:hover:bg-zinc-700"
                >
                  {" "}
                  <FileJson className="w-4 h-4 opacity-70" /> Add Root Folder{" "}
                </button>
                <button
                  onClick={() => {
                    openExportDialog("tree");
                    setTopMenuOpen(false);
                  }}
                  className="flex items-center gap-3 w-full px-4 py-2.5 text-sm text-left text-zinc-700 dark:text-zinc-200 hover:bg-zinc-100 dark:hover:bg-zinc-700"
                >
                  {" "}
                  <FileJson className="w-4 h-4 opacity-70" /> Export Full
                  Tree...{" "}
                </button>
                <button
                  onClick={() => {
                    openImportDialog("tree");
                    setTopMenuOpen(false);
                  }}
                  className="flex items-center gap-3 w-full px-4 py-2.5 text-sm text-left text-zinc-700 dark:text-zinc-200 hover:bg-zinc-100 dark:hover:bg-zinc-700"
                >
                  {" "}
                  <FileJson className="w-4 h-4 opacity-70" /> Import Full
                  Tree...{" "}
                </button>
                <div className="my-1 h-px bg-zinc-200 dark:bg-zinc-700"></div>
                <button
                  onClick={() => {
                    setAboutDialogOpen(true);
                    setTopMenuOpen(false);
                  }}
                  className="flex items-center gap-3 w-full px-4 py-2.5 text-sm text-left text-zinc-700 dark:text-zinc-200 hover:bg-zinc-100 dark:hover:bg-zinc-700"
                >
                  {" "}
                  <Info className="w-4 h-4 opacity-70" /> About{" "}
                </button>
                <button
                  onClick={() => {
                    handleLogout();
                    setTopMenuOpen(false);
                  }}
                  className="flex items-center gap-3 w-full px-4 py-2.5 text-sm text-left text-red-600 dark:text-red-400 hover:bg-red-50 dark:hover:bg-red-700/30"
                >
                  {" "}
                  <LogOut className="w-4 h-4 opacity-70" /> Logout{" "}
                </button>
              </div>
            )}
          </div>
        </div>
      </header>
      <main className={`flex-1 flex min-h-0 pt-14 sm:pt-12`}>
        <PanelGroup direction="horizontal" className="flex-1">
          <Panel
            id="tree-panel"
            order={0}
            defaultSize={30}
            minSize={20}
            maxSize={60}
            className="flex flex-col !overflow-hidden bg-zinc-50 dark:bg-zinc-800/30 border-r border-zinc-200 dark:border-zinc-700/50"
          >
            {/* ... Tree Panel JSX as before ... */}
            <div
              className="flex-grow overflow-auto"
              id="tree-navigation-area"
              tabIndex={-1}
            >
              <Tree
                items={tree || []}
                selectedItemId={selectedItemId}
                onSelect={selectItemById}
                inlineRenameId={inlineRenameId}
                inlineRenameValue={inlineRenameValue}
                setInlineRenameValue={setInlineRenameValue}
                onAttemptRename={handleAttemptRename}
                cancelInlineRename={cancelInlineRename}
                expandedFolders={expandedFolders}
                onToggleExpand={toggleFolderExpand}
                onToggleTask={handleToggleTask}
                draggedId={draggedId}
                onDragStart={(e, id) => {
                  if (inlineRenameId) {
                    e.preventDefault();
                    return;
                  }
                  try {
                    if (e.dataTransfer) {
                      e.dataTransfer.setData("text/plain", id);
                      e.dataTransfer.effectAllowed = "move";
                    }
                    setDraggedId(id);
                  } catch (err) {
                    console.error("Drag error:", err);
                    showMessage("Drag operation failed.", "error");
                  }
                }}
                onDrop={(targetId) => handleDrop(targetId, draggedId)}
                onDragEnd={handleDragEnd}
                onNativeContextMenu={handleNativeContextMenu}
                onShowItemMenu={handleShowItemMenu}
                onRename={startInlineRename}
                uiError={uiMessage}
                setUiError={(msg) => showMessage(msg, "error")}
              />
            </div>
          </Panel>
          <PanelResizeHandle className="w-1.5 bg-zinc-200 dark:bg-zinc-700 hover:bg-blue-500 data-[resize-handle-active=true]:bg-blue-600 transition-colors cursor-col-resize z-20 flex-shrink-0" />
          <Panel
            id="content-panel"
            order={1}
            defaultSize={70}
            minSize={30}
            className="flex flex-col !overflow-hidden bg-white dark:bg-zinc-900"
          >
            {" "}
            {/* CHANGED to dark:bg-zinc-900 for panel */}
            <div className="flex-grow overflow-auto h-full">
              {selectedItem ? (
                selectedItem.type === "folder" ? (
                  <div className="p-3 sm:p-4">
                    <h2 className="text-lg sm:text-xl font-semibold mb-3 text-zinc-800 dark:text-zinc-100 break-words">
                      {" "}
                      {/* Added dark text color */}
                      {selectedItem.label}
                    </h2>
                    <FolderContents
                      folder={selectedItem}
                      onSelect={selectItemById}
                      handleDragStart={(e, id) => {
                        if (inlineRenameId) e.preventDefault();
                        else setDraggedId(id);
                      }}
                      handleDragEnter={(e, id) => {}}
                      handleDragOver={(e) => e.preventDefault()}
                      handleDragLeave={(e) => {}}
                      handleDrop={(e, targetItemId) => {
                        if (draggedId && targetItemId === selectedItem.id) {
                          handleDrop(targetItemId, draggedId);
                        }
                      }}
                      handleDragEnd={handleDragEnd}
                      draggedId={draggedId}
                      onToggleExpand={toggleFolderExpand}
                      expandedItems={expandedFolders}
                      onShowItemMenu={handleShowItemMenu}
                    />
                  </div>
                ) : selectedItem.type === "note" ||
                  selectedItem.type === "task" ? (
                  <ContentEditor
                    key={selectedItemId}
                    item={selectedItem}
                    defaultFontFamily={settings.editorFontFamily}
                    defaultFontSize={settings.editorFontSize}
                    onSaveContent={
                      selectedItem.type === "task"
                        ? async (id, content) => {
                            const result = await updateTask(id, { content });
                            if (!result.success)
                              showMessage(
                                result.error || "Failed to save task content.",
                                "error"
                              );
                          }
                        : async (id, content) => {
                            const result = await updateNoteContent(id, content);
                            if (!result.success)
                              showMessage(
                                result.error || "Failed to save note content.",
                                "error"
                              );
                          }
                    }
                  />
                ) : null
              ) : (
                <div className="flex items-center justify-center h-full text-zinc-500 dark:text-zinc-400 p-4 text-center">
                  {" "}
                  Select or create an item to view or edit its content.{" "}
                </div>
              )}
            </div>
          </Panel>
        </PanelGroup>
      </main>
      {/* ... Sheet, ContextMenu, AddDialog, AboutDialog, ExportDialog, ImportDialog, SettingsDialog JSX as before ... */}
      <Sheet
        isOpen={searchSheetOpen}
        onClose={() => setSearchSheetOpen(false)}
        snapPoints={[0.85, 0.6, 0.3]}
        initialSnap={1}
        className="z-40"
      >
        <Sheet.Container className="!bg-zinc-50 dark:!bg-zinc-900 !rounded-t-xl">
          <Sheet.Header>
            <div className="flex justify-center py-2.5 cursor-grab">
              <div className="w-10 h-1.5 bg-zinc-300 dark:bg-zinc-600 rounded-full"></div>
            </div>
          </Sheet.Header>
          <Sheet.Content className="!pb-0">
            <div className="overflow-y-auto h-full">
              <SearchResultsPane
                headerHeightClass={APP_HEADER_HEIGHT_CLASS}
                query={searchQuery}
                onQueryChange={setSearchQuery}
                results={searchResults}
                onSelectResult={(item) => {
                  if (item.originalId) {
                    expandFolderPath(item.originalId);
                    selectItemById(item.originalId);
                    setSearchSheetOpen(false);
                    setTimeout(() => {
                      document
                        .querySelector(`li[data-item-id="${item.originalId}"]`)
                        ?.scrollIntoView({
                          behavior: "smooth",
                          block: "center",
                        });
                    }, 100);
                  }
                }}
                onClose={() => setSearchSheetOpen(false)}
                opts={searchOptions}
                setOpts={setSearchOptions}
              />
            </div>
          </Sheet.Content>
        </Sheet.Container>
        <Sheet.Backdrop onTap={() => setSearchSheetOpen(false)} />
      </Sheet>
      {contextMenu.visible && (
        <ContextMenu
          visible={contextMenu.visible}
          x={contextMenu.x}
          y={contextMenu.y}
          item={contextMenu.item}
          isEmptyArea={contextMenu.isEmptyArea}
          clipboardItem={clipboardItem}
          onAddRootFolder={() => openAddDialog("folder", null)}
          onAddFolder={() =>
            contextMenu.item && openAddDialog("folder", contextMenu.item)
          }
          onAddNote={() =>
            contextMenu.item && openAddDialog("note", contextMenu.item)
          }
          onAddTask={() =>
            contextMenu.item && openAddDialog("task", contextMenu.item)
          }
          onRename={() =>
            contextMenu.item && startInlineRename(contextMenu.item)
          }
          onDelete={() => {
            if (contextMenu.item) {
              if (
                window.confirm(
                  `Delete "${contextMenu.item.label}"? This cannot be undone.`
                )
              ) {
                handleDeleteConfirm(contextMenu.item.id);
              } else {
                setContextMenu((m) => ({ ...m, visible: false }));
              }
            } else {
              setContextMenu((m) => ({ ...m, visible: false }));
            }
          }}
          onDuplicate={async () => {
            if (contextMenu.item) {
              const result = await duplicateItem(contextMenu.item.id);
              if (!result.success)
                showMessage(result.error || "Duplicate failed", "error");
              else showMessage("Item duplicated.", "success", 3000);
            }
          }}
          onClose={() => setContextMenu((m) => ({ ...m, visible: false }))}
          onCopy={() => {
            if (contextMenu.item) {
              copyItem(contextMenu.item.id);
              showMessage("Item copied.", "success", 2000);
            }
          }}
          onCut={() => {
            if (contextMenu.item) {
              cutItem(contextMenu.item.id);
              showMessage("Item cut.", "success", 2000);
            }
          }}
          onPaste={async () => {
            const tid = contextMenu.isEmptyArea
              ? null
              : contextMenu.item?.type === "folder"
              ? contextMenu.item.id
              : findParentAndSiblingsFromTree(contextMenu.item?.id)?.parent
                  ?.id ?? null;
            await handlePasteWrapper(tid);
          }}
          onExportItem={() => openExportDialog("item")}
          onImportItem={() => openImportDialog("item")}
          onExportTree={() => openExportDialog("tree")}
          onImportTree={() => openImportDialog("tree")}
        />
      )}
      <AddDialog
        isOpen={addDialogOpen}
        newItemType={newItemType}
        newItemLabel={newItemLabel}
        errorMessage={addDialogErrorMessage}
        onLabelChange={(e) => {
          setNewItemLabel(e.target.value);
          if (addDialogOpen) setAddDialogErrorMessage("");
        }}
        onAdd={handleAdd}
        onCancel={() => {
          setAddDialogOpen(false);
          setAddDialogErrorMessage("");
          showMessage("", "error");
        }}
      />
      <AboutDialog
        isOpen={aboutDialogOpen}
        onClose={() => setAboutDialogOpen(false)}
      />
      <ExportDialog
        isOpen={exportDialogState.isOpen}
        context={exportDialogState.context}
        defaultFormat={settings.defaultExportFormat}
        onClose={() => setExportDialogState({ isOpen: false, context: null })}
        onExport={handleExport}
      />
      <ImportDialog
        isOpen={importDialogState.isOpen}
        context={importDialogState.context}
        selectedItem={selectedItem}
        onClose={() => {
          setImportDialogState({ isOpen: false, context: null });
          showMessage("", "success");
        }}
        onImport={handleFileImport}
      />
      <SettingsDialog
        isOpen={settingsDialogOpen}
        onClose={() => setSettingsDialogOpen(false)}
      />
    </div>
  );
};
export default App;


--- src\index.css ---
@tailwind base;
@tailwind components;
@tailwind utilities;

--- src\main.jsx ---
// src/main.jsx
import React from "react";
import ReactDOM from "react-dom/client";
import App from "./App.jsx";
import { SettingsProvider } from "./contexts/SettingsContext"; // <-- Import Provider
import "./styles/index.css";

ReactDOM.createRoot(document.getElementById("root")).render(
  <React.StrictMode>
    {/* Wrap App with the SettingsProvider */}
    <SettingsProvider>
      <App />
    </SettingsProvider>
  </React.StrictMode>
);

--- tests\components\AboutDialog.test.jsx ---
// tests/components/AboutDialog.test.jsx
import React from "react";
import { render, screen, fireEvent } from "@testing-library/react";
import "@testing-library/jest-dom";
import AboutDialog from "../../src/components/AboutDialog";
// Ensure package.json is correctly resolved relative to this test file, or mock it
// For simplicity, let's assume a mock or that the path is correct.
// If it causes issues, you might need to configure Jest's moduleNameMapper or mock package.json
let packageJson;
try {
  packageJson = require("../../package.json");
} catch (e) {
  // Mock if package.json is not found at that relative path during testing
  console.warn(
    "package.json not found for AboutDialog test, using mock version."
  );
  packageJson = { version: "1.0.0-test" };
}

describe("<AboutDialog />", () => {
  const mockOnClose = jest.fn();
  const originalGetFullYear = Date.prototype.getFullYear;

  beforeEach(() => {
    mockOnClose.mockClear();
    // Mock current year for consistent testing
    Date.prototype.getFullYear = jest.fn(() => 2025);
  });

  afterEach(() => {
    Date.prototype.getFullYear = originalGetFullYear; // Restore original Date object
  });

  test("does not render when isOpen is false", () => {
    const { container } = render(
      <AboutDialog isOpen={false} onClose={mockOnClose} />
    );
    expect(container.firstChild).toBeNull();
  });

  test("renders correctly when isOpen is true", () => {
    render(<AboutDialog isOpen={true} onClose={mockOnClose} />);
    expect(
      screen.getByRole("heading", { name: /About Notes & Tasks App/i })
    ).toBeInTheDocument();
    expect(screen.getByText(/Notes & Tasks App © 2025/)).toBeInTheDocument();
    expect(
      screen.getByText(new RegExp(`Version: ${packageJson.version}`))
    ).toBeInTheDocument();
    expect(screen.getByRole("button", { name: /Close/i })).toBeInTheDocument();
  });

  test("calls onClose when Close button is clicked", () => {
    render(<AboutDialog isOpen={true} onClose={mockOnClose} />);
    const closeButton = screen.getByRole("button", { name: /Close/i });
    fireEvent.click(closeButton);
    expect(mockOnClose).toHaveBeenCalledTimes(1);
  });

  test("modal overlay is present", () => {
    render(<AboutDialog isOpen={true} onClose={mockOnClose} />);
    const overlay = screen
      .getByRole("button", { name: /Close/i })
      .closest("div.fixed.inset-0");
    expect(overlay).toHaveClass("bg-black", "bg-opacity-50");
  });

  test("close button is focused on open", () => {
    render(<AboutDialog isOpen={true} onClose={mockOnClose} />);
    expect(screen.getByRole("button", { name: /Close/i })).toHaveFocus();
  });
});


--- tests\components\AddDialog.test.jsx ---
// tests/components/AddDialog.test.jsx
import React from "react";
import { render, screen, fireEvent, waitFor } from "@testing-library/react";
import "@testing-library/jest-dom";
import AddDialog from "../../src/components/AddDialog";

describe("<AddDialog />", () => {
  const mockOnLabelChange = jest.fn();
  const mockOnAdd = jest.fn();
  const mockOnCancel = jest.fn();

  const defaultProps = {
    isOpen: true,
    newItemType: "folder",
    newItemLabel: "",
    errorMessage: "",
    onLabelChange: mockOnLabelChange,
    onAdd: mockOnAdd,
    onCancel: mockOnCancel,
  };

  beforeEach(() => {
    mockOnLabelChange.mockClear();
    mockOnAdd.mockClear();
    mockOnCancel.mockClear();
  });

  test("does not render when isOpen is false", () => {
    const { container } = render(
      <AddDialog {...defaultProps} isOpen={false} />
    );
    expect(container.firstChild).toBeNull();
  });

  test("renders correct title based on newItemType", () => {
    const { rerender } = render(
      <AddDialog {...defaultProps} newItemType="folder" />
    );
    expect(
      screen.getByRole("heading", { name: /Add folder/i })
    ).toBeInTheDocument();

    rerender(<AddDialog {...defaultProps} newItemType="note" />);
    expect(
      screen.getByRole("heading", { name: /Add note/i })
    ).toBeInTheDocument();

    rerender(<AddDialog {...defaultProps} newItemType="task" />);
    expect(
      screen.getByRole("heading", { name: /Add task/i })
    ).toBeInTheDocument();
  });

  test("renders input, calls onLabelChange, and focuses input", async () => {
    render(<AddDialog {...defaultProps} />);
    const input = screen.getByPlaceholderText(/Enter folder name/i);
    expect(input).toBeInTheDocument();
    await waitFor(() => expect(input).toHaveFocus());
    expect(input).toHaveValue("");

    fireEvent.change(input, { target: { value: "New Folder Name" } });
    expect(mockOnLabelChange).toHaveBeenCalledTimes(1);
  });

  test("displays specific error message when errorMessage prop is set", () => {
    const errorText = "Duplicate name detected!";
    render(<AddDialog {...defaultProps} errorMessage={errorText} />);
    expect(screen.getByText(errorText)).toBeInTheDocument();
    const input = screen.getByPlaceholderText(/Enter folder name/i);
    expect(input).toHaveAttribute("aria-invalid", "true");
    expect(input).toHaveAttribute("aria-describedby", "add-error-message");
    expect(input).toHaveClass("border-red-500");
  });

  test("does not display error message when errorMessage is empty", () => {
    render(<AddDialog {...defaultProps} errorMessage="" />);
    const errorParagraph = screen.queryByText("Duplicate name detected!"); // Example error text
    expect(errorParagraph).not.toBeInTheDocument();
    const input = screen.getByPlaceholderText(/Enter folder name/i);
    expect(input).not.toHaveAttribute("aria-invalid", "true");
    expect(input).not.toHaveAttribute("aria-describedby");
    expect(input).not.toHaveClass("border-red-500");
  });

  test("calls onCancel when Cancel button is clicked", () => {
    render(<AddDialog {...defaultProps} />);
    fireEvent.click(screen.getByRole("button", { name: /Cancel/i }));
    expect(mockOnCancel).toHaveBeenCalledTimes(1);
  });

  test("calls onAdd when Add button is clicked", () => {
    render(<AddDialog {...defaultProps} newItemLabel="Valid Name" />);
    fireEvent.click(screen.getByRole("button", { name: /Add/i }));
    expect(mockOnAdd).toHaveBeenCalledTimes(1);
  });

  test("calls onAdd when form is submitted", () => {
    render(<AddDialog {...defaultProps} newItemLabel="Valid Name" />);
    const form = screen.getByRole("button", { name: /Add/i }).closest("form");
    if (!form) throw new Error("Could not find form element");
    fireEvent.submit(form);
    expect(mockOnAdd).toHaveBeenCalledTimes(1);
  });
});


--- tests\components\ContextMenu.test.jsx ---
// tests/components/ContextMenu.test.jsx
import React from "react";
import { render, screen, fireEvent } from "@testing-library/react";
import "@testing-library/jest-dom";
import ContextMenu from "../../src/components/ContextMenu";

jest.mock("lucide-react", () => ({
  Scissors: () => <svg data-testid="icon-scissors" />,
  Copy: () => <svg data-testid="icon-copy" />,
  ClipboardPaste: () => <svg data-testid="icon-paste" />,
  Upload: () => <svg data-testid="icon-upload" />,
  Download: () => <svg data-testid="icon-download" />,
}));

describe("<ContextMenu />", () => {
  const mockHandlers = {
    onAddRootFolder: jest.fn(),
    onAddFolder: jest.fn(),
    onAddNote: jest.fn(),
    onAddTask: jest.fn(),
    onRename: jest.fn(),
    onDelete: jest.fn(),
    onCopy: jest.fn(),
    onCut: jest.fn(),
    onPaste: jest.fn(),
    onDuplicate: jest.fn(),
    onExportItem: jest.fn(),
    onImportItem: jest.fn(),
    onExportTree: jest.fn(),
    onImportTree: jest.fn(),
    onClose: jest.fn(),
  };
  const folderItem = { id: "f1", type: "folder", label: "My Folder" };
  const noteItem = { id: "n1", type: "note", label: "My Note" };
  const clipboardItemMock = {
    id: "clip1",
    type: "note",
    label: "Clipped Note",
  };
  const defaultProps = {
    visible: true,
    x: 100,
    y: 150,
    item: null,
    isEmptyArea: false,
    clipboardItem: null,
    ...mockHandlers,
  };

  beforeEach(() => jest.clearAllMocks());

  test("does not render when visible is false", () => {
    const { container } = render(
      <ContextMenu {...defaultProps} visible={false} />
    );
    expect(container.firstChild).toBeNull();
  });

  test("renders at correct position", () => {
    render(
      <ContextMenu {...defaultProps} item={noteItem} isEmptyArea={false} />
    );
    const menu = screen
      .getByRole("button", { name: /Rename/i })
      .closest('div[class*="fixed"]');
    expect(menu).toHaveStyle(`top: ${defaultProps.y}px`);
    expect(menu).toHaveStyle(`left: ${defaultProps.x}px`);
  });

  describe("When isEmptyArea is true", () => {
    test("renders correct empty area actions", () => {
      const { rerender } = render(
        <ContextMenu
          {...defaultProps}
          isEmptyArea={true}
          item={null}
          clipboardItem={null}
        />
      );
      expect(
        screen.getByRole("button", { name: /Add Root Folder/i })
      ).toBeInTheDocument();
      expect(
        screen.getByRole("button", { name: /Export Full Tree/i })
      ).toBeInTheDocument();
      expect(
        screen.getByRole("button", { name: /Import Full Tree/i })
      ).toBeInTheDocument();
      expect(
        screen.queryByRole("button", { name: /Paste/i })
      ).not.toBeInTheDocument();

      rerender(
        <ContextMenu
          {...defaultProps}
          isEmptyArea={true}
          item={null}
          clipboardItem={clipboardItemMock}
        />
      );
      expect(
        screen.getByRole("button", { name: /Paste/i })
      ).toBeInTheDocument();
    });
    test("calls correct handlers for empty area actions", () => {
      render(
        <ContextMenu
          {...defaultProps}
          isEmptyArea={true}
          item={null}
          clipboardItem={clipboardItemMock}
        />
      );
      fireEvent.click(screen.getByRole("button", { name: /Add Root Folder/i }));
      expect(mockHandlers.onAddRootFolder).toHaveBeenCalledTimes(1);
      fireEvent.click(screen.getByRole("button", { name: /Paste/i }));
      expect(mockHandlers.onPaste).toHaveBeenCalledTimes(1);
      fireEvent.click(
        screen.getByRole("button", { name: /Export Full Tree/i })
      );
      expect(mockHandlers.onExportTree).toHaveBeenCalledTimes(1);
      fireEvent.click(
        screen.getByRole("button", { name: /Import Full Tree/i })
      );
      expect(mockHandlers.onImportTree).toHaveBeenCalledTimes(1);
      expect(mockHandlers.onClose).toHaveBeenCalledTimes(4);
    });
  });

  describe("When item is a folder", () => {
    test("renders all folder actions", () => {
      const { rerender } = render(
        <ContextMenu
          {...defaultProps}
          isEmptyArea={false}
          item={folderItem}
          clipboardItem={null}
        />
      );
      expect(
        screen.getByRole("button", { name: /Add Folder Here/i })
      ).toBeInTheDocument();
      expect(
        screen.getByRole("button", { name: /Add Note Here/i })
      ).toBeInTheDocument();
      expect(
        screen.getByRole("button", { name: /Add Task Here/i })
      ).toBeInTheDocument();
      expect(
        screen.getByRole("button", { name: /Import under Item/i })
      ).toBeInTheDocument();
      expect(
        screen.queryByRole("button", { name: /Paste Here/i })
      ).not.toBeInTheDocument();
      rerender(
        <ContextMenu
          {...defaultProps}
          isEmptyArea={false}
          item={folderItem}
          clipboardItem={clipboardItemMock}
        />
      );
      expect(
        screen.getByRole("button", { name: /Paste Here/i })
      ).toBeInTheDocument();
    });
    test("calls correct handlers for folder actions", () => {
      render(
        <ContextMenu
          {...defaultProps}
          isEmptyArea={false}
          item={folderItem}
          clipboardItem={clipboardItemMock}
        />
      );
      fireEvent.click(screen.getByRole("button", { name: /Add Folder Here/i }));
      expect(mockHandlers.onAddFolder).toHaveBeenCalledTimes(1);
      fireEvent.click(screen.getByRole("button", { name: /Add Note Here/i }));
      expect(mockHandlers.onAddNote).toHaveBeenCalledTimes(1);
      fireEvent.click(screen.getByRole("button", { name: /Add Task Here/i }));
      expect(mockHandlers.onAddTask).toHaveBeenCalledTimes(1);
      fireEvent.click(screen.getByRole("button", { name: /Cut/i }));
      expect(mockHandlers.onCut).toHaveBeenCalledTimes(1);
      fireEvent.click(screen.getByRole("button", { name: /Copy/i }));
      expect(mockHandlers.onCopy).toHaveBeenCalledTimes(1);
      fireEvent.click(screen.getByRole("button", { name: /Duplicate/i }));
      expect(mockHandlers.onDuplicate).toHaveBeenCalledTimes(1);
      fireEvent.click(screen.getByRole("button", { name: /Paste Here/i }));
      expect(mockHandlers.onPaste).toHaveBeenCalledTimes(1);
      fireEvent.click(screen.getByRole("button", { name: /Export Item/i }));
      expect(mockHandlers.onExportItem).toHaveBeenCalledTimes(1);
      fireEvent.click(
        screen.getByRole("button", { name: /Import under Item/i })
      );
      expect(mockHandlers.onImportItem).toHaveBeenCalledTimes(1);
      fireEvent.click(screen.getByRole("button", { name: /Rename/i }));
      expect(mockHandlers.onRename).toHaveBeenCalledTimes(1);
      fireEvent.click(screen.getByRole("button", { name: /Delete/i }));
      expect(mockHandlers.onDelete).toHaveBeenCalledTimes(1);
      expect(mockHandlers.onClose).toHaveBeenCalledTimes(11);
    });
  });

  describe("When item is a note/task", () => {
    test("renders note/task actions (no add/paste/import)", () => {
      render(
        <ContextMenu
          {...defaultProps}
          isEmptyArea={false}
          item={noteItem}
          clipboardItem={clipboardItemMock}
        />
      );
      expect(
        screen.queryByRole("button", { name: /Add Folder Here/i })
      ).not.toBeInTheDocument();
      expect(
        screen.queryByRole("button", { name: /Paste Here/i })
      ).not.toBeInTheDocument();
      expect(
        screen.queryByRole("button", { name: /Import under Item/i })
      ).not.toBeInTheDocument();
      expect(screen.getByRole("button", { name: /Cut/i })).toBeInTheDocument();
    });
    test("calls correct handlers for note/task actions", () => {
      render(
        <ContextMenu {...defaultProps} isEmptyArea={false} item={noteItem} />
      );
      fireEvent.click(screen.getByRole("button", { name: /Cut/i }));
      expect(mockHandlers.onCut).toHaveBeenCalledTimes(1);
      fireEvent.click(screen.getByRole("button", { name: /Copy/i }));
      expect(mockHandlers.onCopy).toHaveBeenCalledTimes(1);
      fireEvent.click(screen.getByRole("button", { name: /Duplicate/i }));
      expect(mockHandlers.onDuplicate).toHaveBeenCalledTimes(1);
      fireEvent.click(screen.getByRole("button", { name: /Export Item/i }));
      expect(mockHandlers.onExportItem).toHaveBeenCalledTimes(1);
      fireEvent.click(screen.getByRole("button", { name: /Rename/i }));
      expect(mockHandlers.onRename).toHaveBeenCalledTimes(1);
      fireEvent.click(screen.getByRole("button", { name: /Delete/i }));
      expect(mockHandlers.onDelete).toHaveBeenCalledTimes(1);
      expect(mockHandlers.onClose).toHaveBeenCalledTimes(6);
    });
  });

  test("calls onClose when clicking outside", () => {
    render(
      <div>
        <ContextMenu {...defaultProps} item={noteItem} /> Outside{" "}
      </div>
    );
    fireEvent.mouseDown(screen.getByText("Outside"));
    expect(mockHandlers.onClose).toHaveBeenCalledTimes(1);
  });
  test("calls onClose when Escape key is pressed", () => {
    render(<ContextMenu {...defaultProps} item={noteItem} />);
    fireEvent.keyDown(document.body, { key: "Escape", code: "Escape" });
    expect(mockHandlers.onClose).toHaveBeenCalledTimes(1);
  });
});


--- tests\components\ExportDialog.test.jsx ---
// tests/components/ExportDialog.test.jsx
import React from 'react';
import { render, screen, fireEvent } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import '@testing-library/jest-dom';
import ExportDialog from '../../src/components/ExportDialog';

describe('<ExportDialog />', () => {
  const mockOnClose = jest.fn();
  const mockOnExport = jest.fn();

  const defaultProps = {
    isOpen: true,
    context: null, // Generic context, allows choosing target
    defaultFormat: 'json',
    onClose: mockOnClose,
    onExport: mockOnExport,
  };

  beforeEach(() => {
    mockOnClose.mockClear();
    mockOnExport.mockClear();
  });

  test('does not render when isOpen is false', () => {
    const { container } = render(<ExportDialog {...defaultProps} isOpen={false} />);
    expect(container.firstChild).toBeNull();
  });

  test('renders correctly with default props (generic context)', () => {
    render(<ExportDialog {...defaultProps} />);
    expect(screen.getByRole('heading', { name: /Export Options/i })).toBeInTheDocument();
    expect(screen.getByLabelText(/Selected Item/i)).toBeChecked(); // Default target
    expect(screen.getByLabelText(/JSON/i)).toBeChecked(); // Default format
    expect(screen.getByRole('button', { name: /Export as JSON/i })).toBeInTheDocument();
  });

  test('renders correctly for "item" context', () => {
    render(<ExportDialog {...defaultProps} context="item" />);
    expect(screen.getByRole('heading', { name: /Export Selected Item/i })).toBeInTheDocument();
    // Target radio buttons should not be shown
    expect(screen.queryByLabelText(/Selected Item/i)).not.toBeInTheDocument();
    expect(screen.queryByLabelText(/Entire Tree/i)).not.toBeInTheDocument();
    expect(screen.getByLabelText(/JSON/i)).toBeChecked();
  });

  test('renders correctly for "tree" context', () => {
    render(<ExportDialog {...defaultProps} context="tree" />);
    expect(screen.getByRole('heading', { name: /Export Full Tree/i })).toBeInTheDocument();
    expect(screen.queryByLabelText(/Selected Item/i)).not.toBeInTheDocument();
    expect(screen.queryByLabelText(/Entire Tree/i)).not.toBeInTheDocument();
    expect(screen.getByLabelText(/PDF/i)).not.toBeChecked(); // JSON is default
  });

  test('allows changing export target when context is generic', async () => {
    const user = userEvent.setup();
    render(<ExportDialog {...defaultProps} context={null} />); // Generic context
    const entireTreeRadio = screen.getByLabelText(/Entire Tree/i);
    await user.click(entireTreeRadio);
    expect(entireTreeRadio).toBeChecked();
  });

  test('allows changing export format', async () => {
    const user = userEvent.setup();
    render(<ExportDialog {...defaultProps} />);
    const pdfRadio = screen.getByLabelText(/PDF/i);
    await user.click(pdfRadio);
    expect(pdfRadio).toBeChecked();
    expect(screen.getByRole('button', { name: /Export as PDF/i })).toBeInTheDocument();
  });

  test('calls onExport with correct target and format', async () => {
    const user = userEvent.setup();
    render(<ExportDialog {...defaultProps} context={null} />); // Generic to allow target change
    
    // Change target and format
    await user.click(screen.getByLabelText(/Entire Tree/i));
    await user.click(screen.getByLabelText(/PDF/i));
    
    await user.click(screen.getByRole('button', { name: /Export as PDF/i }));
    expect(mockOnExport).toHaveBeenCalledWith('entire', 'pdf');
    expect(mockOnClose).toHaveBeenCalledTimes(1);
  });

  test('calls onExport with "selected" target if context is "item"', async () => {
    const user = userEvent.setup();
    render(<ExportDialog {...defaultProps} context="item" defaultFormat="pdf" />);
    await user.click(screen.getByRole('button', { name: /Export as PDF/i }));
    expect(mockOnExport).toHaveBeenCalledWith('selected', 'pdf');
    expect(mockOnClose).toHaveBeenCalledTimes(1);
  });

  test('calls onClose when Cancel button is clicked', async () => {
    const user = userEvent.setup();
    render(<ExportDialog {...defaultProps} />);
    await user.click(screen.getByRole('button', { name: /Cancel/i }));
    expect(mockOnClose).toHaveBeenCalledTimes(1);
  });

  test('uses defaultFormat prop correctly', () => {
    render(<ExportDialog {...defaultProps} defaultFormat="pdf" />);
    expect(screen.getByLabelText(/PDF/i)).toBeChecked();
    expect(screen.getByRole('button', {name: /Export as PDF/i})).toBeInTheDocument();
  });
});

--- tests\components\FolderContents.test.jsx ---
// tests/components/FolderContents.test.jsx
import React from "react";
import {
  render,
  screen,
  fireEvent,
  within,
  waitFor,
} from "@testing-library/react";
import userEvent from "@testing-library/user-event";
import "@testing-library/jest-dom";
import FolderContents from "../../src/components/FolderContents";

// Mock lucide-react MoreVertical icon
jest.mock("lucide-react", () => ({
  ...jest.requireActual("lucide-react"), // Import and retain default behavior
  MoreVertical: () => <svg data-testid="icon-more-vertical" />,
}));

describe("<FolderContents /> Component", () => {
  const mockOnSelect = jest.fn();
  const mockOnToggleExpand = jest.fn();
  const mockHandleDragStart = jest.fn();
  const mockHandleDragEnter = jest.fn();
  const mockHandleDragOver = jest.fn();
  const mockHandleDragLeave = jest.fn();
  const mockHandleDrop = jest.fn();
  const mockHandleDragEnd = jest.fn();
  const mockOnShowItemMenu = jest.fn(); // Mock for the new prop

  const emptyFolder = {
    id: "f0",
    type: "folder",
    label: "Empty Folder",
    children: [],
  };
  const folderWithChildren = {
    id: "f1",
    type: "folder",
    label: "Folder With Items",
    children: [
      { id: "f2", type: "folder", label: "Subfolder Alpha", children: [] },
      { id: "n1", type: "note", label: "Note Beta" },
      { id: "t1", type: "task", label: "Task Gamma", completed: false },
      { id: "t2", type: "task", label: "Task Delta", completed: true },
    ],
  };

  const defaultProps = {
    onSelect: mockOnSelect,
    onToggleExpand: mockOnToggleExpand,
    expandedItems: {}, // Default to no folders expanded
    handleDragStart: mockHandleDragStart,
    handleDragEnter: mockHandleDragEnter,
    handleDragOver: mockHandleDragOver,
    handleDragLeave: mockHandleDragLeave,
    handleDrop: mockHandleDrop,
    handleDragEnd: mockHandleDragEnd,
    draggedId: null,
    dragOverItemId: null,
    onShowItemMenu: mockOnShowItemMenu,
  };

  beforeEach(() => {
    jest.clearAllMocks();
  });

  test("renders empty message when folder has no children", () => {
    render(<FolderContents {...defaultProps} folder={emptyFolder} />);
    expect(screen.getByText("This folder is empty.")).toBeInTheDocument();
  });

  test("renders children items sorted correctly", () => {
    // sortItems in FolderContents sorts folders first, then by label
    render(
      <FolderContents
        {...defaultProps}
        folder={folderWithChildren}
        expandedItems={{ f2: false }}
      />
    );
    const listItems = screen.getAllByRole("listitem"); // Get all <li> elements
    expect(listItems.length).toBe(4);
    // Based on sortItems: Folder, Note, Task, Task (alphabetical within type)
    expect(
      within(listItems[0]).getByText("Subfolder Alpha")
    ).toBeInTheDocument();
    expect(within(listItems[1]).getByText("Note Beta")).toBeInTheDocument();
    expect(within(listItems[2]).getByText("Task Delta")).toBeInTheDocument(); // Delta before Gamma
    expect(within(listItems[3]).getByText("Task Gamma")).toBeInTheDocument();
  });

  test("calls onSelect when an item (not an interactive button within it) is clicked", async () => {
    const user = userEvent.setup();
    render(<FolderContents {...defaultProps} folder={folderWithChildren} />);
    // Target the list item itself or its main clickable area, not specific buttons within it yet
    const noteListItem = screen.getByText("Note Beta").closest("li");
    if (!noteListItem) throw new Error("Note Beta list item not found");
    await user.click(noteListItem);
    expect(mockOnSelect).toHaveBeenCalledWith("n1");
  });

  test("calls onToggleExpand when folder expand button is clicked", async () => {
    const user = userEvent.setup();
    render(
      <FolderContents
        {...defaultProps}
        folder={folderWithChildren}
        expandedItems={{ f2: false }}
      />
    );
    // Target the expand button specifically using its accessible name
    const expandButton = screen.getByRole("button", {
      name: /Expand Subfolder Alpha/i,
    });
    await user.click(expandButton);
    expect(mockOnToggleExpand).toHaveBeenCalledWith("f2");
  });

  test("calls onShowItemMenu when More options button is clicked", async () => {
    const user = userEvent.setup();
    render(<FolderContents {...defaultProps} folder={folderWithChildren} />);
    const noteItemLabel = screen.getByText("Note Beta");
    const noteItemLi = noteItemLabel.closest("li");
    if (!noteItemLi) throw new Error("List item for Note Beta not found");

    const moreButton = within(noteItemLi).getByRole("button", {
      name: /More options for Note Beta/i,
    });
    await user.click(moreButton);
    expect(mockOnShowItemMenu).toHaveBeenCalledTimes(1);
    expect(mockOnShowItemMenu).toHaveBeenCalledWith(
      folderWithChildren.children[1],
      expect.any(HTMLElement)
    ); // children[1] is Note Beta
  });

  // Drag and drop tests can be complex with react-testing-library.
  // Basic interaction checks:
  test("calls drag handlers when an item is dragged", () => {
    render(<FolderContents {...defaultProps} folder={folderWithChildren} />);
    const draggableItem = screen.getByText("Note Beta").closest("li");
    if (!draggableItem) throw new Error("Draggable item 'Note Beta' not found");

    fireEvent.dragStart(draggableItem);
    expect(mockHandleDragStart).toHaveBeenCalledWith(expect.any(Object), "n1");

    fireEvent.dragEnd(draggableItem);
    expect(mockHandleDragEnd).toHaveBeenCalledWith(expect.any(Object));
  });

  test("applies opacity when item is being dragged", () => {
    render(
      <FolderContents
        {...defaultProps}
        folder={folderWithChildren}
        draggedId="n1"
      />
    );
    const noteItemLi = screen.getByText("Note Beta").closest("li");
    expect(noteItemLi).toHaveClass("opacity-40");
  });

  test("shows folder icon correctly (open/closed)", () => {
    const { rerender } = render(
      <FolderContents
        {...defaultProps}
        folder={folderWithChildren}
        expandedItems={{ f2: false }}
      />
    );
    const subfolderItem = screen.getByText("Subfolder Alpha").closest("li");
    expect(within(subfolderItem).getByText("📁")).toBeInTheDocument(); // Closed folder icon

    rerender(
      <FolderContents
        {...defaultProps}
        folder={folderWithChildren}
        expandedItems={{ f2: true }}
      />
    );
    const openedSubfolderItem = screen
      .getByText("Subfolder Alpha")
      .closest("li");
    expect(within(openedSubfolderItem).getByText("📂")).toBeInTheDocument(); // Open folder icon
  });

  test("shows task completion status correctly", () => {
    render(<FolderContents {...defaultProps} folder={folderWithChildren} />);
    const taskDeltaItem = screen.getByText("Task Delta").closest("li"); // Completed
    expect(within(taskDeltaItem).getByText("✅")).toBeInTheDocument();
    expect(within(taskDeltaItem).getByText("Task Delta")).toHaveClass(
      "line-through"
    );

    const taskGammaItem = screen.getByText("Task Gamma").closest("li"); // Incomplete
    expect(within(taskGammaItem).getByText("⬜️")).toBeInTheDocument();
    expect(within(taskGammaItem).getByText("Task Gamma")).not.toHaveClass(
      "line-through"
    );
  });
});


--- tests\components\ImportDialog.test.jsx ---
// tests/components/ImportDialog.test.jsx
import React from 'react';
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import '@testing-library/jest-dom';
import ImportDialog from '../../src/components/ImportDialog';

describe('<ImportDialog />', () => {
  const mockOnClose = jest.fn();
  const mockOnImport = jest.fn();
  const selectedItemMock = { id: 'folder1', label: 'My Folder', type: 'folder' };

  const defaultProps = {
    isOpen: true,
    context: 'item', // Default to import under item
    selectedItem: selectedItemMock,
    onClose: mockOnClose,
    onImport: mockOnImport,
  };

  beforeEach(() => {
    mockOnClose.mockClear();
    mockOnImport.mockClear();
  });

  test('does not render when isOpen is false', () => {
    const { container } = render(<ImportDialog {...defaultProps} isOpen={false} />);
    expect(container.firstChild).toBeNull();
  });

  test('renders correctly for "import under item" context', () => {
    render(<ImportDialog {...defaultProps} />);
    expect(screen.getByRole('heading', { name: /Import Under "My Folder"/i })).toBeInTheDocument();
    expect(screen.getByLabelText(/Under Selected Item/i)).toBeChecked();
    expect(screen.getByLabelText(/Into empty tree or overwrite existing data/i)).not.toBeChecked();
    expect(screen.getByLabelText(/Select JSON File/i)).toBeInTheDocument();
    expect(screen.getByRole('button', { name: 'Import' })).toBeDisabled(); // No file selected
  });

  test('renders correctly for "tree" (full import) context', () => {
    render(<ImportDialog {...defaultProps} context="tree" selectedItem={null} />);
    expect(screen.getByRole('heading', { name: /Import Tree \(Overwrite Existing\)/i })).toBeInTheDocument();
    // Radio buttons might be hidden or "Replace Entire Tree" forced checked
    // Based on current ImportDialog, radio buttons are hidden if context="tree"
    expect(screen.queryByLabelText(/Under Selected Item/i)).not.toBeInTheDocument();
    expect(screen.queryByLabelText(/Into empty tree or overwrite existing data/i)).not.toBeInTheDocument();
    expect(screen.getByText(/This will replace your entire current tree/i)).toBeInTheDocument();
  });

  test('enables import button when a file is selected', async () => {
    const user = userEvent.setup();
    render(<ImportDialog {...defaultProps} />);
    const fileInput = screen.getByLabelText(/Select JSON File/i);
    const file = new File(['{"test":"data"}'], 'test.json', { type: 'application/json' });
    
    await user.upload(fileInput, file);
    expect(screen.getByText(/Selected: test.json/i)).toBeInTheDocument();
    expect(screen.getByRole('button', { name: 'Import' })).toBeEnabled();
  });

  test('calls onImport with file and target when Import button is clicked', async () => {
    const user = userEvent.setup();
    mockOnImport.mockResolvedValue({ success: true }); // Mock onImport to resolve
    render(<ImportDialog {...defaultProps} context="item" selectedItem={selectedItemMock} />);
    const fileInput = screen.getByLabelText(/Select JSON File/i);
    const file = new File(['{"id":"1","label":"Test"}'], 'import.json', { type: 'application/json' });
    await user.upload(fileInput, file);
    
    const importButton = screen.getByRole('button', { name: 'Import' });
    await user.click(importButton);

    await waitFor(() => {
      expect(mockOnImport).toHaveBeenCalledWith(file, 'selected'); // 'selected' because context is 'item'
    });
  });

  test('calls onImport with "entire" target if that option is selected', async () => {
    const user = userEvent.setup();
    mockOnImport.mockResolvedValue({ success: true });
     // Render without specific item context to allow radio button choice
    render(<ImportDialog isOpen={true} context="generic" selectedItem={null} onClose={mockOnClose} onImport={mockOnImport} />);
    
    const fileInput = screen.getByLabelText(/Select JSON File/i);
    const file = new File(['[{"id":"1"}]'], 'tree.json', { type: 'application/json' });
    await user.upload(fileInput, file);

    // Select "Replace Entire Tree"
    const entireTreeRadio = screen.getByLabelText(/Into empty tree or overwrite existing data/i);
    await user.click(entireTreeRadio);
    
    const importButton = screen.getByRole('button', { name: 'Import' });
    await user.click(importButton);

    await waitFor(() => {
      expect(mockOnImport).toHaveBeenCalledWith(file, 'entire');
    });
  });


  test('calls onClose when Cancel button is clicked', async () => {
    const user = userEvent.setup();
    render(<ImportDialog {...defaultProps} />);
    await user.click(screen.getByRole('button', { name: /Close/i })); // Changed from Cancel to Close
    expect(mockOnClose).toHaveBeenCalledTimes(1);
  });

  test('displays import message on success', async () => {
    const user = userEvent.setup();
    mockOnImport.mockResolvedValue({ success: true, message: "Test import successful" });
    render(<ImportDialog {...defaultProps} />);
    const fileInput = screen.getByLabelText(/Select JSON File/i);
    const file = new File(['{}'], 'test.json', { type: 'application/json' });
    await user.upload(fileInput, file);
    await user.click(screen.getByRole('button', { name: 'Import' }));

    await waitFor(() => {
      expect(screen.getByText("Test import successful")).toBeInTheDocument();
      expect(screen.getByText("Test import successful")).toHaveClass('bg-green-100');
    });
  });

  test('displays import message on failure', async () => {
    const user = userEvent.setup();
    mockOnImport.mockResolvedValue({ success: false, error: "Test import failed" });
    render(<ImportDialog {...defaultProps} />);
    const fileInput = screen.getByLabelText(/Select JSON File/i);
    const file = new File(['{}'], 'test.json', { type: 'application/json' });
    await user.upload(fileInput, file);
    await user.click(screen.getByRole('button', { name: 'Import' }));

    await waitFor(() => {
      expect(screen.getByText("Test import failed")).toBeInTheDocument();
      expect(screen.getByText("Test import failed")).toHaveClass('bg-red-100');
    });
  });
});

--- tests\components\Login.test.jsx ---
// tests/components/Login.test.jsx
import React from "react";
import { render, screen, fireEvent, waitFor } from "@testing-library/react";
import userEvent from "@testing-library/user-event";
import "@testing-library/jest-dom";
import Login from "../../src/components/Login";

const mockOnLoginSuccess = jest.fn();
const mockOnSwitchToRegister = jest.fn();

// Mock global.fetch
global.fetch = jest.fn();

// Mock VITE_API_BASE_URL
const originalEnv = { ...process.env };
beforeAll(() => {
  process.env.VITE_API_BASE_URL = "http://localhost:5001/api"; // Or your test API URL
});
afterAll(() => {
  process.env = originalEnv; // Restore original env
});

describe("<Login />", () => {
  beforeEach(() => {
    fetch.mockClear();
    mockOnLoginSuccess.mockClear();
    mockOnSwitchToRegister.mockClear();
  });

  test("renders login form correctly", () => {
    render(
      <Login
        onLoginSuccess={mockOnLoginSuccess}
        onSwitchToRegister={mockOnSwitchToRegister}
      />
    );
    expect(
      screen.getByRole("heading", { name: /Login to Notes & Tasks/i })
    ).toBeInTheDocument();
    expect(screen.getByLabelText(/Email Address/i)).toBeInTheDocument();
    expect(screen.getByLabelText(/Password/i)).toBeInTheDocument();
    expect(screen.getByRole("button", { name: /Login/i })).toBeInTheDocument();
    expect(
      screen.getByRole("button", { name: /Create one/i })
    ).toBeInTheDocument();
  });

  test("allows input for email and password", async () => {
    const user = userEvent.setup();
    render(
      <Login
        onLoginSuccess={mockOnLoginSuccess}
        onSwitchToRegister={mockOnSwitchToRegister}
      />
    );

    const emailInput = screen.getByLabelText(/Email Address/i);
    await user.type(emailInput, "test@example.com");
    expect(emailInput).toHaveValue("test@example.com");

    const passwordInput = screen.getByLabelText(/Password/i);
    await user.type(passwordInput, "password123");
    expect(passwordInput).toHaveValue("password123");
  });

  test("shows error message if fields are empty on submit", async () => {
    const user = userEvent.setup();
    render(
      <Login
        onLoginSuccess={mockOnLoginSuccess}
        onSwitchToRegister={mockOnSwitchToRegister}
      />
    );
    const loginButton = screen.getByRole("button", { name: /Login/i });
    await user.click(loginButton);
    expect(
      screen.getByText(/Please enter both email and password/i)
    ).toBeInTheDocument();
    expect(fetch).not.toHaveBeenCalled();
  });

  test("calls onLoginSuccess with user data on successful login", async () => {
    const user = userEvent.setup();
    const mockUserData = { id: "123", email: "test@example.com" };
    fetch.mockResolvedValueOnce({
      ok: true,
      json: async () => ({ token: "fake-jwt-token", user: mockUserData }),
    });

    render(
      <Login
        onLoginSuccess={mockOnLoginSuccess}
        onSwitchToRegister={mockOnSwitchToRegister}
      />
    );
    await user.type(
      screen.getByLabelText(/Email Address/i),
      "test@example.com"
    );
    await user.type(screen.getByLabelText(/Password/i), "password123");
    await user.click(screen.getByRole("button", { name: /Login/i }));

    await waitFor(() => {
      expect(fetch).toHaveBeenCalledWith(
        "http://localhost:5001/api/auth/login",
        expect.any(Object)
      );
      expect(mockOnLoginSuccess).toHaveBeenCalledWith(mockUserData);
    });
    expect(localStorage.getItem("userToken")).toBe("fake-jwt-token");
  });

  test("shows error message on failed login (invalid credentials)", async () => {
    const user = userEvent.setup();
    fetch.mockResolvedValueOnce({
      ok: false,
      status: 401,
      json: async () => ({ error: "Invalid credentials" }),
    });

    render(
      <Login
        onLoginSuccess={mockOnLoginSuccess}
        onSwitchToRegister={mockOnSwitchToRegister}
      />
    );
    await user.type(
      screen.getByLabelText(/Email Address/i),
      "test@example.com"
    );
    await user.type(screen.getByLabelText(/Password/i), "wrongpassword");
    await user.click(screen.getByRole("button", { name: /Login/i }));

    await waitFor(() => {
      expect(screen.getByText(/Invalid credentials/i)).toBeInTheDocument();
    });
    expect(mockOnLoginSuccess).not.toHaveBeenCalled();
  });

  test("shows error message on network error", async () => {
    const user = userEvent.setup();
    fetch.mockRejectedValueOnce(new Error("Network error"));

    render(
      <Login
        onLoginSuccess={mockOnLoginSuccess}
        onSwitchToRegister={mockOnSwitchToRegister}
      />
    );
    await user.type(
      screen.getByLabelText(/Email Address/i),
      "test@example.com"
    );
    await user.type(screen.getByLabelText(/Password/i), "password123");
    await user.click(screen.getByRole("button", { name: /Login/i }));

    await waitFor(() => {
      expect(
        screen.getByText(/Network error or server issue/i)
      ).toBeInTheDocument();
    });
  });

  test('calls onSwitchToRegister when "Create one" button is clicked', async () => {
    const user = userEvent.setup();
    render(
      <Login
        onLoginSuccess={mockOnLoginSuccess}
        onSwitchToRegister={mockOnSwitchToRegister}
      />
    );
    const createAccountButton = screen.getByRole("button", {
      name: /Create one/i,
    });
    await user.click(createAccountButton);
    expect(mockOnSwitchToRegister).toHaveBeenCalledTimes(1);
  });
});


--- tests\components\Register.test.jsx ---
// tests/components/Register.test.jsx
import React from "react";
import { render, screen, fireEvent, waitFor } from "@testing-library/react";
import userEvent from "@testing-library/user-event";
import "@testing-library/jest-dom";
import Register from "../../src/components/Register";

const mockOnRegisterSuccess = jest.fn();
const mockOnSwitchToLogin = jest.fn();

// Mock global.fetch
global.fetch = jest.fn();

// Mock VITE_API_BASE_URL
const originalEnv = { ...process.env };
beforeAll(() => {
  process.env.VITE_API_BASE_URL = "http://localhost:5001/api";
});
afterAll(() => {
  process.env = originalEnv;
});

describe("<Register />", () => {
  beforeEach(() => {
    fetch.mockClear();
    mockOnRegisterSuccess.mockClear();
    mockOnSwitchToLogin.mockClear();
  });

  test("renders registration form correctly", () => {
    render(
      <Register
        onRegisterSuccess={mockOnRegisterSuccess}
        onSwitchToLogin={mockOnSwitchToLogin}
      />
    );
    expect(
      screen.getByRole("heading", { name: /Create Account/i })
    ).toBeInTheDocument();
    expect(screen.getByLabelText(/Email Address/i)).toBeInTheDocument();
    expect(
      screen.getByLabelText(/Password \(min. 8 characters\)/i)
    ).toBeInTheDocument();
    expect(screen.getByLabelText(/Confirm Password/i)).toBeInTheDocument();
    expect(
      screen.getByRole("button", { name: /Create Account/i })
    ).toBeInTheDocument();
    expect(screen.getByRole("button", { name: /Log In/i })).toBeInTheDocument();
  });

  test("shows error if fields are empty on submit", async () => {
    const user = userEvent.setup();
    render(
      <Register
        onRegisterSuccess={mockOnRegisterSuccess}
        onSwitchToLogin={mockOnSwitchToLogin}
      />
    );
    await user.click(screen.getByRole("button", { name: /Create Account/i }));
    expect(screen.getByText(/Please fill in all fields/i)).toBeInTheDocument();
  });

  test("shows error if passwords do not match", async () => {
    const user = userEvent.setup();
    render(
      <Register
        onRegisterSuccess={mockOnRegisterSuccess}
        onSwitchToLogin={mockOnSwitchToLogin}
      />
    );
    await user.type(
      screen.getByLabelText(/Email Address/i),
      "test@example.com"
    );
    await user.type(screen.getByLabelText(/Password/i), "password123");
    await user.type(screen.getByLabelText(/Confirm Password/i), "password456");
    await user.click(screen.getByRole("button", { name: /Create Account/i }));
    expect(screen.getByText(/Passwords do not match/i)).toBeInTheDocument();
  });

  test("shows error if password is too short", async () => {
    const user = userEvent.setup();
    render(
      <Register
        onRegisterSuccess={mockOnRegisterSuccess}
        onSwitchToLogin={mockOnSwitchToLogin}
      />
    );
    await user.type(
      screen.getByLabelText(/Email Address/i),
      "test@example.com"
    );
    await user.type(screen.getByLabelText(/Password/i), "pass");
    await user.type(screen.getByLabelText(/Confirm Password/i), "pass");
    await user.click(screen.getByRole("button", { name: /Create Account/i }));
    expect(
      screen.getByText(/Password must be at least 8 characters long/i)
    ).toBeInTheDocument();
  });

  test("calls onRegisterSuccess on successful registration", async () => {
    const user = userEvent.setup();
    const mockServerResponse = {
      user: { id: "newUser123", email: "test@example.com" },
      token: "new-fake-token",
    }; // Assuming register might also return token
    fetch.mockResolvedValueOnce({
      ok: true,
      json: async () => mockServerResponse,
    });
    window.alert = jest.fn(); // Mock alert

    render(
      <Register
        onRegisterSuccess={mockOnRegisterSuccess}
        onSwitchToLogin={mockOnSwitchToLogin}
      />
    );
    await user.type(
      screen.getByLabelText(/Email Address/i),
      "test@example.com"
    );
    await user.type(screen.getByLabelText(/Password/i), "password123");
    await user.type(screen.getByLabelText(/Confirm Password/i), "password123");
    await user.click(screen.getByRole("button", { name: /Create Account/i }));

    await waitFor(() => {
      expect(fetch).toHaveBeenCalledWith(
        "http://localhost:5001/api/auth/register",
        expect.any(Object)
      );
      expect(mockOnRegisterSuccess).toHaveBeenCalledTimes(1);
      expect(window.alert).toHaveBeenCalledWith(
        "Registration successful! Please log in."
      );
    });
  });

  test("shows server error message on failed registration", async () => {
    const user = userEvent.setup();
    fetch.mockResolvedValueOnce({
      ok: false,
      json: async () => ({ error: "Email already exists" }),
    });
    render(
      <Register
        onRegisterSuccess={mockOnRegisterSuccess}
        onSwitchToLogin={mockOnSwitchToLogin}
      />
    );
    await user.type(
      screen.getByLabelText(/Email Address/i),
      "test@example.com"
    );
    await user.type(screen.getByLabelText(/Password/i), "password123");
    await user.type(screen.getByLabelText(/Confirm Password/i), "password123");
    await user.click(screen.getByRole("button", { name: /Create Account/i }));

    await waitFor(() => {
      expect(screen.getByText(/Email already exists/i)).toBeInTheDocument();
    });
  });

  test('calls onSwitchToLogin when "Log In" button is clicked', async () => {
    const user = userEvent.setup();
    render(
      <Register
        onRegisterSuccess={mockOnRegisterSuccess}
        onSwitchToLogin={mockOnSwitchToLogin}
      />
    );
    await user.click(screen.getByRole("button", { name: /Log In/i }));
    expect(mockOnSwitchToLogin).toHaveBeenCalledTimes(1);
  });
});


--- tests\components\RenameDialog.test.jsx ---
// tests/components/RenameDialog.test.jsx
import React from "react";
import { render, screen, fireEvent } from "@testing-library/react";
import "@testing-library/jest-dom";
import RenameDialog from "../../src/components/RenameDialog";

describe("<RenameDialog />", () => {
  const mockOnNameChange = jest.fn();
  const mockOnRename = jest.fn();
  const mockOnCancel = jest.fn();

  const defaultProps = {
    isOpen: true,
    item: { id: "1", label: "Old Label" },
    newName: "Old Label",
    onNameChange: mockOnNameChange,
    onRename: mockOnRename,
    onCancel: mockOnCancel,
  };

  beforeEach(() => {
    mockOnNameChange.mockClear();
    mockOnRename.mockClear();
    mockOnCancel.mockClear();
  });

  test("does not render when isOpen is false", () => {
    const { container } = render(
      <RenameDialog {...defaultProps} isOpen={false} />
    );
    expect(container.firstChild).toBeNull();
  });

  test("renders correct title with item label", () => {
    render(<RenameDialog {...defaultProps} />);
    expect(
      screen.getByRole("heading", { name: /Rename “Old Label”/i })
    ).toBeInTheDocument();
  });

  test("renders input with current name, calls onNameChange, and focuses input", () => {
    render(<RenameDialog {...defaultProps} />);
    const input = screen.getByDisplayValue("Old Label");
    expect(input).toBeInTheDocument();
    expect(input).toHaveFocus(); // autoFocus should work

    fireEvent.change(input, { target: { value: "New Label Value" } });
    expect(mockOnNameChange).toHaveBeenCalledTimes(1);
    // The event object itself is passed, so checking e.target.value is fine if needed by the handler
    // expect(mockOnNameChange).toHaveBeenCalledWith(expect.objectContaining({ target: { value: 'New Label Value' } }));
  });

  test("calls onCancel when Cancel button is clicked", () => {
    render(<RenameDialog {...defaultProps} />);
    fireEvent.click(screen.getByRole("button", { name: /Cancel/i }));
    expect(mockOnCancel).toHaveBeenCalledTimes(1);
  });

  test("calls onRename when Rename button is clicked", () => {
    render(<RenameDialog {...defaultProps} />);
    fireEvent.click(screen.getByRole("button", { name: /Rename/i }));
    expect(mockOnRename).toHaveBeenCalledTimes(1);
  });

  test("calls onRename when form is submitted", () => {
    render(<RenameDialog {...defaultProps} />);
    const form = screen
      .getByRole("button", { name: /Rename/i })
      .closest("form");
    if (!form) throw new Error("Form not found");
    fireEvent.submit(form);
    expect(mockOnRename).toHaveBeenCalledTimes(1);
  });
});


--- tests\components\SettingsDialog.test.jsx ---
// tests/components/SettingsDialog.test.jsx
import React from "react";
import { render, screen } from "@testing-library/react"; // fireEvent removed if not directly used
import userEvent from "@testing-library/user-event";
import "@testing-library/jest-dom";
import SettingsDialog from "../../src/components/SettingsDialog";
import {
  SettingsContext,
  defaultSettings,
} from "../../src/contexts/SettingsContext";

const mockUpdateSetting = jest.fn();
const mockResetSettings = jest.fn();
const mockResetApplicationData = jest.fn();

const customRender = (ui, { providerProps, ...renderOptions }) => {
  return render(
    <SettingsContext.Provider value={providerProps}>
      {ui}
    </SettingsContext.Provider>,
    renderOptions
  );
};

describe("<SettingsDialog />", () => {
  let providerProps;
  const originalConfirm = window.confirm;

  beforeEach(() => {
    mockUpdateSetting.mockClear();
    mockResetSettings.mockClear();
    mockResetApplicationData.mockClear();
    providerProps = {
      settings: { ...defaultSettings },
      updateSetting: mockUpdateSetting,
      resetSettings: mockResetSettings,
      resetApplicationData: mockResetApplicationData,
    };
    window.confirm = jest.fn(() => true); // Mock window.confirm
  });

  afterEach(() => {
    window.confirm = originalConfirm; // Restore window.confirm
  });

  test("does not render when isOpen is false", () => {
    const { container } = customRender(
      <SettingsDialog isOpen={false} onClose={jest.fn()} />,
      { providerProps }
    );
    expect(container.firstChild).toBeNull();
  });

  test("renders correctly when isOpen is true", () => {
    customRender(<SettingsDialog isOpen={true} onClose={jest.fn()} />, {
      providerProps,
    });
    expect(screen.getByTestId("settings-dialog-overlay")).toBeInTheDocument();
    expect(screen.getByTestId("settings-dialog-content")).toBeInTheDocument();
    expect(
      screen.getByRole("heading", { name: /Settings/i })
    ).toBeInTheDocument();
    // ... (other getByTestId checks for rows as in your original)
    expect(screen.getByTestId("setting-row-theme")).toBeInTheDocument();
    expect(
      screen.getByTestId("setting-row-autoExpandNewFolders")
    ).toBeInTheDocument();
  });

  test("calls onClose when header Close button is clicked", async () => {
    const mockOnClose = jest.fn();
    customRender(<SettingsDialog isOpen={true} onClose={mockOnClose} />, {
      providerProps,
    });
    await userEvent.click(screen.getByTestId("settings-close-button-header"));
    expect(mockOnClose).toHaveBeenCalledTimes(1);
  });

  test("calls onClose when footer Close button is clicked", async () => {
    const mockOnClose = jest.fn();
    customRender(<SettingsDialog isOpen={true} onClose={mockOnClose} />, {
      providerProps,
    });
    await userEvent.click(screen.getByTestId("settings-close-button-footer"));
    expect(mockOnClose).toHaveBeenCalledTimes(1);
  });

  test("updates theme setting when selection changes", async () => {
    customRender(<SettingsDialog isOpen={true} onClose={jest.fn()} />, {
      providerProps,
    });
    const themeSelect = screen.getByTestId("setting-theme-select");
    await userEvent.selectOptions(themeSelect, "dark");
    expect(mockUpdateSetting).toHaveBeenCalledWith("theme", "dark");
  });

  test("updates autoExpand setting when checkbox is clicked", async () => {
    customRender(<SettingsDialog isOpen={true} onClose={jest.fn()} />, {
      providerProps,
    });
    const checkbox = screen.getByTestId("setting-autoexpand-checkbox");
    expect(checkbox).toBeChecked(); // Default is true
    await userEvent.click(checkbox);
    expect(mockUpdateSetting).toHaveBeenCalledWith(
      "autoExpandNewFolders",
      false
    );
  });

  // ... (other specific setting change tests like fontFamily, fontSize, exportFormat as in your original)

  test("filters settings based on search term in label", async () => {
    customRender(<SettingsDialog isOpen={true} onClose={jest.fn()} />, {
      providerProps,
    });
    const searchInput = screen.getByTestId("settings-search-input");
    await userEvent.type(searchInput, "Theme");
    expect(screen.getByTestId("setting-row-theme")).toBeInTheDocument();
    expect(
      screen.queryByTestId("setting-row-autoExpandNewFolders")
    ).not.toBeInTheDocument();
  });

  test('displays "No settings found" message when search yields no results', async () => {
    customRender(<SettingsDialog isOpen={true} onClose={jest.fn()} />, {
      providerProps,
    });
    const searchInput = screen.getByTestId("settings-search-input");
    await userEvent.type(searchInput, "xyznonexistentxyz");
    expect(screen.getByTestId("settings-no-results")).toBeInTheDocument();
  });

  test("calls resetSettings when Reset Settings button is clicked and confirmed", async () => {
    customRender(<SettingsDialog isOpen={true} onClose={jest.fn()} />, {
      providerProps,
    });
    await userEvent.click(screen.getByTestId("setting-resetsettings-button"));
    expect(window.confirm).toHaveBeenCalledWith(
      expect.stringContaining("reset all settings")
    );
    expect(mockResetSettings).toHaveBeenCalledTimes(1);
  });

  test("calls resetApplicationData when Reset All Data button is clicked and confirmed", async () => {
    customRender(<SettingsDialog isOpen={true} onClose={jest.fn()} />, {
      providerProps,
    });
    await userEvent.click(screen.getByTestId("setting-resetdata-button"));
    expect(window.confirm).toHaveBeenCalledWith(
      expect.stringContaining("WARNING: This will permanently delete")
    );
    expect(mockResetApplicationData).toHaveBeenCalledTimes(1);
  });

  test("does NOT call resetSettings if confirm is cancelled", async () => {
    window.confirm.mockImplementationOnce(() => false); // Override for this test
    customRender(<SettingsDialog isOpen={true} onClose={jest.fn()} />, {
      providerProps,
    });
    await userEvent.click(screen.getByTestId("setting-resetsettings-button"));
    expect(window.confirm).toHaveBeenCalled();
    expect(mockResetSettings).not.toHaveBeenCalled();
  });
});


--- tests\components\TaskItem.test.jsx ---
// tests/components/TaskItem.test.jsx
import React from "react";
import { render, screen, fireEvent } from "@testing-library/react";
import "@testing-library/jest-dom";
import TaskItem from "../../src/components/TaskItem";

describe("<TaskItem /> Component", () => {
  const mockToggle = jest.fn();

  beforeEach(() => {
    mockToggle.mockClear();
  });

  test("returns null if no task prop is provided", () => {
    const { container } = render(<TaskItem onToggle={mockToggle} />);
    expect(container.firstChild).toBeNull();
  });

  test("renders task label and unchecked checkbox for incomplete task", () => {
    const task = {
      id: "t1",
      type: "task",
      label: "Test Task Incomplete",
      completed: false,
    };
    render(<TaskItem task={task} onToggle={mockToggle} />);
    const checkbox = screen.getByRole("checkbox");
    const label = screen.getByText(task.label);
    expect(checkbox).not.toBeChecked();
    expect(label).not.toHaveClass("line-through");
  });

  test("renders task label and checked checkbox for completed task", () => {
    const task = {
      id: "t2",
      type: "task",
      label: "Test Task Complete",
      completed: true,
    };
    render(<TaskItem task={task} onToggle={mockToggle} />);
    const checkbox = screen.getByRole("checkbox");
    const label = screen.getByText(task.label);
    expect(checkbox).toBeChecked();
    expect(label).toHaveClass("line-through");
  });

  test("calls onToggle with true when incomplete task checkbox is clicked", () => {
    const task = {
      id: "t1",
      type: "task",
      label: "Test Task",
      completed: false,
    };
    render(<TaskItem task={task} onToggle={mockToggle} />);
    fireEvent.click(screen.getByRole("checkbox"));
    expect(mockToggle).toHaveBeenCalledWith(true);
  });

  test("calls onToggle with false when completed task checkbox is clicked", () => {
    const task = {
      id: "t2",
      type: "task",
      label: "Test Task",
      completed: true,
    };
    render(<TaskItem task={task} onToggle={mockToggle} />);
    fireEvent.click(screen.getByRole("checkbox"));
    expect(mockToggle).toHaveBeenCalledWith(false);
  });

  test("calls onToggle when label is clicked", () => {
    const task = {
      id: "t1",
      type: "task",
      label: "Clickable Label",
      completed: false,
    };
    render(<TaskItem task={task} onToggle={mockToggle} />);
    fireEvent.click(screen.getByText(task.label));
    expect(mockToggle).toHaveBeenCalledWith(true);
  });
});


--- tests\components\Tree.test.jsx ---
// tests/components/Tree.test.jsx
import React from "react";
import { render, screen, fireEvent } from "@testing-library/react";
import userEvent from "@testing-library/user-event";
import "@testing-library/jest-dom";
import Tree from "../../src/components/Tree";

// Mock lucide-react MoreVertical icon
jest.mock("lucide-react", () => ({
  ...jest.requireActual("lucide-react"), // Import and retain default behavior
  MoreVertical: () => <svg data-testid="icon-more-vertical" />,
}));

const mockHandlers = {
  onSelect: jest.fn(),
  onToggleExpand: jest.fn(),
  onToggleTask: jest.fn(),
  onDragStart: jest.fn(),
  onDrop: jest.fn(),
  onNativeContextMenu: jest.fn(), // Updated prop name
  onShowItemMenu: jest.fn(), // New prop for button menu
  onRename: jest.fn(), // This is for initiating rename (e.g. F2 or dblclick)
  onAttemptRename: jest.fn(), // For when inline input blurs or Enter pressed
  cancelInlineRename: jest.fn(),
  setInlineRenameValue: jest.fn(),
  onDragEnd: jest.fn(),
  setUiError: jest.fn(),
};

const sampleItems = [
  {
    id: "f1",
    type: "folder",
    label: "Folder 1",
    children: [
      { id: "f1-n1", type: "note", label: "Note 1.1" },
      { id: "f1-t1", type: "task", label: "Task 1.1", completed: true },
    ],
  },
  { id: "f2", type: "folder", label: "Folder 2", children: [] },
  { id: "n1", type: "note", label: "Note Alpha" }, // Changed for sort testing
  { id: "t1", type: "task", label: "Task Beta", completed: false },
];

describe("<Tree /> Component", () => {
  let user;

  beforeEach(() => {
    user = userEvent.setup();
    Object.values(mockHandlers).forEach((mock) => mock.mockClear());
  });

  const defaultProps = {
    items: [],
    selectedItemId: null,
    inlineRenameId: null,
    inlineRenameValue: "",
    expandedFolders: {},
    draggedId: null,
    uiError: "",
    ...mockHandlers,
  };

  test("renders navigation role", () => {
    render(<Tree {...defaultProps} />);
    expect(
      screen.getByRole("navigation", { name: "Notes and Tasks Tree" })
    ).toBeInTheDocument();
  });

  test("renders and sorts top-level items correctly", () => {
    render(<Tree {...defaultProps} items={sampleItems} />);
    // Items are sorted: Folder 1, Folder 2, Note Alpha, Task Beta
    const renderedItems = screen.getAllByRole("listitem");
    expect(renderedItems[0]).toHaveTextContent("Folder 1");
    expect(renderedItems[1]).toHaveTextContent("Folder 2");
    expect(renderedItems[2]).toHaveTextContent("Note Alpha");
    expect(renderedItems[3]).toHaveTextContent("Task Beta");
  });

  test("calls onSelect when an item main div is clicked", async () => {
    render(<Tree {...defaultProps} items={sampleItems} />);
    // Find the div that handles selection click (not buttons within the item)
    const noteItemDiv = screen
      .getByText("Note Alpha")
      .closest('div[role="button"]'); // The div that has the onClick for selection
    if (!noteItemDiv)
      throw new Error("Clickable div for 'Note Alpha' not found");
    await user.click(noteItemDiv);
    expect(mockHandlers.onSelect).toHaveBeenCalledWith("n1");
  });

  test("calls onToggleExpand when folder expand button is clicked", async () => {
    render(<Tree {...defaultProps} items={sampleItems} expandedFolders={{}} />);
    const folder1Item = screen.getByText("Folder 1").closest("li");
    const expandButton = within(folder1Item).getByRole("button", {
      name: /Expand Folder 1/i,
    });
    await user.click(expandButton);
    expect(mockHandlers.onToggleExpand).toHaveBeenCalledWith("f1");
  });

  test("calls onToggleTask when task checkbox area is clicked", async () => {
    render(<Tree {...defaultProps} items={sampleItems} />);
    const taskItem = screen.getByText("Task Beta").closest("li");
    // The checkbox itself is a button in the implementation
    const checkboxButton = within(taskItem).getByRole("checkbox", {
      name: /Mark task Task Beta as complete/i,
    });
    await user.click(checkboxButton);
    expect(mockHandlers.onToggleTask).toHaveBeenCalledWith("t1", true); // true because initial was false
  });

  test("calls onShowItemMenu when more options button is clicked", async () => {
    render(<Tree {...defaultProps} items={sampleItems} />);
    const noteItem = screen.getByText("Note Alpha").closest("li");
    const moreButton = within(noteItem).getByRole("button", {
      name: /More options for Note Alpha/i,
    });
    await user.click(moreButton);
    expect(mockHandlers.onShowItemMenu).toHaveBeenCalledWith(
      expect.objectContaining({ id: "n1", label: "Note Alpha" }), // The item object
      expect.any(HTMLElement) // The button element
    );
  });

  test("calls onNativeContextMenu when tree area is right-clicked (empty area)", async () => {
    render(<Tree {...defaultProps} items={sampleItems} />);
    const treeNav = screen.getByRole("navigation", {
      name: "Notes and Tasks Tree",
    });
    fireEvent.contextMenu(treeNav);
    expect(mockHandlers.onSelect).toHaveBeenCalledWith(null); // Selects null for empty area
    expect(mockHandlers.onNativeContextMenu).toHaveBeenCalledWith(
      expect.any(Object),
      null
    );
  });

  test("calls onNativeContextMenu when an item is right-clicked", async () => {
    render(<Tree {...defaultProps} items={sampleItems} />);
    const noteItemLi = screen.getByText("Note Alpha").closest("li");
    if (!noteItemLi) throw new Error("Note Alpha list item not found");
    fireEvent.contextMenu(noteItemLi);
    expect(mockHandlers.onSelect).toHaveBeenCalledWith("n1"); // Selects the item first
    expect(mockHandlers.onNativeContextMenu).toHaveBeenCalledWith(
      expect.any(Object), // The event
      expect.objectContaining({ id: "n1" }) // The item
    );
  });

  test("renders inline rename input when inlineRenameId matches an item", () => {
    render(
      <Tree
        {...defaultProps}
        items={sampleItems}
        inlineRenameId="n1"
        inlineRenameValue="Renaming Note"
      />
    );
    const input = screen.getByDisplayValue("Renaming Note");
    expect(input).toBeInTheDocument();
    expect(input.tagName).toBe("INPUT");
    // The original label "Note Alpha" should not be visible for this item
    expect(
      screen.queryByText("Note Alpha", { selector: "span" })
    ).not.toBeInTheDocument();
  });

  test("displays uiError message when inline renaming and error exists", () => {
    const errorMessage = "Name conflict!";
    render(
      <Tree
        {...defaultProps}
        items={sampleItems}
        inlineRenameId="n1"
        uiError={errorMessage}
      />
    );
    expect(screen.getByText(errorMessage)).toBeInTheDocument();
    // Check ARIA attributes on the input
    const input = screen.getByRole("textbox"); // Assuming rename input becomes a textbox
    expect(input).toHaveAttribute("aria-invalid", "true");
    expect(input).toHaveAttribute("aria-describedby", "n1-rename-error");
  });
});


--- tests\hooks\useTree.test.js ---
// tests/hooks/useTree.test.js
import { renderHook, act } from '@testing-library/react';
import { useTree } from '../../src/hooks/useTree';
import { LOCAL_STORAGE_KEY } from '../../src/utils/constants';

// Mocking fetch
global.fetch = jest.fn();

// Mock unicode-bidirectional
jest.mock('unicode-bidirectional', () => ({
  __esModule: true, // This is important for modules with default exports when mocking
  embeddingLevels: jest.fn(() => []), // Mock implementation
  reorder: jest.fn(text => text),     // Mock implementation
}));

// Mock SettingsContext
jest.mock('../../src/contexts/SettingsContext', () => ({
  useSettings: () => ({
    settings: {
      theme: 'system',
      defaultSortOrder: 'foldersFirstAlpha',
      autoExpandNewFolders: true,
      editorFontFamily: 'Arial',
      editorFontSize: '3',
      defaultExportFormat: 'json',
    },
    // Mock functions if your hook uses them directly, otherwise not strictly needed for all tests
    updateSetting: jest.fn(),
    resetSettings: jest.fn(),
    resetApplicationData: jest.fn(),
  }),
  // Exporting defaultSettings isn't strictly necessary for the mock if useSettings provides it
  defaultSettings: { /* your default settings object */ },
}));

// LocalStorage mock
const localStorageMock = (() => {
  let store = {};
  return {
    getItem: jest.fn(key => store[key] || null),
    setItem: jest.fn((key, value) => { store[key] = value.toString(); }),
    removeItem: jest.fn(key => { delete store[key]; }),
    clear: jest.fn(() => { store = {}; }),
    hasOwnProperty: jest.fn(key => store.hasOwnProperty(key)), // Added for completeness
    length: Object.keys(store).length, // Added for completeness
    key: jest.fn(index => Object.keys(store)[index] || null) // Added for completeness
  };
})();
Object.defineProperty(window, 'localStorage', { value: localStorageMock });


describe('useTree Hook', () => {
  beforeEach(() => {
    localStorageMock.clear();
    jest.clearAllMocks(); // Clears all mocks including fetch
    // Provide a default successful fetch response for initial load
    fetch.mockResolvedValueOnce({
      ok: true,
      json: async () => ({ notesTree: [] }), // Default to empty tree
    });
  });

  test('initializes with an attempt to fetch tree if token exists', async () => {
    localStorageMock.setItem('userToken', 'fake-token'); // Simulate logged-in user
    const { result } = renderHook(() => useTree());

    // Wait for async operations in useEffect to complete if necessary
    // For this initial test, we check immediate state before async fetch might complete in test env
    expect(result.current.tree).toEqual([]); // Initial state before fetch completes
    expect(result.current.expandedFolders).toEqual({});

    // Check that fetch was called (due to useEffect in useTree)
    // await waitFor(() => expect(fetch).toHaveBeenCalledTimes(1));
    // The above waitFor might be tricky depending on how useEffect and async calls are handled in test renderer
    // For now, we know fetch should be called if token exists
  });

  test('initializes with empty tree if localStorage is empty and no token', () => {
    localStorageMock.removeItem('userToken'); // Ensure no token
    fetch.mockResolvedValueOnce({ // Mock fetch in case it's called even without token (though it shouldn't)
      ok: true,
      json: async () => ({ notesTree: [] }),
    });
    const { result } = renderHook(() => useTree());
    expect(result.current.tree).toEqual([]);
    expect(result.current.expandedFolders).toEqual({});
    expect(localStorageMock.getItem).toHaveBeenCalledWith(LOCAL_STORAGE_KEY);
    expect(localStorageMock.getItem).toHaveBeenCalledWith(`${LOCAL_STORAGE_KEY}_expanded`);
  });


  test('loads tree from localStorage if present (and no token initially for fetch)', () => {
    const storedTree = [{ id: 'f1', type: 'folder', label: 'Folder 1', children: [] }];
    localStorageMock.setItem(LOCAL_STORAGE_KEY, JSON.stringify(storedTree));
    localStorageMock.removeItem('userToken'); // Ensure no token for this specific test case focus

    fetch.mockResolvedValueOnce({ // Mock fetch if it's still called
      ok: true,
      json: async () => ({ notesTree: [] }), // Return empty from fetch to ensure localStorage is preferred
    });

    const { result } = renderHook(() => useTree());

    // If fetch is prioritized over localStorage load, this might need adjustment
    // The current useTree loads from localStorage, then useEffect fetches if token.
    expect(result.current.tree).toEqual(storedTree);
  });

  // More comprehensive tests for addItem, deleteItem, etc., would require:
  // - Mocking `Workspace` for each specific API call (POST, PATCH, DELETE).
  // - Using `act()` from `@testing-library/react` to wrap state updates.
  // - Verifying that `setTreeWithUndo` is called with the expected new tree state.
  // These become more like integration tests for the hook.

  test.skip('addItem successfully updates the tree after API call', async () => {
    // Example of a more involved test (SKIPPED for brevity, needs full setup)
    const initialItems = [];
    localStorageMock.setItem(LOCAL_STORAGE_KEY, JSON.stringify(initialItems));
    localStorageMock.setItem('userToken', 'fake-token');

    const mockNewItemFromServer = { id: 'server-id-1', type: 'note', label: 'New Note from Server', content: '' };
    fetch.mockResolvedValueOnce({ // For initial fetch
      ok: true,
      json: async () => ({ notesTree: initialItems }),
    }).mockResolvedValueOnce({ // For the POST request in addItem
      ok: true,
      json: async () => mockNewItemFromServer,
    });

    const { result } = renderHook(() => useTree());

    await act(async () => {
      await result.current.addItem({ label: 'New Note', type: 'note' }, null);
    });

    // This assertion depends on how `insertItemRecursive` and `setTreeWithUndo` update the state
    // expect(result.current.tree).toEqual(expect.arrayContaining([mockNewItemFromServer]));
  });

});

--- tests\utils\constants.test.js ---
import { LOCAL_STORAGE_KEY } from '../../src/utils/constants';

describe('constants', () => {
  test('LOCAL_STORAGE_KEY is correct', () => {
    expect(LOCAL_STORAGE_KEY).toBe('myNotesTasksTree');
  });
});


--- tests\utils\treeUtils.test.js ---
import {
    sortItems,
    handleDrop,
    deleteItemRecursive,
    renameItemRecursive,
    insertItemRecursive,
    findItemById,
    findParentAndSiblings,
    hasSiblingWithName,
    isSelfOrDescendant,
} from '../../src/utils/treeUtils';

import {
    assignNewIds
} from '../../src/hooks/useTree';

// --- Tests for sortItems ---
describe('treeUtils.sortItems', () => { /* ... Your existing sortItems tests ... */
    test('returns empty array for invalid input', () => {
        expect(sortItems(null)).toEqual([]);
        expect(sortItems(undefined)).toEqual([]);
        expect(sortItems({})).toEqual([]);
        expect(sortItems("string")).toEqual([]);
    });
    test('returns a new sorted array, does not mutate original', () => {
        const items = [{ type: 'note', label: 'b', id: '2' }, { type: 'folder', label: 'a', id: '1' }];
        const originalItems = [...items];
        const sorted = sortItems(items);
        expect(sorted).not.toBe(items);
        expect(items).toEqual(originalItems);
        expect(sorted[0].label).toBe('a');
        expect(sorted[1].label).toBe('b');
    });
    test('sorts folders first, then notes, then tasks, then alphabetically', () => {
        const items = [{ id: 't1', type: 'task', label: 'Task A' }, { id: 'f1', type: 'folder', label: 'Folder C' }, { id: 'n1', type: 'note', label: 'Note B' }, { id: 'f2', type: 'folder', label: 'Folder A' }, { id: 't2', type: 'task', label: 'Task B' }, { id: 'n2', type: 'note', label: 'Note A' }, { id: 'f3', type: 'folder', label: 'Folder B' },];
        const sorted = sortItems(items);
        expect(sorted.map(i => i.label)).toEqual(['Folder A', 'Folder B', 'Folder C', 'Note A', 'Note B', 'Task A', 'Task B']);
        expect(sorted.map(i => i.type)).toEqual(['folder', 'folder', 'folder', 'note', 'note', 'task', 'task']);
    });
    test('handles items with missing/null properties gracefully', () => {
        const items = [{ id: '1', type: 'folder', label: 'A' }, { id: '2', type: null, label: 'B' }, { id: '3', type: 'note' }, { id: '4' }, { id: '5', type: 'task', label: 'C' },];
        expect(() => sortItems(items)).not.toThrow();
        const sorted = sortItems(items);
        expect(sorted[0].label).toBe('A');
    });
    test('handles items with children correctly (does not sort children)', () => {
        const items = [{ id: 'f1', type: 'folder', label: 'B', children: [{ id: 'f1n1', type: 'note', label: 'Z' }] }, { id: 'f2', type: 'folder', label: 'A', children: [{ id: 'f2n1', type: 'note', label: 'X' }] },];
        const sorted = sortItems(items);
        expect(sorted.map(i => i.label)).toEqual(['A', 'B']);
        expect(sorted[0].children[0].label).toBe('X');
        expect(sorted[1].children[0].label).toBe('Z');
    });
});

// --- Tests for findItemById ---
describe('treeUtils.findItemById', () => { /* ... Your existing findItemById tests ... */
    const tree = [{ id: 'f1', type: 'folder', label: 'F1', children: [{ id: 'f1n1', type: 'note', label: 'N1' }, { id: 'f1f1', type: 'folder', label: 'F11', children: [{ id: 'f1f1t1', type: 'task', label: 'T1' }] }] }, { id: 'f2', type: 'folder', label: 'F2', children: [] }, { id: 'n2', type: 'note', label: 'N2' }];
    test('returns the item if found at root', () => expect(findItemById(tree, 'n2')).toBe(tree[2]));
    test('returns the item if found nested', () => { expect(findItemById(tree, 'f1n1')).toBe(tree[0].children[0]); expect(findItemById(tree, 'f1f1t1')).toBe(tree[0].children[1].children[0]); });
    test('returns null if item not found', () => expect(findItemById(tree, 'nonexistent')).toBeNull());
    test('returns null for invalid input', () => { expect(findItemById(null, 'f1')).toBeNull(); expect(findItemById(tree, null)).toBeNull(); expect(findItemById([], 'f1')).toBeNull(); });
});

// --- Tests for findParentAndSiblings ---
describe('treeUtils.findParentAndSiblings', () => { /* ... Your existing findParentAndSiblings tests ... */
    const tree = [{ id: 'f1', type: 'folder', label: 'F1', children: [{ id: 'f1n1', type: 'note', label: 'N1' }, { id: 'f1f1', type: 'folder', label: 'F11', children: [{ id: 'f1f1t1', type: 'task', label: 'T1' }] }] }, { id: 'f2', type: 'folder', label: 'F2', children: [] }, { id: 'n2', type: 'note', label: 'N2' }];
    const treeWithEmptyFolder = [{ id: 'f1', type: 'folder', label: 'F1', children: [] }];
    test('returns correct parent and siblings for root item', () => { const result = findParentAndSiblings(tree, 'n2'); expect(result.parent).toBeNull(); expect(result.siblings).toBe(tree); expect(result.siblings.length).toBe(3); });
    test('returns correct parent and siblings for nested item', () => { const result = findParentAndSiblings(tree, 'f1n1'); expect(result.parent).toBe(tree[0]); expect(result.siblings).toBe(tree[0].children); expect(result.siblings.length).toBe(2); });
    test('returns correct parent and siblings for deeply nested item', () => { const result = findParentAndSiblings(tree, 'f1f1t1'); expect(result.parent).toBe(tree[0].children[1]); expect(result.siblings).toBe(tree[0].children[1].children); expect(result.siblings.length).toBe(1); });
    test('returns null parent and empty siblings if item not found', () => { const result = findParentAndSiblings(tree, 'nonexistent'); expect(result.parent).toBeNull(); expect(result.siblings).toEqual([]); });
    test('returns null parent and root siblings if itemId is null', () => { const result = findParentAndSiblings(tree, null); expect(result.parent).toBeNull(); expect(result.siblings).toBe(tree); });
    test('returns empty siblings for invalid tree input', () => { const result = findParentAndSiblings(null, 'f1'); expect(result.parent).toBeNull(); expect(result.siblings).toEqual([]); });
    test('handles empty children array correctly', () => { const result = findParentAndSiblings(treeWithEmptyFolder, 'f1'); expect(result.parent).toBeNull(); expect(result.siblings).toBe(treeWithEmptyFolder); });
});

// --- Tests for hasSiblingWithName ---
describe('treeUtils.hasSiblingWithName', () => { /* ... Your existing hasSiblingWithName tests ... */
    const siblings = [{ id: '1', label: 'Apple' }, { id: '2', label: 'Banana ' }, { id: '3', label: 'cherry' }, { id: '4', label: null }, { id: '5' }];
    test('returns true if name exists (case-insensitive, trimmed)', () => { expect(hasSiblingWithName(siblings, 'apple')).toBe(true); expect(hasSiblingWithName(siblings, ' APPLE ')).toBe(true); expect(hasSiblingWithName(siblings, 'Banana')).toBe(true); expect(hasSiblingWithName(siblings, 'Cherry')).toBe(true); });
    test('returns false if name does not exist', () => { expect(hasSiblingWithName(siblings, 'Orange')).toBe(false); expect(hasSiblingWithName(siblings, 'Appl')).toBe(false); });
    test('returns false for invalid input', () => { expect(hasSiblingWithName(null, 'Apple')).toBe(false); expect(hasSiblingWithName([], 'Apple')).toBe(false); expect(hasSiblingWithName(siblings, null)).toBe(false); expect(hasSiblingWithName(siblings, '')).toBe(false); expect(hasSiblingWithName(siblings, '   ')).toBe(false); });
    test('excludes item with excludeId', () => { expect(hasSiblingWithName(siblings, 'Apple', '1')).toBe(false); expect(hasSiblingWithName(siblings, 'Banana', '1')).toBe(true); expect(hasSiblingWithName(siblings, 'Banana', '2')).toBe(false); });
    test('handles siblings with null/missing labels gracefully', () => { expect(hasSiblingWithName(siblings, 'Some Name')).toBe(false); expect(hasSiblingWithName(siblings, null)).toBe(false); });
});

// --- Tests for isSelfOrDescendant ---
describe('treeUtils.isSelfOrDescendant', () => { /* ... Your existing isSelfOrDescendant tests ... */
    const tree = [{ id: 'f1', type: 'folder', label: 'F1', children: [{ id: 'f1n1', type: 'note', label: 'N1' }, { id: 'f1f1', type: 'folder', label: 'F11', children: [{ id: 'f1f1t1', type: 'task', label: 'T1' }] }] }, { id: 'f2', type: 'folder', label: 'F2', children: [] }, { id: 'n2', type: 'note', label: 'N2' }];
    test('returns true if checkItemId equals potentialTargetId', () => { expect(isSelfOrDescendant(tree, 'f1', 'f1')).toBe(true); expect(isSelfOrDescendant(tree, 'f1n1', 'f1n1')).toBe(true); });
    test('returns true if potentialTargetId is a direct child', () => { expect(isSelfOrDescendant(tree, 'f1', 'f1n1')).toBe(true); expect(isSelfOrDescendant(tree, 'f1', 'f1f1')).toBe(true); });
    test('returns true if potentialTargetId is a nested descendant', () => expect(isSelfOrDescendant(tree, 'f1', 'f1f1t1')).toBe(true));
    test('returns false if potentialTargetId is not a descendant', () => { expect(isSelfOrDescendant(tree, 'f1', 'f2')).toBe(false); expect(isSelfOrDescendant(tree, 'f1', 'n2')).toBe(false); expect(isSelfOrDescendant(tree, 'f2', 'f1n1')).toBe(false); });
    test('returns false if checkItem is not a folder (and not self)', () => { expect(isSelfOrDescendant(tree, 'f1n1', 'f1f1t1')).toBe(false); expect(isSelfOrDescendant(tree, 'n2', 'f1')).toBe(false); });
    test('returns false for invalid IDs or tree', () => { expect(isSelfOrDescendant(null, 'f1', 'f1n1')).toBe(false); expect(isSelfOrDescendant(tree, null, 'f1n1')).toBe(false); expect(isSelfOrDescendant(tree, 'f1', null)).toBe(false); expect(isSelfOrDescendant(tree, 'nonexistent', 'f1n1')).toBe(false); expect(isSelfOrDescendant(tree, 'f1', 'nonexistent')).toBe(false); });
});

// --- Tests for deleteItemRecursive ---
describe('treeUtils.deleteItemRecursive', () => { /* ... Your existing deleteItemRecursive tests ... */
    const tree = [{ id: 'f1', type: 'folder', label: 'F1', children: [{ id: 'f1n1', type: 'note', label: 'N1' }] }, { id: 'n2', type: 'note', label: 'N2' }];
    test('removes root item', () => { const result = deleteItemRecursive(tree, 'n2'); expect(result.length).toBe(1); expect(result[0].id).toBe('f1'); });
    test('removes nested item', () => { const result = deleteItemRecursive(tree, 'f1n1'); expect(result.length).toBe(2); expect(result[0].id).toBe('f1'); expect(result[0].children.length).toBe(0); });
    test('returns new tree instance if ID not found but is an array', () => { const result = deleteItemRecursive(tree, 'nonexistent'); expect(result).toEqual(tree); expect(result).not.toBe(tree); });
    test('handles invalid input', () => { expect(deleteItemRecursive(null, 'id')).toEqual([]); expect(deleteItemRecursive(tree, null)).toEqual(tree); });
});

// --- Tests for renameItemRecursive ---
describe('treeUtils.renameItemRecursive', () => { /* ... Your existing renameItemRecursive tests ... */
    const tree = [{ id: 'f1', type: 'folder', label: 'F1', children: [{ id: 'f1n1', type: 'note', label: 'N1' }] }, { id: 'n2', type: 'note', label: 'N2' }];
    test('renames root item', () => { const result = renameItemRecursive(tree, 'n2', ' New Name '); expect(result[1].label).toBe('New Name'); expect(result[0].label).toBe('F1'); });
    test('renames nested item', () => { const result = renameItemRecursive(tree, 'f1n1', 'Nested New'); expect(result[0].children[0].label).toBe('Nested New'); expect(result[0].label).toBe('F1'); });
    test('returns new tree instance if ID not found but is an array', () => { const result = renameItemRecursive(tree, 'nonexistent', 'New Name'); expect(result).toEqual(tree); expect(result).not.toBe(tree); });
    test('handles invalid input', () => { expect(renameItemRecursive(null, 'id', 'Name')).toEqual([]); expect(renameItemRecursive(tree, null, 'Name')).toEqual(tree); });
});

// --- Tests for insertItemRecursive ---
describe('treeUtils.insertItemRecursive', () => { /* ... Your existing insertItemRecursive tests ... */
    const tree = [{ id: 'f1', type: 'folder', label: 'F1', children: [{ id: 'f1n1', type: 'note', label: 'N1' }] }, { id: 'n2', type: 'note', label: 'N2' }];
    const newItem = { id: 'new', type: 'task', label: 'New Task' };
    test('inserts item at root if targetFolderId is null', () => { const result = insertItemRecursive(tree, null, newItem); expect(result.length).toBe(3); expect(result.map(i => i.id)).toEqual(['f1', 'n2', 'new']); });
    test('inserts item into target folder and sorts', () => { const newItemB = { id: 'newB', type: 'task', label: 'B Task' }; const result = insertItemRecursive(tree, 'f1', newItemB); expect(result[0].id).toBe('f1'); expect(result[0].children.length).toBe(2); expect(result[0].children.map(c => c.label)).toEqual(['N1', 'B Task']); });
    test('returns new tree instance if targetFolderId not found', () => { const result = insertItemRecursive(tree, 'nonexistent', newItem); expect(result).toEqual(tree); expect(result).not.toBe(tree); });
    test('returns new tree instance if target is not a folder', () => { const result = insertItemRecursive(tree, 'n2', newItem); expect(result).toEqual(tree); expect(result).not.toBe(tree); });
    test('handles invalid input', () => { expect(insertItemRecursive(null, null, newItem)).toEqual([newItem]); expect(insertItemRecursive(null, 'f1', newItem)).toEqual([]); expect(insertItemRecursive([], null, newItem)).toEqual([newItem]); });
});

// --- Tests for handleDrop (Validation Focus) ---
describe('treeUtils.handleDrop (Validation Focus)', () => { /* ... Your existing handleDrop tests ... */
    let initialTree; const alertSpy = jest.spyOn(window, 'alert').mockImplementation(() => { });
    beforeEach(() => { initialTree = [{ id: 'f1', type: 'folder', label: 'Folder 1', children: [{ id: 'n1', type: 'note', label: 'Note 1' }] }, { id: 'f2', type: 'folder', label: 'Folder 2', children: [{ id: 'n2', type: 'note', label: 'Note 1' }] }]; alertSpy.mockClear(); });
    afterAll(() => { alertSpy.mockRestore(); });
    test('returns null if dropping folder into self (no alert)', () => { expect(handleDrop(initialTree, 'f1', 'f1')).toBeNull(); expect(alertSpy).not.toHaveBeenCalled(); }); // Self-drop handled by initial check
    test('returns null and alerts if dropping parent folder into child', () => { const treeWithNest = [{ id: 'a', type: 'folder', children: [{ id: 'b', type: 'folder' }] }]; expect(handleDrop(treeWithNest, 'b', 'a')).toBeNull(); expect(alertSpy).toHaveBeenCalledWith(expect.stringContaining("Cannot drop folder")); });
    test('returns null and alerts if name conflict exists in target', () => { expect(handleDrop(initialTree, 'f2', 'n1')).toBeNull(); expect(alertSpy).toHaveBeenCalledWith(expect.stringContaining("already exists in the target folder 'Folder 2'")); });
    test('allows drop if name conflict does NOT exist', () => { const tree = [{ id: 'f1', type: 'folder', label: 'Folder 1', children: [{ id: 'n1', type: 'note', label: 'Unique Note' }] }, { id: 'f2', type: 'folder', label: 'Folder 2', children: [{ id: 'n2', type: 'note', label: 'Another Note' }] }]; const newTree = handleDrop(tree, 'f2', 'n1'); expect(newTree).not.toBeNull(); expect(alertSpy).not.toHaveBeenCalled(); const targetFolder = newTree.find(i => i.id === 'f2'); expect(targetFolder.children.length).toBe(2); expect(targetFolder.children.map(c => c.label)).toContain('Unique Note'); });
});

describe('treeUtils.assignNewIds', () => {
    test('assigns a new ID if isDuplication is true', () => {
        const item = { id: 'old-id', label: 'Test', type: 'note' };
        const newItem = assignNewIds(item, true);
        expect(newItem.id).not.toBe('old-id');
        expect(newItem.id).toMatch(/^client-/);
    });

    test('assigns a new ID if item has no ID', () => {
        const item = { label: 'Test', type: 'note' }; // No id
        const newItem = assignNewIds(item, false);
        expect(newItem.id).toMatch(/^client-/);
    });

    test('assigns a new ID if item ID starts with "temp-"', () => {
        const item = { id: 'temp-123', label: 'Test', type: 'note' };
        const newItem = assignNewIds(item, false);
        expect(newItem.id).not.toBe('temp-123');
        expect(newItem.id).toMatch(/^client-/);
    });

    test('assigns a new ID if item ID starts with "client-" and isDuplication is true', () => {
        const item = { id: 'client-abc', label: 'Test', type: 'note' };
        const newItem = assignNewIds(item, true); // Duplicating an already client-ID'd item
        expect(newItem.id).not.toBe('client-abc');
        expect(newItem.id).toMatch(/^client-/);
    });

    test('keeps existing ID if not duplication and ID is not temp/client', () => {
        const item = { id: 'server-id-123', label: 'Test', type: 'note' };
        const newItem = assignNewIds(item, false);
        expect(newItem.id).toBe('server-id-123');
    });

    test('recursively assigns new IDs to children of a folder if isDuplication is true', () => {
        const folder = {
            id: 'f-old', type: 'folder', label: 'F',
            children: [
                { id: 'c1-old', type: 'note', label: 'N1' },
                {
                    id: 'c2-old', type: 'folder', label: 'SF', children: [
                        { id: 'gc1-old', type: 'task', label: 'T1' }
                    ]
                }
            ]
        };
        const newFolder = assignNewIds(folder, true);
        expect(newFolder.id).not.toBe('f-old');
        expect(newFolder.id).toMatch(/^client-/);
        expect(newFolder.children[0].id).not.toBe('c1-old');
        expect(newFolder.children[0].id).toMatch(/^client-/);
        expect(newFolder.children[1].id).not.toBe('c2-old');
        expect(newFolder.children[1].id).toMatch(/^client-/);
        expect(newFolder.children[1].children[0].id).not.toBe('gc1-old');
        expect(newFolder.children[1].children[0].id).toMatch(/^client-/);
    });

    test('does not change children IDs if not duplication and parent ID is stable', () => {
        const folder = {
            id: 'server-f', type: 'folder', label: 'F',
            children: [{ id: 'server-c1', type: 'note', label: 'N1' }]
        };
        const newFolder = assignNewIds(folder, false);
        expect(newFolder.id).toBe('server-f');
        expect(newFolder.children[0].id).toBe('server-c1');
    });
});

--- tests\__mocks__\unicodeBidirectionalMock.js ---
// tests/__mocks__/unicodeBidirectionalMock.js
module.exports = {
  embeddingLevels: jest.fn(() => []),
  reorder: jest.fn((txt) => txt),
};


--- tests\__mocks__\unicodeBidirectionalMock.js ---
// tests/__mocks__/unicodeBidirectionalMock.js
module.exports = {
  embeddingLevels: jest.fn(() => []),
  reorder: jest.fn((txt) => txt),
};


--- tests\__mocks__\unicodeBidirectionalMock.js ---
// tests/__mocks__/unicodeBidirectionalMock.js
module.exports = {
  embeddingLevels: jest.fn(() => []),
  reorder: jest.fn((txt) => txt),
};


--- tests\components\AboutDialog.test.jsx ---
// tests/components/AboutDialog.test.jsx
import React from "react";
import { render, screen, fireEvent } from "@testing-library/react";
import "@testing-library/jest-dom";
import AboutDialog from "../../src/components/AboutDialog";
// Ensure package.json is correctly resolved relative to this test file, or mock it
// For simplicity, let's assume a mock or that the path is correct.
// If it causes issues, you might need to configure Jest's moduleNameMapper or mock package.json
let packageJson;
try {
  packageJson = require("../../package.json");
} catch (e) {
  // Mock if package.json is not found at that relative path during testing
  console.warn(
    "package.json not found for AboutDialog test, using mock version."
  );
  packageJson = { version: "1.0.0-test" };
}

describe("<AboutDialog />", () => {
  const mockOnClose = jest.fn();
  const originalGetFullYear = Date.prototype.getFullYear;

  beforeEach(() => {
    mockOnClose.mockClear();
    // Mock current year for consistent testing
    Date.prototype.getFullYear = jest.fn(() => 2025);
  });

  afterEach(() => {
    Date.prototype.getFullYear = originalGetFullYear; // Restore original Date object
  });

  test("does not render when isOpen is false", () => {
    const { container } = render(
      <AboutDialog isOpen={false} onClose={mockOnClose} />
    );
    expect(container.firstChild).toBeNull();
  });

  test("renders correctly when isOpen is true", () => {
    render(<AboutDialog isOpen={true} onClose={mockOnClose} />);
    expect(
      screen.getByRole("heading", { name: /About Notes & Tasks App/i })
    ).toBeInTheDocument();
    expect(screen.getByText(/Notes & Tasks App © 2025/)).toBeInTheDocument();
    expect(
      screen.getByText(new RegExp(`Version: ${packageJson.version}`))
    ).toBeInTheDocument();
    expect(screen.getByRole("button", { name: /Close/i })).toBeInTheDocument();
  });

  test("calls onClose when Close button is clicked", () => {
    render(<AboutDialog isOpen={true} onClose={mockOnClose} />);
    const closeButton = screen.getByRole("button", { name: /Close/i });
    fireEvent.click(closeButton);
    expect(mockOnClose).toHaveBeenCalledTimes(1);
  });

  test("modal overlay is present", () => {
    render(<AboutDialog isOpen={true} onClose={mockOnClose} />);
    const overlay = screen
      .getByRole("button", { name: /Close/i })
      .closest("div.fixed.inset-0");
    expect(overlay).toHaveClass("bg-black", "bg-opacity-50");
  });

  test("close button is focused on open", () => {
    render(<AboutDialog isOpen={true} onClose={mockOnClose} />);
    expect(screen.getByRole("button", { name: /Close/i })).toHaveFocus();
  });
});


--- tests\components\AddDialog.test.jsx ---
// tests/components/AddDialog.test.jsx
import React from "react";
import { render, screen, fireEvent, waitFor } from "@testing-library/react";
import "@testing-library/jest-dom";
import AddDialog from "../../src/components/AddDialog";

describe("<AddDialog />", () => {
  const mockOnLabelChange = jest.fn();
  const mockOnAdd = jest.fn();
  const mockOnCancel = jest.fn();

  const defaultProps = {
    isOpen: true,
    newItemType: "folder",
    newItemLabel: "",
    errorMessage: "",
    onLabelChange: mockOnLabelChange,
    onAdd: mockOnAdd,
    onCancel: mockOnCancel,
  };

  beforeEach(() => {
    mockOnLabelChange.mockClear();
    mockOnAdd.mockClear();
    mockOnCancel.mockClear();
  });

  test("does not render when isOpen is false", () => {
    const { container } = render(
      <AddDialog {...defaultProps} isOpen={false} />
    );
    expect(container.firstChild).toBeNull();
  });

  test("renders correct title based on newItemType", () => {
    const { rerender } = render(
      <AddDialog {...defaultProps} newItemType="folder" />
    );
    expect(
      screen.getByRole("heading", { name: /Add folder/i })
    ).toBeInTheDocument();

    rerender(<AddDialog {...defaultProps} newItemType="note" />);
    expect(
      screen.getByRole("heading", { name: /Add note/i })
    ).toBeInTheDocument();

    rerender(<AddDialog {...defaultProps} newItemType="task" />);
    expect(
      screen.getByRole("heading", { name: /Add task/i })
    ).toBeInTheDocument();
  });

  test("renders input, calls onLabelChange, and focuses input", async () => {
    render(<AddDialog {...defaultProps} />);
    const input = screen.getByPlaceholderText(/Enter folder name/i);
    expect(input).toBeInTheDocument();
    await waitFor(() => expect(input).toHaveFocus());
    expect(input).toHaveValue("");

    fireEvent.change(input, { target: { value: "New Folder Name" } });
    expect(mockOnLabelChange).toHaveBeenCalledTimes(1);
  });

  test("displays specific error message when errorMessage prop is set", () => {
    const errorText = "Duplicate name detected!";
    render(<AddDialog {...defaultProps} errorMessage={errorText} />);
    expect(screen.getByText(errorText)).toBeInTheDocument();
    const input = screen.getByPlaceholderText(/Enter folder name/i);
    expect(input).toHaveAttribute("aria-invalid", "true");
    expect(input).toHaveAttribute("aria-describedby", "add-error-message");
    expect(input).toHaveClass("border-red-500");
  });

  test("does not display error message when errorMessage is empty", () => {
    render(<AddDialog {...defaultProps} errorMessage="" />);
    const errorParagraph = screen.queryByText("Duplicate name detected!"); // Example error text
    expect(errorParagraph).not.toBeInTheDocument();
    const input = screen.getByPlaceholderText(/Enter folder name/i);
    expect(input).not.toHaveAttribute("aria-invalid", "true");
    expect(input).not.toHaveAttribute("aria-describedby");
    expect(input).not.toHaveClass("border-red-500");
  });

  test("calls onCancel when Cancel button is clicked", () => {
    render(<AddDialog {...defaultProps} />);
    fireEvent.click(screen.getByRole("button", { name: /Cancel/i }));
    expect(mockOnCancel).toHaveBeenCalledTimes(1);
  });

  test("calls onAdd when Add button is clicked", () => {
    render(<AddDialog {...defaultProps} newItemLabel="Valid Name" />);
    fireEvent.click(screen.getByRole("button", { name: /Add/i }));
    expect(mockOnAdd).toHaveBeenCalledTimes(1);
  });

  test("calls onAdd when form is submitted", () => {
    render(<AddDialog {...defaultProps} newItemLabel="Valid Name" />);
    const form = screen.getByRole("button", { name: /Add/i }).closest("form");
    if (!form) throw new Error("Could not find form element");
    fireEvent.submit(form);
    expect(mockOnAdd).toHaveBeenCalledTimes(1);
  });
});


--- tests\components\ContextMenu.test.jsx ---
// tests/components/ContextMenu.test.jsx
import React from "react";
import { render, screen, fireEvent } from "@testing-library/react";
import "@testing-library/jest-dom";
import ContextMenu from "../../src/components/ContextMenu";

jest.mock("lucide-react", () => ({
  Scissors: () => <svg data-testid="icon-scissors" />,
  Copy: () => <svg data-testid="icon-copy" />,
  ClipboardPaste: () => <svg data-testid="icon-paste" />,
  Upload: () => <svg data-testid="icon-upload" />,
  Download: () => <svg data-testid="icon-download" />,
}));

describe("<ContextMenu />", () => {
  const mockHandlers = {
    onAddRootFolder: jest.fn(),
    onAddFolder: jest.fn(),
    onAddNote: jest.fn(),
    onAddTask: jest.fn(),
    onRename: jest.fn(),
    onDelete: jest.fn(),
    onCopy: jest.fn(),
    onCut: jest.fn(),
    onPaste: jest.fn(),
    onDuplicate: jest.fn(),
    onExportItem: jest.fn(),
    onImportItem: jest.fn(),
    onExportTree: jest.fn(),
    onImportTree: jest.fn(),
    onClose: jest.fn(),
  };
  const folderItem = { id: "f1", type: "folder", label: "My Folder" };
  const noteItem = { id: "n1", type: "note", label: "My Note" };
  const clipboardItemMock = {
    id: "clip1",
    type: "note",
    label: "Clipped Note",
  };
  const defaultProps = {
    visible: true,
    x: 100,
    y: 150,
    item: null,
    isEmptyArea: false,
    clipboardItem: null,
    ...mockHandlers,
  };

  beforeEach(() => jest.clearAllMocks());

  test("does not render when visible is false", () => {
    const { container } = render(
      <ContextMenu {...defaultProps} visible={false} />
    );
    expect(container.firstChild).toBeNull();
  });

  test("renders at correct position", () => {
    render(
      <ContextMenu {...defaultProps} item={noteItem} isEmptyArea={false} />
    );
    const menu = screen
      .getByRole("button", { name: /Rename/i })
      .closest('div[class*="fixed"]');
    expect(menu).toHaveStyle(`top: ${defaultProps.y}px`);
    expect(menu).toHaveStyle(`left: ${defaultProps.x}px`);
  });

  describe("When isEmptyArea is true", () => {
    test("renders correct empty area actions", () => {
      const { rerender } = render(
        <ContextMenu
          {...defaultProps}
          isEmptyArea={true}
          item={null}
          clipboardItem={null}
        />
      );
      expect(
        screen.getByRole("button", { name: /Add Root Folder/i })
      ).toBeInTheDocument();
      expect(
        screen.getByRole("button", { name: /Export Full Tree/i })
      ).toBeInTheDocument();
      expect(
        screen.getByRole("button", { name: /Import Full Tree/i })
      ).toBeInTheDocument();
      expect(
        screen.queryByRole("button", { name: /Paste/i })
      ).not.toBeInTheDocument();

      rerender(
        <ContextMenu
          {...defaultProps}
          isEmptyArea={true}
          item={null}
          clipboardItem={clipboardItemMock}
        />
      );
      expect(
        screen.getByRole("button", { name: /Paste/i })
      ).toBeInTheDocument();
    });
    test("calls correct handlers for empty area actions", () => {
      render(
        <ContextMenu
          {...defaultProps}
          isEmptyArea={true}
          item={null}
          clipboardItem={clipboardItemMock}
        />
      );
      fireEvent.click(screen.getByRole("button", { name: /Add Root Folder/i }));
      expect(mockHandlers.onAddRootFolder).toHaveBeenCalledTimes(1);
      fireEvent.click(screen.getByRole("button", { name: /Paste/i }));
      expect(mockHandlers.onPaste).toHaveBeenCalledTimes(1);
      fireEvent.click(
        screen.getByRole("button", { name: /Export Full Tree/i })
      );
      expect(mockHandlers.onExportTree).toHaveBeenCalledTimes(1);
      fireEvent.click(
        screen.getByRole("button", { name: /Import Full Tree/i })
      );
      expect(mockHandlers.onImportTree).toHaveBeenCalledTimes(1);
      expect(mockHandlers.onClose).toHaveBeenCalledTimes(4);
    });
  });

  describe("When item is a folder", () => {
    test("renders all folder actions", () => {
      const { rerender } = render(
        <ContextMenu
          {...defaultProps}
          isEmptyArea={false}
          item={folderItem}
          clipboardItem={null}
        />
      );
      expect(
        screen.getByRole("button", { name: /Add Folder Here/i })
      ).toBeInTheDocument();
      expect(
        screen.getByRole("button", { name: /Add Note Here/i })
      ).toBeInTheDocument();
      expect(
        screen.getByRole("button", { name: /Add Task Here/i })
      ).toBeInTheDocument();
      expect(
        screen.getByRole("button", { name: /Import under Item/i })
      ).toBeInTheDocument();
      expect(
        screen.queryByRole("button", { name: /Paste Here/i })
      ).not.toBeInTheDocument();
      rerender(
        <ContextMenu
          {...defaultProps}
          isEmptyArea={false}
          item={folderItem}
          clipboardItem={clipboardItemMock}
        />
      );
      expect(
        screen.getByRole("button", { name: /Paste Here/i })
      ).toBeInTheDocument();
    });
    test("calls correct handlers for folder actions", () => {
      render(
        <ContextMenu
          {...defaultProps}
          isEmptyArea={false}
          item={folderItem}
          clipboardItem={clipboardItemMock}
        />
      );
      fireEvent.click(screen.getByRole("button", { name: /Add Folder Here/i }));
      expect(mockHandlers.onAddFolder).toHaveBeenCalledTimes(1);
      fireEvent.click(screen.getByRole("button", { name: /Add Note Here/i }));
      expect(mockHandlers.onAddNote).toHaveBeenCalledTimes(1);
      fireEvent.click(screen.getByRole("button", { name: /Add Task Here/i }));
      expect(mockHandlers.onAddTask).toHaveBeenCalledTimes(1);
      fireEvent.click(screen.getByRole("button", { name: /Cut/i }));
      expect(mockHandlers.onCut).toHaveBeenCalledTimes(1);
      fireEvent.click(screen.getByRole("button", { name: /Copy/i }));
      expect(mockHandlers.onCopy).toHaveBeenCalledTimes(1);
      fireEvent.click(screen.getByRole("button", { name: /Duplicate/i }));
      expect(mockHandlers.onDuplicate).toHaveBeenCalledTimes(1);
      fireEvent.click(screen.getByRole("button", { name: /Paste Here/i }));
      expect(mockHandlers.onPaste).toHaveBeenCalledTimes(1);
      fireEvent.click(screen.getByRole("button", { name: /Export Item/i }));
      expect(mockHandlers.onExportItem).toHaveBeenCalledTimes(1);
      fireEvent.click(
        screen.getByRole("button", { name: /Import under Item/i })
      );
      expect(mockHandlers.onImportItem).toHaveBeenCalledTimes(1);
      fireEvent.click(screen.getByRole("button", { name: /Rename/i }));
      expect(mockHandlers.onRename).toHaveBeenCalledTimes(1);
      fireEvent.click(screen.getByRole("button", { name: /Delete/i }));
      expect(mockHandlers.onDelete).toHaveBeenCalledTimes(1);
      expect(mockHandlers.onClose).toHaveBeenCalledTimes(11);
    });
  });

  describe("When item is a note/task", () => {
    test("renders note/task actions (no add/paste/import)", () => {
      render(
        <ContextMenu
          {...defaultProps}
          isEmptyArea={false}
          item={noteItem}
          clipboardItem={clipboardItemMock}
        />
      );
      expect(
        screen.queryByRole("button", { name: /Add Folder Here/i })
      ).not.toBeInTheDocument();
      expect(
        screen.queryByRole("button", { name: /Paste Here/i })
      ).not.toBeInTheDocument();
      expect(
        screen.queryByRole("button", { name: /Import under Item/i })
      ).not.toBeInTheDocument();
      expect(screen.getByRole("button", { name: /Cut/i })).toBeInTheDocument();
    });
    test("calls correct handlers for note/task actions", () => {
      render(
        <ContextMenu {...defaultProps} isEmptyArea={false} item={noteItem} />
      );
      fireEvent.click(screen.getByRole("button", { name: /Cut/i }));
      expect(mockHandlers.onCut).toHaveBeenCalledTimes(1);
      fireEvent.click(screen.getByRole("button", { name: /Copy/i }));
      expect(mockHandlers.onCopy).toHaveBeenCalledTimes(1);
      fireEvent.click(screen.getByRole("button", { name: /Duplicate/i }));
      expect(mockHandlers.onDuplicate).toHaveBeenCalledTimes(1);
      fireEvent.click(screen.getByRole("button", { name: /Export Item/i }));
      expect(mockHandlers.onExportItem).toHaveBeenCalledTimes(1);
      fireEvent.click(screen.getByRole("button", { name: /Rename/i }));
      expect(mockHandlers.onRename).toHaveBeenCalledTimes(1);
      fireEvent.click(screen.getByRole("button", { name: /Delete/i }));
      expect(mockHandlers.onDelete).toHaveBeenCalledTimes(1);
      expect(mockHandlers.onClose).toHaveBeenCalledTimes(6);
    });
  });

  test("calls onClose when clicking outside", () => {
    render(
      <div>
        <ContextMenu {...defaultProps} item={noteItem} /> Outside{" "}
      </div>
    );
    fireEvent.mouseDown(screen.getByText("Outside"));
    expect(mockHandlers.onClose).toHaveBeenCalledTimes(1);
  });
  test("calls onClose when Escape key is pressed", () => {
    render(<ContextMenu {...defaultProps} item={noteItem} />);
    fireEvent.keyDown(document.body, { key: "Escape", code: "Escape" });
    expect(mockHandlers.onClose).toHaveBeenCalledTimes(1);
  });
});


--- tests\components\ExportDialog.test.jsx ---
// tests/components/ExportDialog.test.jsx
import React from 'react';
import { render, screen, fireEvent } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import '@testing-library/jest-dom';
import ExportDialog from '../../src/components/ExportDialog';

describe('<ExportDialog />', () => {
  const mockOnClose = jest.fn();
  const mockOnExport = jest.fn();

  const defaultProps = {
    isOpen: true,
    context: null, // Generic context, allows choosing target
    defaultFormat: 'json',
    onClose: mockOnClose,
    onExport: mockOnExport,
  };

  beforeEach(() => {
    mockOnClose.mockClear();
    mockOnExport.mockClear();
  });

  test('does not render when isOpen is false', () => {
    const { container } = render(<ExportDialog {...defaultProps} isOpen={false} />);
    expect(container.firstChild).toBeNull();
  });

  test('renders correctly with default props (generic context)', () => {
    render(<ExportDialog {...defaultProps} />);
    expect(screen.getByRole('heading', { name: /Export Options/i })).toBeInTheDocument();
    expect(screen.getByLabelText(/Selected Item/i)).toBeChecked(); // Default target
    expect(screen.getByLabelText(/JSON/i)).toBeChecked(); // Default format
    expect(screen.getByRole('button', { name: /Export as JSON/i })).toBeInTheDocument();
  });

  test('renders correctly for "item" context', () => {
    render(<ExportDialog {...defaultProps} context="item" />);
    expect(screen.getByRole('heading', { name: /Export Selected Item/i })).toBeInTheDocument();
    // Target radio buttons should not be shown
    expect(screen.queryByLabelText(/Selected Item/i)).not.toBeInTheDocument();
    expect(screen.queryByLabelText(/Entire Tree/i)).not.toBeInTheDocument();
    expect(screen.getByLabelText(/JSON/i)).toBeChecked();
  });

  test('renders correctly for "tree" context', () => {
    render(<ExportDialog {...defaultProps} context="tree" />);
    expect(screen.getByRole('heading', { name: /Export Full Tree/i })).toBeInTheDocument();
    expect(screen.queryByLabelText(/Selected Item/i)).not.toBeInTheDocument();
    expect(screen.queryByLabelText(/Entire Tree/i)).not.toBeInTheDocument();
    expect(screen.getByLabelText(/PDF/i)).not.toBeChecked(); // JSON is default
  });

  test('allows changing export target when context is generic', async () => {
    const user = userEvent.setup();
    render(<ExportDialog {...defaultProps} context={null} />); // Generic context
    const entireTreeRadio = screen.getByLabelText(/Entire Tree/i);
    await user.click(entireTreeRadio);
    expect(entireTreeRadio).toBeChecked();
  });

  test('allows changing export format', async () => {
    const user = userEvent.setup();
    render(<ExportDialog {...defaultProps} />);
    const pdfRadio = screen.getByLabelText(/PDF/i);
    await user.click(pdfRadio);
    expect(pdfRadio).toBeChecked();
    expect(screen.getByRole('button', { name: /Export as PDF/i })).toBeInTheDocument();
  });

  test('calls onExport with correct target and format', async () => {
    const user = userEvent.setup();
    render(<ExportDialog {...defaultProps} context={null} />); // Generic to allow target change
    
    // Change target and format
    await user.click(screen.getByLabelText(/Entire Tree/i));
    await user.click(screen.getByLabelText(/PDF/i));
    
    await user.click(screen.getByRole('button', { name: /Export as PDF/i }));
    expect(mockOnExport).toHaveBeenCalledWith('entire', 'pdf');
    expect(mockOnClose).toHaveBeenCalledTimes(1);
  });

  test('calls onExport with "selected" target if context is "item"', async () => {
    const user = userEvent.setup();
    render(<ExportDialog {...defaultProps} context="item" defaultFormat="pdf" />);
    await user.click(screen.getByRole('button', { name: /Export as PDF/i }));
    expect(mockOnExport).toHaveBeenCalledWith('selected', 'pdf');
    expect(mockOnClose).toHaveBeenCalledTimes(1);
  });

  test('calls onClose when Cancel button is clicked', async () => {
    const user = userEvent.setup();
    render(<ExportDialog {...defaultProps} />);
    await user.click(screen.getByRole('button', { name: /Cancel/i }));
    expect(mockOnClose).toHaveBeenCalledTimes(1);
  });

  test('uses defaultFormat prop correctly', () => {
    render(<ExportDialog {...defaultProps} defaultFormat="pdf" />);
    expect(screen.getByLabelText(/PDF/i)).toBeChecked();
    expect(screen.getByRole('button', {name: /Export as PDF/i})).toBeInTheDocument();
  });
});

--- tests\components\FolderContents.test.jsx ---
// tests/components/FolderContents.test.jsx
import React from "react";
import {
  render,
  screen,
  fireEvent,
  within,
  waitFor,
} from "@testing-library/react";
import userEvent from "@testing-library/user-event";
import "@testing-library/jest-dom";
import FolderContents from "../../src/components/FolderContents";

// Mock lucide-react MoreVertical icon
jest.mock("lucide-react", () => ({
  ...jest.requireActual("lucide-react"), // Import and retain default behavior
  MoreVertical: () => <svg data-testid="icon-more-vertical" />,
}));

describe("<FolderContents /> Component", () => {
  const mockOnSelect = jest.fn();
  const mockOnToggleExpand = jest.fn();
  const mockHandleDragStart = jest.fn();
  const mockHandleDragEnter = jest.fn();
  const mockHandleDragOver = jest.fn();
  const mockHandleDragLeave = jest.fn();
  const mockHandleDrop = jest.fn();
  const mockHandleDragEnd = jest.fn();
  const mockOnShowItemMenu = jest.fn(); // Mock for the new prop

  const emptyFolder = {
    id: "f0",
    type: "folder",
    label: "Empty Folder",
    children: [],
  };
  const folderWithChildren = {
    id: "f1",
    type: "folder",
    label: "Folder With Items",
    children: [
      { id: "f2", type: "folder", label: "Subfolder Alpha", children: [] },
      { id: "n1", type: "note", label: "Note Beta" },
      { id: "t1", type: "task", label: "Task Gamma", completed: false },
      { id: "t2", type: "task", label: "Task Delta", completed: true },
    ],
  };

  const defaultProps = {
    onSelect: mockOnSelect,
    onToggleExpand: mockOnToggleExpand,
    expandedItems: {}, // Default to no folders expanded
    handleDragStart: mockHandleDragStart,
    handleDragEnter: mockHandleDragEnter,
    handleDragOver: mockHandleDragOver,
    handleDragLeave: mockHandleDragLeave,
    handleDrop: mockHandleDrop,
    handleDragEnd: mockHandleDragEnd,
    draggedId: null,
    dragOverItemId: null,
    onShowItemMenu: mockOnShowItemMenu,
  };

  beforeEach(() => {
    jest.clearAllMocks();
  });

  test("renders empty message when folder has no children", () => {
    render(<FolderContents {...defaultProps} folder={emptyFolder} />);
    expect(screen.getByText("This folder is empty.")).toBeInTheDocument();
  });

  test("renders children items sorted correctly", () => {
    // sortItems in FolderContents sorts folders first, then by label
    render(
      <FolderContents
        {...defaultProps}
        folder={folderWithChildren}
        expandedItems={{ f2: false }}
      />
    );
    const listItems = screen.getAllByRole("listitem"); // Get all <li> elements
    expect(listItems.length).toBe(4);
    // Based on sortItems: Folder, Note, Task, Task (alphabetical within type)
    expect(
      within(listItems[0]).getByText("Subfolder Alpha")
    ).toBeInTheDocument();
    expect(within(listItems[1]).getByText("Note Beta")).toBeInTheDocument();
    expect(within(listItems[2]).getByText("Task Delta")).toBeInTheDocument(); // Delta before Gamma
    expect(within(listItems[3]).getByText("Task Gamma")).toBeInTheDocument();
  });

  test("calls onSelect when an item (not an interactive button within it) is clicked", async () => {
    const user = userEvent.setup();
    render(<FolderContents {...defaultProps} folder={folderWithChildren} />);
    // Target the list item itself or its main clickable area, not specific buttons within it yet
    const noteListItem = screen.getByText("Note Beta").closest("li");
    if (!noteListItem) throw new Error("Note Beta list item not found");
    await user.click(noteListItem);
    expect(mockOnSelect).toHaveBeenCalledWith("n1");
  });

  test("calls onToggleExpand when folder expand button is clicked", async () => {
    const user = userEvent.setup();
    render(
      <FolderContents
        {...defaultProps}
        folder={folderWithChildren}
        expandedItems={{ f2: false }}
      />
    );
    // Target the expand button specifically using its accessible name
    const expandButton = screen.getByRole("button", {
      name: /Expand Subfolder Alpha/i,
    });
    await user.click(expandButton);
    expect(mockOnToggleExpand).toHaveBeenCalledWith("f2");
  });

  test("calls onShowItemMenu when More options button is clicked", async () => {
    const user = userEvent.setup();
    render(<FolderContents {...defaultProps} folder={folderWithChildren} />);
    const noteItemLabel = screen.getByText("Note Beta");
    const noteItemLi = noteItemLabel.closest("li");
    if (!noteItemLi) throw new Error("List item for Note Beta not found");

    const moreButton = within(noteItemLi).getByRole("button", {
      name: /More options for Note Beta/i,
    });
    await user.click(moreButton);
    expect(mockOnShowItemMenu).toHaveBeenCalledTimes(1);
    expect(mockOnShowItemMenu).toHaveBeenCalledWith(
      folderWithChildren.children[1],
      expect.any(HTMLElement)
    ); // children[1] is Note Beta
  });

  // Drag and drop tests can be complex with react-testing-library.
  // Basic interaction checks:
  test("calls drag handlers when an item is dragged", () => {
    render(<FolderContents {...defaultProps} folder={folderWithChildren} />);
    const draggableItem = screen.getByText("Note Beta").closest("li");
    if (!draggableItem) throw new Error("Draggable item 'Note Beta' not found");

    fireEvent.dragStart(draggableItem);
    expect(mockHandleDragStart).toHaveBeenCalledWith(expect.any(Object), "n1");

    fireEvent.dragEnd(draggableItem);
    expect(mockHandleDragEnd).toHaveBeenCalledWith(expect.any(Object));
  });

  test("applies opacity when item is being dragged", () => {
    render(
      <FolderContents
        {...defaultProps}
        folder={folderWithChildren}
        draggedId="n1"
      />
    );
    const noteItemLi = screen.getByText("Note Beta").closest("li");
    expect(noteItemLi).toHaveClass("opacity-40");
  });

  test("shows folder icon correctly (open/closed)", () => {
    const { rerender } = render(
      <FolderContents
        {...defaultProps}
        folder={folderWithChildren}
        expandedItems={{ f2: false }}
      />
    );
    const subfolderItem = screen.getByText("Subfolder Alpha").closest("li");
    expect(within(subfolderItem).getByText("📁")).toBeInTheDocument(); // Closed folder icon

    rerender(
      <FolderContents
        {...defaultProps}
        folder={folderWithChildren}
        expandedItems={{ f2: true }}
      />
    );
    const openedSubfolderItem = screen
      .getByText("Subfolder Alpha")
      .closest("li");
    expect(within(openedSubfolderItem).getByText("📂")).toBeInTheDocument(); // Open folder icon
  });

  test("shows task completion status correctly", () => {
    render(<FolderContents {...defaultProps} folder={folderWithChildren} />);
    const taskDeltaItem = screen.getByText("Task Delta").closest("li"); // Completed
    expect(within(taskDeltaItem).getByText("✅")).toBeInTheDocument();
    expect(within(taskDeltaItem).getByText("Task Delta")).toHaveClass(
      "line-through"
    );

    const taskGammaItem = screen.getByText("Task Gamma").closest("li"); // Incomplete
    expect(within(taskGammaItem).getByText("⬜️")).toBeInTheDocument();
    expect(within(taskGammaItem).getByText("Task Gamma")).not.toHaveClass(
      "line-through"
    );
  });
});


--- tests\components\ImportDialog.test.jsx ---
// tests/components/ImportDialog.test.jsx
import React from 'react';
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import '@testing-library/jest-dom';
import ImportDialog from '../../src/components/ImportDialog';

describe('<ImportDialog />', () => {
  const mockOnClose = jest.fn();
  const mockOnImport = jest.fn();
  const selectedItemMock = { id: 'folder1', label: 'My Folder', type: 'folder' };

  const defaultProps = {
    isOpen: true,
    context: 'item', // Default to import under item
    selectedItem: selectedItemMock,
    onClose: mockOnClose,
    onImport: mockOnImport,
  };

  beforeEach(() => {
    mockOnClose.mockClear();
    mockOnImport.mockClear();
  });

  test('does not render when isOpen is false', () => {
    const { container } = render(<ImportDialog {...defaultProps} isOpen={false} />);
    expect(container.firstChild).toBeNull();
  });

  test('renders correctly for "import under item" context', () => {
    render(<ImportDialog {...defaultProps} />);
    expect(screen.getByRole('heading', { name: /Import Under "My Folder"/i })).toBeInTheDocument();
    expect(screen.getByLabelText(/Under Selected Item/i)).toBeChecked();
    expect(screen.getByLabelText(/Into empty tree or overwrite existing data/i)).not.toBeChecked();
    expect(screen.getByLabelText(/Select JSON File/i)).toBeInTheDocument();
    expect(screen.getByRole('button', { name: 'Import' })).toBeDisabled(); // No file selected
  });

  test('renders correctly for "tree" (full import) context', () => {
    render(<ImportDialog {...defaultProps} context="tree" selectedItem={null} />);
    expect(screen.getByRole('heading', { name: /Import Tree \(Overwrite Existing\)/i })).toBeInTheDocument();
    // Radio buttons might be hidden or "Replace Entire Tree" forced checked
    // Based on current ImportDialog, radio buttons are hidden if context="tree"
    expect(screen.queryByLabelText(/Under Selected Item/i)).not.toBeInTheDocument();
    expect(screen.queryByLabelText(/Into empty tree or overwrite existing data/i)).not.toBeInTheDocument();
    expect(screen.getByText(/This will replace your entire current tree/i)).toBeInTheDocument();
  });

  test('enables import button when a file is selected', async () => {
    const user = userEvent.setup();
    render(<ImportDialog {...defaultProps} />);
    const fileInput = screen.getByLabelText(/Select JSON File/i);
    const file = new File(['{"test":"data"}'], 'test.json', { type: 'application/json' });
    
    await user.upload(fileInput, file);
    expect(screen.getByText(/Selected: test.json/i)).toBeInTheDocument();
    expect(screen.getByRole('button', { name: 'Import' })).toBeEnabled();
  });

  test('calls onImport with file and target when Import button is clicked', async () => {
    const user = userEvent.setup();
    mockOnImport.mockResolvedValue({ success: true }); // Mock onImport to resolve
    render(<ImportDialog {...defaultProps} context="item" selectedItem={selectedItemMock} />);
    const fileInput = screen.getByLabelText(/Select JSON File/i);
    const file = new File(['{"id":"1","label":"Test"}'], 'import.json', { type: 'application/json' });
    await user.upload(fileInput, file);
    
    const importButton = screen.getByRole('button', { name: 'Import' });
    await user.click(importButton);

    await waitFor(() => {
      expect(mockOnImport).toHaveBeenCalledWith(file, 'selected'); // 'selected' because context is 'item'
    });
  });

  test('calls onImport with "entire" target if that option is selected', async () => {
    const user = userEvent.setup();
    mockOnImport.mockResolvedValue({ success: true });
     // Render without specific item context to allow radio button choice
    render(<ImportDialog isOpen={true} context="generic" selectedItem={null} onClose={mockOnClose} onImport={mockOnImport} />);
    
    const fileInput = screen.getByLabelText(/Select JSON File/i);
    const file = new File(['[{"id":"1"}]'], 'tree.json', { type: 'application/json' });
    await user.upload(fileInput, file);

    // Select "Replace Entire Tree"
    const entireTreeRadio = screen.getByLabelText(/Into empty tree or overwrite existing data/i);
    await user.click(entireTreeRadio);
    
    const importButton = screen.getByRole('button', { name: 'Import' });
    await user.click(importButton);

    await waitFor(() => {
      expect(mockOnImport).toHaveBeenCalledWith(file, 'entire');
    });
  });


  test('calls onClose when Cancel button is clicked', async () => {
    const user = userEvent.setup();
    render(<ImportDialog {...defaultProps} />);
    await user.click(screen.getByRole('button', { name: /Close/i })); // Changed from Cancel to Close
    expect(mockOnClose).toHaveBeenCalledTimes(1);
  });

  test('displays import message on success', async () => {
    const user = userEvent.setup();
    mockOnImport.mockResolvedValue({ success: true, message: "Test import successful" });
    render(<ImportDialog {...defaultProps} />);
    const fileInput = screen.getByLabelText(/Select JSON File/i);
    const file = new File(['{}'], 'test.json', { type: 'application/json' });
    await user.upload(fileInput, file);
    await user.click(screen.getByRole('button', { name: 'Import' }));

    await waitFor(() => {
      expect(screen.getByText("Test import successful")).toBeInTheDocument();
      expect(screen.getByText("Test import successful")).toHaveClass('bg-green-100');
    });
  });

  test('displays import message on failure', async () => {
    const user = userEvent.setup();
    mockOnImport.mockResolvedValue({ success: false, error: "Test import failed" });
    render(<ImportDialog {...defaultProps} />);
    const fileInput = screen.getByLabelText(/Select JSON File/i);
    const file = new File(['{}'], 'test.json', { type: 'application/json' });
    await user.upload(fileInput, file);
    await user.click(screen.getByRole('button', { name: 'Import' }));

    await waitFor(() => {
      expect(screen.getByText("Test import failed")).toBeInTheDocument();
      expect(screen.getByText("Test import failed")).toHaveClass('bg-red-100');
    });
  });
});

--- tests\components\Login.test.jsx ---
// tests/components/Login.test.jsx
import React from "react";
import { render, screen, fireEvent, waitFor } from "@testing-library/react";
import userEvent from "@testing-library/user-event";
import "@testing-library/jest-dom";
import Login from "../../src/components/Login";

const mockOnLoginSuccess = jest.fn();
const mockOnSwitchToRegister = jest.fn();

// Mock global.fetch
global.fetch = jest.fn();

// Mock VITE_API_BASE_URL
const originalEnv = { ...process.env };
beforeAll(() => {
  process.env.VITE_API_BASE_URL = "http://localhost:5001/api"; // Or your test API URL
});
afterAll(() => {
  process.env = originalEnv; // Restore original env
});

describe("<Login />", () => {
  beforeEach(() => {
    fetch.mockClear();
    mockOnLoginSuccess.mockClear();
    mockOnSwitchToRegister.mockClear();
  });

  test("renders login form correctly", () => {
    render(
      <Login
        onLoginSuccess={mockOnLoginSuccess}
        onSwitchToRegister={mockOnSwitchToRegister}
      />
    );
    expect(
      screen.getByRole("heading", { name: /Login to Notes & Tasks/i })
    ).toBeInTheDocument();
    expect(screen.getByLabelText(/Email Address/i)).toBeInTheDocument();
    expect(screen.getByLabelText(/Password/i)).toBeInTheDocument();
    expect(screen.getByRole("button", { name: /Login/i })).toBeInTheDocument();
    expect(
      screen.getByRole("button", { name: /Create one/i })
    ).toBeInTheDocument();
  });

  test("allows input for email and password", async () => {
    const user = userEvent.setup();
    render(
      <Login
        onLoginSuccess={mockOnLoginSuccess}
        onSwitchToRegister={mockOnSwitchToRegister}
      />
    );

    const emailInput = screen.getByLabelText(/Email Address/i);
    await user.type(emailInput, "test@example.com");
    expect(emailInput).toHaveValue("test@example.com");

    const passwordInput = screen.getByLabelText(/Password/i);
    await user.type(passwordInput, "password123");
    expect(passwordInput).toHaveValue("password123");
  });

  test("shows error message if fields are empty on submit", async () => {
    const user = userEvent.setup();
    render(
      <Login
        onLoginSuccess={mockOnLoginSuccess}
        onSwitchToRegister={mockOnSwitchToRegister}
      />
    );
    const loginButton = screen.getByRole("button", { name: /Login/i });
    await user.click(loginButton);
    expect(
      screen.getByText(/Please enter both email and password/i)
    ).toBeInTheDocument();
    expect(fetch).not.toHaveBeenCalled();
  });

  test("calls onLoginSuccess with user data on successful login", async () => {
    const user = userEvent.setup();
    const mockUserData = { id: "123", email: "test@example.com" };
    fetch.mockResolvedValueOnce({
      ok: true,
      json: async () => ({ token: "fake-jwt-token", user: mockUserData }),
    });

    render(
      <Login
        onLoginSuccess={mockOnLoginSuccess}
        onSwitchToRegister={mockOnSwitchToRegister}
      />
    );
    await user.type(
      screen.getByLabelText(/Email Address/i),
      "test@example.com"
    );
    await user.type(screen.getByLabelText(/Password/i), "password123");
    await user.click(screen.getByRole("button", { name: /Login/i }));

    await waitFor(() => {
      expect(fetch).toHaveBeenCalledWith(
        "http://localhost:5001/api/auth/login",
        expect.any(Object)
      );
      expect(mockOnLoginSuccess).toHaveBeenCalledWith(mockUserData);
    });
    expect(localStorage.getItem("userToken")).toBe("fake-jwt-token");
  });

  test("shows error message on failed login (invalid credentials)", async () => {
    const user = userEvent.setup();
    fetch.mockResolvedValueOnce({
      ok: false,
      status: 401,
      json: async () => ({ error: "Invalid credentials" }),
    });

    render(
      <Login
        onLoginSuccess={mockOnLoginSuccess}
        onSwitchToRegister={mockOnSwitchToRegister}
      />
    );
    await user.type(
      screen.getByLabelText(/Email Address/i),
      "test@example.com"
    );
    await user.type(screen.getByLabelText(/Password/i), "wrongpassword");
    await user.click(screen.getByRole("button", { name: /Login/i }));

    await waitFor(() => {
      expect(screen.getByText(/Invalid credentials/i)).toBeInTheDocument();
    });
    expect(mockOnLoginSuccess).not.toHaveBeenCalled();
  });

  test("shows error message on network error", async () => {
    const user = userEvent.setup();
    fetch.mockRejectedValueOnce(new Error("Network error"));

    render(
      <Login
        onLoginSuccess={mockOnLoginSuccess}
        onSwitchToRegister={mockOnSwitchToRegister}
      />
    );
    await user.type(
      screen.getByLabelText(/Email Address/i),
      "test@example.com"
    );
    await user.type(screen.getByLabelText(/Password/i), "password123");
    await user.click(screen.getByRole("button", { name: /Login/i }));

    await waitFor(() => {
      expect(
        screen.getByText(/Network error or server issue/i)
      ).toBeInTheDocument();
    });
  });

  test('calls onSwitchToRegister when "Create one" button is clicked', async () => {
    const user = userEvent.setup();
    render(
      <Login
        onLoginSuccess={mockOnLoginSuccess}
        onSwitchToRegister={mockOnSwitchToRegister}
      />
    );
    const createAccountButton = screen.getByRole("button", {
      name: /Create one/i,
    });
    await user.click(createAccountButton);
    expect(mockOnSwitchToRegister).toHaveBeenCalledTimes(1);
  });
});


--- tests\components\Register.test.jsx ---
// tests/components/Register.test.jsx
import React from "react";
import { render, screen, fireEvent, waitFor } from "@testing-library/react";
import userEvent from "@testing-library/user-event";
import "@testing-library/jest-dom";
import Register from "../../src/components/Register";

const mockOnRegisterSuccess = jest.fn();
const mockOnSwitchToLogin = jest.fn();

// Mock global.fetch
global.fetch = jest.fn();

// Mock VITE_API_BASE_URL
const originalEnv = { ...process.env };
beforeAll(() => {
  process.env.VITE_API_BASE_URL = "http://localhost:5001/api";
});
afterAll(() => {
  process.env = originalEnv;
});

describe("<Register />", () => {
  beforeEach(() => {
    fetch.mockClear();
    mockOnRegisterSuccess.mockClear();
    mockOnSwitchToLogin.mockClear();
  });

  test("renders registration form correctly", () => {
    render(
      <Register
        onRegisterSuccess={mockOnRegisterSuccess}
        onSwitchToLogin={mockOnSwitchToLogin}
      />
    );
    expect(
      screen.getByRole("heading", { name: /Create Account/i })
    ).toBeInTheDocument();
    expect(screen.getByLabelText(/Email Address/i)).toBeInTheDocument();
    expect(
      screen.getByLabelText(/Password \(min. 8 characters\)/i)
    ).toBeInTheDocument();
    expect(screen.getByLabelText(/Confirm Password/i)).toBeInTheDocument();
    expect(
      screen.getByRole("button", { name: /Create Account/i })
    ).toBeInTheDocument();
    expect(screen.getByRole("button", { name: /Log In/i })).toBeInTheDocument();
  });

  test("shows error if fields are empty on submit", async () => {
    const user = userEvent.setup();
    render(
      <Register
        onRegisterSuccess={mockOnRegisterSuccess}
        onSwitchToLogin={mockOnSwitchToLogin}
      />
    );
    await user.click(screen.getByRole("button", { name: /Create Account/i }));
    expect(screen.getByText(/Please fill in all fields/i)).toBeInTheDocument();
  });

  test("shows error if passwords do not match", async () => {
    const user = userEvent.setup();
    render(
      <Register
        onRegisterSuccess={mockOnRegisterSuccess}
        onSwitchToLogin={mockOnSwitchToLogin}
      />
    );
    await user.type(
      screen.getByLabelText(/Email Address/i),
      "test@example.com"
    );
    await user.type(screen.getByLabelText(/Password/i), "password123");
    await user.type(screen.getByLabelText(/Confirm Password/i), "password456");
    await user.click(screen.getByRole("button", { name: /Create Account/i }));
    expect(screen.getByText(/Passwords do not match/i)).toBeInTheDocument();
  });

  test("shows error if password is too short", async () => {
    const user = userEvent.setup();
    render(
      <Register
        onRegisterSuccess={mockOnRegisterSuccess}
        onSwitchToLogin={mockOnSwitchToLogin}
      />
    );
    await user.type(
      screen.getByLabelText(/Email Address/i),
      "test@example.com"
    );
    await user.type(screen.getByLabelText(/Password/i), "pass");
    await user.type(screen.getByLabelText(/Confirm Password/i), "pass");
    await user.click(screen.getByRole("button", { name: /Create Account/i }));
    expect(
      screen.getByText(/Password must be at least 8 characters long/i)
    ).toBeInTheDocument();
  });

  test("calls onRegisterSuccess on successful registration", async () => {
    const user = userEvent.setup();
    const mockServerResponse = {
      user: { id: "newUser123", email: "test@example.com" },
      token: "new-fake-token",
    }; // Assuming register might also return token
    fetch.mockResolvedValueOnce({
      ok: true,
      json: async () => mockServerResponse,
    });
    window.alert = jest.fn(); // Mock alert

    render(
      <Register
        onRegisterSuccess={mockOnRegisterSuccess}
        onSwitchToLogin={mockOnSwitchToLogin}
      />
    );
    await user.type(
      screen.getByLabelText(/Email Address/i),
      "test@example.com"
    );
    await user.type(screen.getByLabelText(/Password/i), "password123");
    await user.type(screen.getByLabelText(/Confirm Password/i), "password123");
    await user.click(screen.getByRole("button", { name: /Create Account/i }));

    await waitFor(() => {
      expect(fetch).toHaveBeenCalledWith(
        "http://localhost:5001/api/auth/register",
        expect.any(Object)
      );
      expect(mockOnRegisterSuccess).toHaveBeenCalledTimes(1);
      expect(window.alert).toHaveBeenCalledWith(
        "Registration successful! Please log in."
      );
    });
  });

  test("shows server error message on failed registration", async () => {
    const user = userEvent.setup();
    fetch.mockResolvedValueOnce({
      ok: false,
      json: async () => ({ error: "Email already exists" }),
    });
    render(
      <Register
        onRegisterSuccess={mockOnRegisterSuccess}
        onSwitchToLogin={mockOnSwitchToLogin}
      />
    );
    await user.type(
      screen.getByLabelText(/Email Address/i),
      "test@example.com"
    );
    await user.type(screen.getByLabelText(/Password/i), "password123");
    await user.type(screen.getByLabelText(/Confirm Password/i), "password123");
    await user.click(screen.getByRole("button", { name: /Create Account/i }));

    await waitFor(() => {
      expect(screen.getByText(/Email already exists/i)).toBeInTheDocument();
    });
  });

  test('calls onSwitchToLogin when "Log In" button is clicked', async () => {
    const user = userEvent.setup();
    render(
      <Register
        onRegisterSuccess={mockOnRegisterSuccess}
        onSwitchToLogin={mockOnSwitchToLogin}
      />
    );
    await user.click(screen.getByRole("button", { name: /Log In/i }));
    expect(mockOnSwitchToLogin).toHaveBeenCalledTimes(1);
  });
});


--- tests\components\RenameDialog.test.jsx ---
// tests/components/RenameDialog.test.jsx
import React from "react";
import { render, screen, fireEvent } from "@testing-library/react";
import "@testing-library/jest-dom";
import RenameDialog from "../../src/components/RenameDialog";

describe("<RenameDialog />", () => {
  const mockOnNameChange = jest.fn();
  const mockOnRename = jest.fn();
  const mockOnCancel = jest.fn();

  const defaultProps = {
    isOpen: true,
    item: { id: "1", label: "Old Label" },
    newName: "Old Label",
    onNameChange: mockOnNameChange,
    onRename: mockOnRename,
    onCancel: mockOnCancel,
  };

  beforeEach(() => {
    mockOnNameChange.mockClear();
    mockOnRename.mockClear();
    mockOnCancel.mockClear();
  });

  test("does not render when isOpen is false", () => {
    const { container } = render(
      <RenameDialog {...defaultProps} isOpen={false} />
    );
    expect(container.firstChild).toBeNull();
  });

  test("renders correct title with item label", () => {
    render(<RenameDialog {...defaultProps} />);
    expect(
      screen.getByRole("heading", { name: /Rename “Old Label”/i })
    ).toBeInTheDocument();
  });

  test("renders input with current name, calls onNameChange, and focuses input", () => {
    render(<RenameDialog {...defaultProps} />);
    const input = screen.getByDisplayValue("Old Label");
    expect(input).toBeInTheDocument();
    expect(input).toHaveFocus(); // autoFocus should work

    fireEvent.change(input, { target: { value: "New Label Value" } });
    expect(mockOnNameChange).toHaveBeenCalledTimes(1);
    // The event object itself is passed, so checking e.target.value is fine if needed by the handler
    // expect(mockOnNameChange).toHaveBeenCalledWith(expect.objectContaining({ target: { value: 'New Label Value' } }));
  });

  test("calls onCancel when Cancel button is clicked", () => {
    render(<RenameDialog {...defaultProps} />);
    fireEvent.click(screen.getByRole("button", { name: /Cancel/i }));
    expect(mockOnCancel).toHaveBeenCalledTimes(1);
  });

  test("calls onRename when Rename button is clicked", () => {
    render(<RenameDialog {...defaultProps} />);
    fireEvent.click(screen.getByRole("button", { name: /Rename/i }));
    expect(mockOnRename).toHaveBeenCalledTimes(1);
  });

  test("calls onRename when form is submitted", () => {
    render(<RenameDialog {...defaultProps} />);
    const form = screen
      .getByRole("button", { name: /Rename/i })
      .closest("form");
    if (!form) throw new Error("Form not found");
    fireEvent.submit(form);
    expect(mockOnRename).toHaveBeenCalledTimes(1);
  });
});


--- tests\components\SettingsDialog.test.jsx ---
// tests/components/SettingsDialog.test.jsx
import React from "react";
import { render, screen } from "@testing-library/react"; // fireEvent removed if not directly used
import userEvent from "@testing-library/user-event";
import "@testing-library/jest-dom";
import SettingsDialog from "../../src/components/SettingsDialog";
import {
  SettingsContext,
  defaultSettings,
} from "../../src/contexts/SettingsContext";

const mockUpdateSetting = jest.fn();
const mockResetSettings = jest.fn();
const mockResetApplicationData = jest.fn();

const customRender = (ui, { providerProps, ...renderOptions }) => {
  return render(
    <SettingsContext.Provider value={providerProps}>
      {ui}
    </SettingsContext.Provider>,
    renderOptions
  );
};

describe("<SettingsDialog />", () => {
  let providerProps;
  const originalConfirm = window.confirm;

  beforeEach(() => {
    mockUpdateSetting.mockClear();
    mockResetSettings.mockClear();
    mockResetApplicationData.mockClear();
    providerProps = {
      settings: { ...defaultSettings },
      updateSetting: mockUpdateSetting,
      resetSettings: mockResetSettings,
      resetApplicationData: mockResetApplicationData,
    };
    window.confirm = jest.fn(() => true); // Mock window.confirm
  });

  afterEach(() => {
    window.confirm = originalConfirm; // Restore window.confirm
  });

  test("does not render when isOpen is false", () => {
    const { container } = customRender(
      <SettingsDialog isOpen={false} onClose={jest.fn()} />,
      { providerProps }
    );
    expect(container.firstChild).toBeNull();
  });

  test("renders correctly when isOpen is true", () => {
    customRender(<SettingsDialog isOpen={true} onClose={jest.fn()} />, {
      providerProps,
    });
    expect(screen.getByTestId("settings-dialog-overlay")).toBeInTheDocument();
    expect(screen.getByTestId("settings-dialog-content")).toBeInTheDocument();
    expect(
      screen.getByRole("heading", { name: /Settings/i })
    ).toBeInTheDocument();
    // ... (other getByTestId checks for rows as in your original)
    expect(screen.getByTestId("setting-row-theme")).toBeInTheDocument();
    expect(
      screen.getByTestId("setting-row-autoExpandNewFolders")
    ).toBeInTheDocument();
  });

  test("calls onClose when header Close button is clicked", async () => {
    const mockOnClose = jest.fn();
    customRender(<SettingsDialog isOpen={true} onClose={mockOnClose} />, {
      providerProps,
    });
    await userEvent.click(screen.getByTestId("settings-close-button-header"));
    expect(mockOnClose).toHaveBeenCalledTimes(1);
  });

  test("calls onClose when footer Close button is clicked", async () => {
    const mockOnClose = jest.fn();
    customRender(<SettingsDialog isOpen={true} onClose={mockOnClose} />, {
      providerProps,
    });
    await userEvent.click(screen.getByTestId("settings-close-button-footer"));
    expect(mockOnClose).toHaveBeenCalledTimes(1);
  });

  test("updates theme setting when selection changes", async () => {
    customRender(<SettingsDialog isOpen={true} onClose={jest.fn()} />, {
      providerProps,
    });
    const themeSelect = screen.getByTestId("setting-theme-select");
    await userEvent.selectOptions(themeSelect, "dark");
    expect(mockUpdateSetting).toHaveBeenCalledWith("theme", "dark");
  });

  test("updates autoExpand setting when checkbox is clicked", async () => {
    customRender(<SettingsDialog isOpen={true} onClose={jest.fn()} />, {
      providerProps,
    });
    const checkbox = screen.getByTestId("setting-autoexpand-checkbox");
    expect(checkbox).toBeChecked(); // Default is true
    await userEvent.click(checkbox);
    expect(mockUpdateSetting).toHaveBeenCalledWith(
      "autoExpandNewFolders",
      false
    );
  });

  // ... (other specific setting change tests like fontFamily, fontSize, exportFormat as in your original)

  test("filters settings based on search term in label", async () => {
    customRender(<SettingsDialog isOpen={true} onClose={jest.fn()} />, {
      providerProps,
    });
    const searchInput = screen.getByTestId("settings-search-input");
    await userEvent.type(searchInput, "Theme");
    expect(screen.getByTestId("setting-row-theme")).toBeInTheDocument();
    expect(
      screen.queryByTestId("setting-row-autoExpandNewFolders")
    ).not.toBeInTheDocument();
  });

  test('displays "No settings found" message when search yields no results', async () => {
    customRender(<SettingsDialog isOpen={true} onClose={jest.fn()} />, {
      providerProps,
    });
    const searchInput = screen.getByTestId("settings-search-input");
    await userEvent.type(searchInput, "xyznonexistentxyz");
    expect(screen.getByTestId("settings-no-results")).toBeInTheDocument();
  });

  test("calls resetSettings when Reset Settings button is clicked and confirmed", async () => {
    customRender(<SettingsDialog isOpen={true} onClose={jest.fn()} />, {
      providerProps,
    });
    await userEvent.click(screen.getByTestId("setting-resetsettings-button"));
    expect(window.confirm).toHaveBeenCalledWith(
      expect.stringContaining("reset all settings")
    );
    expect(mockResetSettings).toHaveBeenCalledTimes(1);
  });

  test("calls resetApplicationData when Reset All Data button is clicked and confirmed", async () => {
    customRender(<SettingsDialog isOpen={true} onClose={jest.fn()} />, {
      providerProps,
    });
    await userEvent.click(screen.getByTestId("setting-resetdata-button"));
    expect(window.confirm).toHaveBeenCalledWith(
      expect.stringContaining("WARNING: This will permanently delete")
    );
    expect(mockResetApplicationData).toHaveBeenCalledTimes(1);
  });

  test("does NOT call resetSettings if confirm is cancelled", async () => {
    window.confirm.mockImplementationOnce(() => false); // Override for this test
    customRender(<SettingsDialog isOpen={true} onClose={jest.fn()} />, {
      providerProps,
    });
    await userEvent.click(screen.getByTestId("setting-resetsettings-button"));
    expect(window.confirm).toHaveBeenCalled();
    expect(mockResetSettings).not.toHaveBeenCalled();
  });
});


--- tests\components\TaskItem.test.jsx ---
// tests/components/TaskItem.test.jsx
import React from "react";
import { render, screen, fireEvent } from "@testing-library/react";
import "@testing-library/jest-dom";
import TaskItem from "../../src/components/TaskItem";

describe("<TaskItem /> Component", () => {
  const mockToggle = jest.fn();

  beforeEach(() => {
    mockToggle.mockClear();
  });

  test("returns null if no task prop is provided", () => {
    const { container } = render(<TaskItem onToggle={mockToggle} />);
    expect(container.firstChild).toBeNull();
  });

  test("renders task label and unchecked checkbox for incomplete task", () => {
    const task = {
      id: "t1",
      type: "task",
      label: "Test Task Incomplete",
      completed: false,
    };
    render(<TaskItem task={task} onToggle={mockToggle} />);
    const checkbox = screen.getByRole("checkbox");
    const label = screen.getByText(task.label);
    expect(checkbox).not.toBeChecked();
    expect(label).not.toHaveClass("line-through");
  });

  test("renders task label and checked checkbox for completed task", () => {
    const task = {
      id: "t2",
      type: "task",
      label: "Test Task Complete",
      completed: true,
    };
    render(<TaskItem task={task} onToggle={mockToggle} />);
    const checkbox = screen.getByRole("checkbox");
    const label = screen.getByText(task.label);
    expect(checkbox).toBeChecked();
    expect(label).toHaveClass("line-through");
  });

  test("calls onToggle with true when incomplete task checkbox is clicked", () => {
    const task = {
      id: "t1",
      type: "task",
      label: "Test Task",
      completed: false,
    };
    render(<TaskItem task={task} onToggle={mockToggle} />);
    fireEvent.click(screen.getByRole("checkbox"));
    expect(mockToggle).toHaveBeenCalledWith(true);
  });

  test("calls onToggle with false when completed task checkbox is clicked", () => {
    const task = {
      id: "t2",
      type: "task",
      label: "Test Task",
      completed: true,
    };
    render(<TaskItem task={task} onToggle={mockToggle} />);
    fireEvent.click(screen.getByRole("checkbox"));
    expect(mockToggle).toHaveBeenCalledWith(false);
  });

  test("calls onToggle when label is clicked", () => {
    const task = {
      id: "t1",
      type: "task",
      label: "Clickable Label",
      completed: false,
    };
    render(<TaskItem task={task} onToggle={mockToggle} />);
    fireEvent.click(screen.getByText(task.label));
    expect(mockToggle).toHaveBeenCalledWith(true);
  });
});


--- tests\components\Tree.test.jsx ---
// tests/components/Tree.test.jsx
import React from "react";
import { render, screen, fireEvent } from "@testing-library/react";
import userEvent from "@testing-library/user-event";
import "@testing-library/jest-dom";
import Tree from "../../src/components/Tree";

// Mock lucide-react MoreVertical icon
jest.mock("lucide-react", () => ({
  ...jest.requireActual("lucide-react"), // Import and retain default behavior
  MoreVertical: () => <svg data-testid="icon-more-vertical" />,
}));

const mockHandlers = {
  onSelect: jest.fn(),
  onToggleExpand: jest.fn(),
  onToggleTask: jest.fn(),
  onDragStart: jest.fn(),
  onDrop: jest.fn(),
  onNativeContextMenu: jest.fn(), // Updated prop name
  onShowItemMenu: jest.fn(), // New prop for button menu
  onRename: jest.fn(), // This is for initiating rename (e.g. F2 or dblclick)
  onAttemptRename: jest.fn(), // For when inline input blurs or Enter pressed
  cancelInlineRename: jest.fn(),
  setInlineRenameValue: jest.fn(),
  onDragEnd: jest.fn(),
  setUiError: jest.fn(),
};

const sampleItems = [
  {
    id: "f1",
    type: "folder",
    label: "Folder 1",
    children: [
      { id: "f1-n1", type: "note", label: "Note 1.1" },
      { id: "f1-t1", type: "task", label: "Task 1.1", completed: true },
    ],
  },
  { id: "f2", type: "folder", label: "Folder 2", children: [] },
  { id: "n1", type: "note", label: "Note Alpha" }, // Changed for sort testing
  { id: "t1", type: "task", label: "Task Beta", completed: false },
];

describe("<Tree /> Component", () => {
  let user;

  beforeEach(() => {
    user = userEvent.setup();
    Object.values(mockHandlers).forEach((mock) => mock.mockClear());
  });

  const defaultProps = {
    items: [],
    selectedItemId: null,
    inlineRenameId: null,
    inlineRenameValue: "",
    expandedFolders: {},
    draggedId: null,
    uiError: "",
    ...mockHandlers,
  };

  test("renders navigation role", () => {
    render(<Tree {...defaultProps} />);
    expect(
      screen.getByRole("navigation", { name: "Notes and Tasks Tree" })
    ).toBeInTheDocument();
  });

  test("renders and sorts top-level items correctly", () => {
    render(<Tree {...defaultProps} items={sampleItems} />);
    // Items are sorted: Folder 1, Folder 2, Note Alpha, Task Beta
    const renderedItems = screen.getAllByRole("listitem");
    expect(renderedItems[0]).toHaveTextContent("Folder 1");
    expect(renderedItems[1]).toHaveTextContent("Folder 2");
    expect(renderedItems[2]).toHaveTextContent("Note Alpha");
    expect(renderedItems[3]).toHaveTextContent("Task Beta");
  });

  test("calls onSelect when an item main div is clicked", async () => {
    render(<Tree {...defaultProps} items={sampleItems} />);
    // Find the div that handles selection click (not buttons within the item)
    const noteItemDiv = screen
      .getByText("Note Alpha")
      .closest('div[role="button"]'); // The div that has the onClick for selection
    if (!noteItemDiv)
      throw new Error("Clickable div for 'Note Alpha' not found");
    await user.click(noteItemDiv);
    expect(mockHandlers.onSelect).toHaveBeenCalledWith("n1");
  });

  test("calls onToggleExpand when folder expand button is clicked", async () => {
    render(<Tree {...defaultProps} items={sampleItems} expandedFolders={{}} />);
    const folder1Item = screen.getByText("Folder 1").closest("li");
    const expandButton = within(folder1Item).getByRole("button", {
      name: /Expand Folder 1/i,
    });
    await user.click(expandButton);
    expect(mockHandlers.onToggleExpand).toHaveBeenCalledWith("f1");
  });

  test("calls onToggleTask when task checkbox area is clicked", async () => {
    render(<Tree {...defaultProps} items={sampleItems} />);
    const taskItem = screen.getByText("Task Beta").closest("li");
    // The checkbox itself is a button in the implementation
    const checkboxButton = within(taskItem).getByRole("checkbox", {
      name: /Mark task Task Beta as complete/i,
    });
    await user.click(checkboxButton);
    expect(mockHandlers.onToggleTask).toHaveBeenCalledWith("t1", true); // true because initial was false
  });

  test("calls onShowItemMenu when more options button is clicked", async () => {
    render(<Tree {...defaultProps} items={sampleItems} />);
    const noteItem = screen.getByText("Note Alpha").closest("li");
    const moreButton = within(noteItem).getByRole("button", {
      name: /More options for Note Alpha/i,
    });
    await user.click(moreButton);
    expect(mockHandlers.onShowItemMenu).toHaveBeenCalledWith(
      expect.objectContaining({ id: "n1", label: "Note Alpha" }), // The item object
      expect.any(HTMLElement) // The button element
    );
  });

  test("calls onNativeContextMenu when tree area is right-clicked (empty area)", async () => {
    render(<Tree {...defaultProps} items={sampleItems} />);
    const treeNav = screen.getByRole("navigation", {
      name: "Notes and Tasks Tree",
    });
    fireEvent.contextMenu(treeNav);
    expect(mockHandlers.onSelect).toHaveBeenCalledWith(null); // Selects null for empty area
    expect(mockHandlers.onNativeContextMenu).toHaveBeenCalledWith(
      expect.any(Object),
      null
    );
  });

  test("calls onNativeContextMenu when an item is right-clicked", async () => {
    render(<Tree {...defaultProps} items={sampleItems} />);
    const noteItemLi = screen.getByText("Note Alpha").closest("li");
    if (!noteItemLi) throw new Error("Note Alpha list item not found");
    fireEvent.contextMenu(noteItemLi);
    expect(mockHandlers.onSelect).toHaveBeenCalledWith("n1"); // Selects the item first
    expect(mockHandlers.onNativeContextMenu).toHaveBeenCalledWith(
      expect.any(Object), // The event
      expect.objectContaining({ id: "n1" }) // The item
    );
  });

  test("renders inline rename input when inlineRenameId matches an item", () => {
    render(
      <Tree
        {...defaultProps}
        items={sampleItems}
        inlineRenameId="n1"
        inlineRenameValue="Renaming Note"
      />
    );
    const input = screen.getByDisplayValue("Renaming Note");
    expect(input).toBeInTheDocument();
    expect(input.tagName).toBe("INPUT");
    // The original label "Note Alpha" should not be visible for this item
    expect(
      screen.queryByText("Note Alpha", { selector: "span" })
    ).not.toBeInTheDocument();
  });

  test("displays uiError message when inline renaming and error exists", () => {
    const errorMessage = "Name conflict!";
    render(
      <Tree
        {...defaultProps}
        items={sampleItems}
        inlineRenameId="n1"
        uiError={errorMessage}
      />
    );
    expect(screen.getByText(errorMessage)).toBeInTheDocument();
    // Check ARIA attributes on the input
    const input = screen.getByRole("textbox"); // Assuming rename input becomes a textbox
    expect(input).toHaveAttribute("aria-invalid", "true");
    expect(input).toHaveAttribute("aria-describedby", "n1-rename-error");
  });
});


--- tests\components\AboutDialog.test.jsx ---
// tests/components/AboutDialog.test.jsx
import React from "react";
import { render, screen, fireEvent } from "@testing-library/react";
import "@testing-library/jest-dom";
import AboutDialog from "../../src/components/AboutDialog";
// Ensure package.json is correctly resolved relative to this test file, or mock it
// For simplicity, let's assume a mock or that the path is correct.
// If it causes issues, you might need to configure Jest's moduleNameMapper or mock package.json
let packageJson;
try {
  packageJson = require("../../package.json");
} catch (e) {
  // Mock if package.json is not found at that relative path during testing
  console.warn(
    "package.json not found for AboutDialog test, using mock version."
  );
  packageJson = { version: "1.0.0-test" };
}

describe("<AboutDialog />", () => {
  const mockOnClose = jest.fn();
  const originalGetFullYear = Date.prototype.getFullYear;

  beforeEach(() => {
    mockOnClose.mockClear();
    // Mock current year for consistent testing
    Date.prototype.getFullYear = jest.fn(() => 2025);
  });

  afterEach(() => {
    Date.prototype.getFullYear = originalGetFullYear; // Restore original Date object
  });

  test("does not render when isOpen is false", () => {
    const { container } = render(
      <AboutDialog isOpen={false} onClose={mockOnClose} />
    );
    expect(container.firstChild).toBeNull();
  });

  test("renders correctly when isOpen is true", () => {
    render(<AboutDialog isOpen={true} onClose={mockOnClose} />);
    expect(
      screen.getByRole("heading", { name: /About Notes & Tasks App/i })
    ).toBeInTheDocument();
    expect(screen.getByText(/Notes & Tasks App © 2025/)).toBeInTheDocument();
    expect(
      screen.getByText(new RegExp(`Version: ${packageJson.version}`))
    ).toBeInTheDocument();
    expect(screen.getByRole("button", { name: /Close/i })).toBeInTheDocument();
  });

  test("calls onClose when Close button is clicked", () => {
    render(<AboutDialog isOpen={true} onClose={mockOnClose} />);
    const closeButton = screen.getByRole("button", { name: /Close/i });
    fireEvent.click(closeButton);
    expect(mockOnClose).toHaveBeenCalledTimes(1);
  });

  test("modal overlay is present", () => {
    render(<AboutDialog isOpen={true} onClose={mockOnClose} />);
    const overlay = screen
      .getByRole("button", { name: /Close/i })
      .closest("div.fixed.inset-0");
    expect(overlay).toHaveClass("bg-black", "bg-opacity-50");
  });

  test("close button is focused on open", () => {
    render(<AboutDialog isOpen={true} onClose={mockOnClose} />);
    expect(screen.getByRole("button", { name: /Close/i })).toHaveFocus();
  });
});


--- tests\components\AddDialog.test.jsx ---
// tests/components/AddDialog.test.jsx
import React from "react";
import { render, screen, fireEvent, waitFor } from "@testing-library/react";
import "@testing-library/jest-dom";
import AddDialog from "../../src/components/AddDialog";

describe("<AddDialog />", () => {
  const mockOnLabelChange = jest.fn();
  const mockOnAdd = jest.fn();
  const mockOnCancel = jest.fn();

  const defaultProps = {
    isOpen: true,
    newItemType: "folder",
    newItemLabel: "",
    errorMessage: "",
    onLabelChange: mockOnLabelChange,
    onAdd: mockOnAdd,
    onCancel: mockOnCancel,
  };

  beforeEach(() => {
    mockOnLabelChange.mockClear();
    mockOnAdd.mockClear();
    mockOnCancel.mockClear();
  });

  test("does not render when isOpen is false", () => {
    const { container } = render(
      <AddDialog {...defaultProps} isOpen={false} />
    );
    expect(container.firstChild).toBeNull();
  });

  test("renders correct title based on newItemType", () => {
    const { rerender } = render(
      <AddDialog {...defaultProps} newItemType="folder" />
    );
    expect(
      screen.getByRole("heading", { name: /Add folder/i })
    ).toBeInTheDocument();

    rerender(<AddDialog {...defaultProps} newItemType="note" />);
    expect(
      screen.getByRole("heading", { name: /Add note/i })
    ).toBeInTheDocument();

    rerender(<AddDialog {...defaultProps} newItemType="task" />);
    expect(
      screen.getByRole("heading", { name: /Add task/i })
    ).toBeInTheDocument();
  });

  test("renders input, calls onLabelChange, and focuses input", async () => {
    render(<AddDialog {...defaultProps} />);
    const input = screen.getByPlaceholderText(/Enter folder name/i);
    expect(input).toBeInTheDocument();
    await waitFor(() => expect(input).toHaveFocus());
    expect(input).toHaveValue("");

    fireEvent.change(input, { target: { value: "New Folder Name" } });
    expect(mockOnLabelChange).toHaveBeenCalledTimes(1);
  });

  test("displays specific error message when errorMessage prop is set", () => {
    const errorText = "Duplicate name detected!";
    render(<AddDialog {...defaultProps} errorMessage={errorText} />);
    expect(screen.getByText(errorText)).toBeInTheDocument();
    const input = screen.getByPlaceholderText(/Enter folder name/i);
    expect(input).toHaveAttribute("aria-invalid", "true");
    expect(input).toHaveAttribute("aria-describedby", "add-error-message");
    expect(input).toHaveClass("border-red-500");
  });

  test("does not display error message when errorMessage is empty", () => {
    render(<AddDialog {...defaultProps} errorMessage="" />);
    const errorParagraph = screen.queryByText("Duplicate name detected!"); // Example error text
    expect(errorParagraph).not.toBeInTheDocument();
    const input = screen.getByPlaceholderText(/Enter folder name/i);
    expect(input).not.toHaveAttribute("aria-invalid", "true");
    expect(input).not.toHaveAttribute("aria-describedby");
    expect(input).not.toHaveClass("border-red-500");
  });

  test("calls onCancel when Cancel button is clicked", () => {
    render(<AddDialog {...defaultProps} />);
    fireEvent.click(screen.getByRole("button", { name: /Cancel/i }));
    expect(mockOnCancel).toHaveBeenCalledTimes(1);
  });

  test("calls onAdd when Add button is clicked", () => {
    render(<AddDialog {...defaultProps} newItemLabel="Valid Name" />);
    fireEvent.click(screen.getByRole("button", { name: /Add/i }));
    expect(mockOnAdd).toHaveBeenCalledTimes(1);
  });

  test("calls onAdd when form is submitted", () => {
    render(<AddDialog {...defaultProps} newItemLabel="Valid Name" />);
    const form = screen.getByRole("button", { name: /Add/i }).closest("form");
    if (!form) throw new Error("Could not find form element");
    fireEvent.submit(form);
    expect(mockOnAdd).toHaveBeenCalledTimes(1);
  });
});


--- tests\components\ContextMenu.test.jsx ---
// tests/components/ContextMenu.test.jsx
import React from "react";
import { render, screen, fireEvent } from "@testing-library/react";
import "@testing-library/jest-dom";
import ContextMenu from "../../src/components/ContextMenu";

jest.mock("lucide-react", () => ({
  Scissors: () => <svg data-testid="icon-scissors" />,
  Copy: () => <svg data-testid="icon-copy" />,
  ClipboardPaste: () => <svg data-testid="icon-paste" />,
  Upload: () => <svg data-testid="icon-upload" />,
  Download: () => <svg data-testid="icon-download" />,
}));

describe("<ContextMenu />", () => {
  const mockHandlers = {
    onAddRootFolder: jest.fn(),
    onAddFolder: jest.fn(),
    onAddNote: jest.fn(),
    onAddTask: jest.fn(),
    onRename: jest.fn(),
    onDelete: jest.fn(),
    onCopy: jest.fn(),
    onCut: jest.fn(),
    onPaste: jest.fn(),
    onDuplicate: jest.fn(),
    onExportItem: jest.fn(),
    onImportItem: jest.fn(),
    onExportTree: jest.fn(),
    onImportTree: jest.fn(),
    onClose: jest.fn(),
  };
  const folderItem = { id: "f1", type: "folder", label: "My Folder" };
  const noteItem = { id: "n1", type: "note", label: "My Note" };
  const clipboardItemMock = {
    id: "clip1",
    type: "note",
    label: "Clipped Note",
  };
  const defaultProps = {
    visible: true,
    x: 100,
    y: 150,
    item: null,
    isEmptyArea: false,
    clipboardItem: null,
    ...mockHandlers,
  };

  beforeEach(() => jest.clearAllMocks());

  test("does not render when visible is false", () => {
    const { container } = render(
      <ContextMenu {...defaultProps} visible={false} />
    );
    expect(container.firstChild).toBeNull();
  });

  test("renders at correct position", () => {
    render(
      <ContextMenu {...defaultProps} item={noteItem} isEmptyArea={false} />
    );
    const menu = screen
      .getByRole("button", { name: /Rename/i })
      .closest('div[class*="fixed"]');
    expect(menu).toHaveStyle(`top: ${defaultProps.y}px`);
    expect(menu).toHaveStyle(`left: ${defaultProps.x}px`);
  });

  describe("When isEmptyArea is true", () => {
    test("renders correct empty area actions", () => {
      const { rerender } = render(
        <ContextMenu
          {...defaultProps}
          isEmptyArea={true}
          item={null}
          clipboardItem={null}
        />
      );
      expect(
        screen.getByRole("button", { name: /Add Root Folder/i })
      ).toBeInTheDocument();
      expect(
        screen.getByRole("button", { name: /Export Full Tree/i })
      ).toBeInTheDocument();
      expect(
        screen.getByRole("button", { name: /Import Full Tree/i })
      ).toBeInTheDocument();
      expect(
        screen.queryByRole("button", { name: /Paste/i })
      ).not.toBeInTheDocument();

      rerender(
        <ContextMenu
          {...defaultProps}
          isEmptyArea={true}
          item={null}
          clipboardItem={clipboardItemMock}
        />
      );
      expect(
        screen.getByRole("button", { name: /Paste/i })
      ).toBeInTheDocument();
    });
    test("calls correct handlers for empty area actions", () => {
      render(
        <ContextMenu
          {...defaultProps}
          isEmptyArea={true}
          item={null}
          clipboardItem={clipboardItemMock}
        />
      );
      fireEvent.click(screen.getByRole("button", { name: /Add Root Folder/i }));
      expect(mockHandlers.onAddRootFolder).toHaveBeenCalledTimes(1);
      fireEvent.click(screen.getByRole("button", { name: /Paste/i }));
      expect(mockHandlers.onPaste).toHaveBeenCalledTimes(1);
      fireEvent.click(
        screen.getByRole("button", { name: /Export Full Tree/i })
      );
      expect(mockHandlers.onExportTree).toHaveBeenCalledTimes(1);
      fireEvent.click(
        screen.getByRole("button", { name: /Import Full Tree/i })
      );
      expect(mockHandlers.onImportTree).toHaveBeenCalledTimes(1);
      expect(mockHandlers.onClose).toHaveBeenCalledTimes(4);
    });
  });

  describe("When item is a folder", () => {
    test("renders all folder actions", () => {
      const { rerender } = render(
        <ContextMenu
          {...defaultProps}
          isEmptyArea={false}
          item={folderItem}
          clipboardItem={null}
        />
      );
      expect(
        screen.getByRole("button", { name: /Add Folder Here/i })
      ).toBeInTheDocument();
      expect(
        screen.getByRole("button", { name: /Add Note Here/i })
      ).toBeInTheDocument();
      expect(
        screen.getByRole("button", { name: /Add Task Here/i })
      ).toBeInTheDocument();
      expect(
        screen.getByRole("button", { name: /Import under Item/i })
      ).toBeInTheDocument();
      expect(
        screen.queryByRole("button", { name: /Paste Here/i })
      ).not.toBeInTheDocument();
      rerender(
        <ContextMenu
          {...defaultProps}
          isEmptyArea={false}
          item={folderItem}
          clipboardItem={clipboardItemMock}
        />
      );
      expect(
        screen.getByRole("button", { name: /Paste Here/i })
      ).toBeInTheDocument();
    });
    test("calls correct handlers for folder actions", () => {
      render(
        <ContextMenu
          {...defaultProps}
          isEmptyArea={false}
          item={folderItem}
          clipboardItem={clipboardItemMock}
        />
      );
      fireEvent.click(screen.getByRole("button", { name: /Add Folder Here/i }));
      expect(mockHandlers.onAddFolder).toHaveBeenCalledTimes(1);
      fireEvent.click(screen.getByRole("button", { name: /Add Note Here/i }));
      expect(mockHandlers.onAddNote).toHaveBeenCalledTimes(1);
      fireEvent.click(screen.getByRole("button", { name: /Add Task Here/i }));
      expect(mockHandlers.onAddTask).toHaveBeenCalledTimes(1);
      fireEvent.click(screen.getByRole("button", { name: /Cut/i }));
      expect(mockHandlers.onCut).toHaveBeenCalledTimes(1);
      fireEvent.click(screen.getByRole("button", { name: /Copy/i }));
      expect(mockHandlers.onCopy).toHaveBeenCalledTimes(1);
      fireEvent.click(screen.getByRole("button", { name: /Duplicate/i }));
      expect(mockHandlers.onDuplicate).toHaveBeenCalledTimes(1);
      fireEvent.click(screen.getByRole("button", { name: /Paste Here/i }));
      expect(mockHandlers.onPaste).toHaveBeenCalledTimes(1);
      fireEvent.click(screen.getByRole("button", { name: /Export Item/i }));
      expect(mockHandlers.onExportItem).toHaveBeenCalledTimes(1);
      fireEvent.click(
        screen.getByRole("button", { name: /Import under Item/i })
      );
      expect(mockHandlers.onImportItem).toHaveBeenCalledTimes(1);
      fireEvent.click(screen.getByRole("button", { name: /Rename/i }));
      expect(mockHandlers.onRename).toHaveBeenCalledTimes(1);
      fireEvent.click(screen.getByRole("button", { name: /Delete/i }));
      expect(mockHandlers.onDelete).toHaveBeenCalledTimes(1);
      expect(mockHandlers.onClose).toHaveBeenCalledTimes(11);
    });
  });

  describe("When item is a note/task", () => {
    test("renders note/task actions (no add/paste/import)", () => {
      render(
        <ContextMenu
          {...defaultProps}
          isEmptyArea={false}
          item={noteItem}
          clipboardItem={clipboardItemMock}
        />
      );
      expect(
        screen.queryByRole("button", { name: /Add Folder Here/i })
      ).not.toBeInTheDocument();
      expect(
        screen.queryByRole("button", { name: /Paste Here/i })
      ).not.toBeInTheDocument();
      expect(
        screen.queryByRole("button", { name: /Import under Item/i })
      ).not.toBeInTheDocument();
      expect(screen.getByRole("button", { name: /Cut/i })).toBeInTheDocument();
    });
    test("calls correct handlers for note/task actions", () => {
      render(
        <ContextMenu {...defaultProps} isEmptyArea={false} item={noteItem} />
      );
      fireEvent.click(screen.getByRole("button", { name: /Cut/i }));
      expect(mockHandlers.onCut).toHaveBeenCalledTimes(1);
      fireEvent.click(screen.getByRole("button", { name: /Copy/i }));
      expect(mockHandlers.onCopy).toHaveBeenCalledTimes(1);
      fireEvent.click(screen.getByRole("button", { name: /Duplicate/i }));
      expect(mockHandlers.onDuplicate).toHaveBeenCalledTimes(1);
      fireEvent.click(screen.getByRole("button", { name: /Export Item/i }));
      expect(mockHandlers.onExportItem).toHaveBeenCalledTimes(1);
      fireEvent.click(screen.getByRole("button", { name: /Rename/i }));
      expect(mockHandlers.onRename).toHaveBeenCalledTimes(1);
      fireEvent.click(screen.getByRole("button", { name: /Delete/i }));
      expect(mockHandlers.onDelete).toHaveBeenCalledTimes(1);
      expect(mockHandlers.onClose).toHaveBeenCalledTimes(6);
    });
  });

  test("calls onClose when clicking outside", () => {
    render(
      <div>
        <ContextMenu {...defaultProps} item={noteItem} /> Outside{" "}
      </div>
    );
    fireEvent.mouseDown(screen.getByText("Outside"));
    expect(mockHandlers.onClose).toHaveBeenCalledTimes(1);
  });
  test("calls onClose when Escape key is pressed", () => {
    render(<ContextMenu {...defaultProps} item={noteItem} />);
    fireEvent.keyDown(document.body, { key: "Escape", code: "Escape" });
    expect(mockHandlers.onClose).toHaveBeenCalledTimes(1);
  });
});


--- tests\components\ExportDialog.test.jsx ---
// tests/components/ExportDialog.test.jsx
import React from 'react';
import { render, screen, fireEvent } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import '@testing-library/jest-dom';
import ExportDialog from '../../src/components/ExportDialog';

describe('<ExportDialog />', () => {
  const mockOnClose = jest.fn();
  const mockOnExport = jest.fn();

  const defaultProps = {
    isOpen: true,
    context: null, // Generic context, allows choosing target
    defaultFormat: 'json',
    onClose: mockOnClose,
    onExport: mockOnExport,
  };

  beforeEach(() => {
    mockOnClose.mockClear();
    mockOnExport.mockClear();
  });

  test('does not render when isOpen is false', () => {
    const { container } = render(<ExportDialog {...defaultProps} isOpen={false} />);
    expect(container.firstChild).toBeNull();
  });

  test('renders correctly with default props (generic context)', () => {
    render(<ExportDialog {...defaultProps} />);
    expect(screen.getByRole('heading', { name: /Export Options/i })).toBeInTheDocument();
    expect(screen.getByLabelText(/Selected Item/i)).toBeChecked(); // Default target
    expect(screen.getByLabelText(/JSON/i)).toBeChecked(); // Default format
    expect(screen.getByRole('button', { name: /Export as JSON/i })).toBeInTheDocument();
  });

  test('renders correctly for "item" context', () => {
    render(<ExportDialog {...defaultProps} context="item" />);
    expect(screen.getByRole('heading', { name: /Export Selected Item/i })).toBeInTheDocument();
    // Target radio buttons should not be shown
    expect(screen.queryByLabelText(/Selected Item/i)).not.toBeInTheDocument();
    expect(screen.queryByLabelText(/Entire Tree/i)).not.toBeInTheDocument();
    expect(screen.getByLabelText(/JSON/i)).toBeChecked();
  });

  test('renders correctly for "tree" context', () => {
    render(<ExportDialog {...defaultProps} context="tree" />);
    expect(screen.getByRole('heading', { name: /Export Full Tree/i })).toBeInTheDocument();
    expect(screen.queryByLabelText(/Selected Item/i)).not.toBeInTheDocument();
    expect(screen.queryByLabelText(/Entire Tree/i)).not.toBeInTheDocument();
    expect(screen.getByLabelText(/PDF/i)).not.toBeChecked(); // JSON is default
  });

  test('allows changing export target when context is generic', async () => {
    const user = userEvent.setup();
    render(<ExportDialog {...defaultProps} context={null} />); // Generic context
    const entireTreeRadio = screen.getByLabelText(/Entire Tree/i);
    await user.click(entireTreeRadio);
    expect(entireTreeRadio).toBeChecked();
  });

  test('allows changing export format', async () => {
    const user = userEvent.setup();
    render(<ExportDialog {...defaultProps} />);
    const pdfRadio = screen.getByLabelText(/PDF/i);
    await user.click(pdfRadio);
    expect(pdfRadio).toBeChecked();
    expect(screen.getByRole('button', { name: /Export as PDF/i })).toBeInTheDocument();
  });

  test('calls onExport with correct target and format', async () => {
    const user = userEvent.setup();
    render(<ExportDialog {...defaultProps} context={null} />); // Generic to allow target change
    
    // Change target and format
    await user.click(screen.getByLabelText(/Entire Tree/i));
    await user.click(screen.getByLabelText(/PDF/i));
    
    await user.click(screen.getByRole('button', { name: /Export as PDF/i }));
    expect(mockOnExport).toHaveBeenCalledWith('entire', 'pdf');
    expect(mockOnClose).toHaveBeenCalledTimes(1);
  });

  test('calls onExport with "selected" target if context is "item"', async () => {
    const user = userEvent.setup();
    render(<ExportDialog {...defaultProps} context="item" defaultFormat="pdf" />);
    await user.click(screen.getByRole('button', { name: /Export as PDF/i }));
    expect(mockOnExport).toHaveBeenCalledWith('selected', 'pdf');
    expect(mockOnClose).toHaveBeenCalledTimes(1);
  });

  test('calls onClose when Cancel button is clicked', async () => {
    const user = userEvent.setup();
    render(<ExportDialog {...defaultProps} />);
    await user.click(screen.getByRole('button', { name: /Cancel/i }));
    expect(mockOnClose).toHaveBeenCalledTimes(1);
  });

  test('uses defaultFormat prop correctly', () => {
    render(<ExportDialog {...defaultProps} defaultFormat="pdf" />);
    expect(screen.getByLabelText(/PDF/i)).toBeChecked();
    expect(screen.getByRole('button', {name: /Export as PDF/i})).toBeInTheDocument();
  });
});

--- tests\components\FolderContents.test.jsx ---
// tests/components/FolderContents.test.jsx
import React from "react";
import {
  render,
  screen,
  fireEvent,
  within,
  waitFor,
} from "@testing-library/react";
import userEvent from "@testing-library/user-event";
import "@testing-library/jest-dom";
import FolderContents from "../../src/components/FolderContents";

// Mock lucide-react MoreVertical icon
jest.mock("lucide-react", () => ({
  ...jest.requireActual("lucide-react"), // Import and retain default behavior
  MoreVertical: () => <svg data-testid="icon-more-vertical" />,
}));

describe("<FolderContents /> Component", () => {
  const mockOnSelect = jest.fn();
  const mockOnToggleExpand = jest.fn();
  const mockHandleDragStart = jest.fn();
  const mockHandleDragEnter = jest.fn();
  const mockHandleDragOver = jest.fn();
  const mockHandleDragLeave = jest.fn();
  const mockHandleDrop = jest.fn();
  const mockHandleDragEnd = jest.fn();
  const mockOnShowItemMenu = jest.fn(); // Mock for the new prop

  const emptyFolder = {
    id: "f0",
    type: "folder",
    label: "Empty Folder",
    children: [],
  };
  const folderWithChildren = {
    id: "f1",
    type: "folder",
    label: "Folder With Items",
    children: [
      { id: "f2", type: "folder", label: "Subfolder Alpha", children: [] },
      { id: "n1", type: "note", label: "Note Beta" },
      { id: "t1", type: "task", label: "Task Gamma", completed: false },
      { id: "t2", type: "task", label: "Task Delta", completed: true },
    ],
  };

  const defaultProps = {
    onSelect: mockOnSelect,
    onToggleExpand: mockOnToggleExpand,
    expandedItems: {}, // Default to no folders expanded
    handleDragStart: mockHandleDragStart,
    handleDragEnter: mockHandleDragEnter,
    handleDragOver: mockHandleDragOver,
    handleDragLeave: mockHandleDragLeave,
    handleDrop: mockHandleDrop,
    handleDragEnd: mockHandleDragEnd,
    draggedId: null,
    dragOverItemId: null,
    onShowItemMenu: mockOnShowItemMenu,
  };

  beforeEach(() => {
    jest.clearAllMocks();
  });

  test("renders empty message when folder has no children", () => {
    render(<FolderContents {...defaultProps} folder={emptyFolder} />);
    expect(screen.getByText("This folder is empty.")).toBeInTheDocument();
  });

  test("renders children items sorted correctly", () => {
    // sortItems in FolderContents sorts folders first, then by label
    render(
      <FolderContents
        {...defaultProps}
        folder={folderWithChildren}
        expandedItems={{ f2: false }}
      />
    );
    const listItems = screen.getAllByRole("listitem"); // Get all <li> elements
    expect(listItems.length).toBe(4);
    // Based on sortItems: Folder, Note, Task, Task (alphabetical within type)
    expect(
      within(listItems[0]).getByText("Subfolder Alpha")
    ).toBeInTheDocument();
    expect(within(listItems[1]).getByText("Note Beta")).toBeInTheDocument();
    expect(within(listItems[2]).getByText("Task Delta")).toBeInTheDocument(); // Delta before Gamma
    expect(within(listItems[3]).getByText("Task Gamma")).toBeInTheDocument();
  });

  test("calls onSelect when an item (not an interactive button within it) is clicked", async () => {
    const user = userEvent.setup();
    render(<FolderContents {...defaultProps} folder={folderWithChildren} />);
    // Target the list item itself or its main clickable area, not specific buttons within it yet
    const noteListItem = screen.getByText("Note Beta").closest("li");
    if (!noteListItem) throw new Error("Note Beta list item not found");
    await user.click(noteListItem);
    expect(mockOnSelect).toHaveBeenCalledWith("n1");
  });

  test("calls onToggleExpand when folder expand button is clicked", async () => {
    const user = userEvent.setup();
    render(
      <FolderContents
        {...defaultProps}
        folder={folderWithChildren}
        expandedItems={{ f2: false }}
      />
    );
    // Target the expand button specifically using its accessible name
    const expandButton = screen.getByRole("button", {
      name: /Expand Subfolder Alpha/i,
    });
    await user.click(expandButton);
    expect(mockOnToggleExpand).toHaveBeenCalledWith("f2");
  });

  test("calls onShowItemMenu when More options button is clicked", async () => {
    const user = userEvent.setup();
    render(<FolderContents {...defaultProps} folder={folderWithChildren} />);
    const noteItemLabel = screen.getByText("Note Beta");
    const noteItemLi = noteItemLabel.closest("li");
    if (!noteItemLi) throw new Error("List item for Note Beta not found");

    const moreButton = within(noteItemLi).getByRole("button", {
      name: /More options for Note Beta/i,
    });
    await user.click(moreButton);
    expect(mockOnShowItemMenu).toHaveBeenCalledTimes(1);
    expect(mockOnShowItemMenu).toHaveBeenCalledWith(
      folderWithChildren.children[1],
      expect.any(HTMLElement)
    ); // children[1] is Note Beta
  });

  // Drag and drop tests can be complex with react-testing-library.
  // Basic interaction checks:
  test("calls drag handlers when an item is dragged", () => {
    render(<FolderContents {...defaultProps} folder={folderWithChildren} />);
    const draggableItem = screen.getByText("Note Beta").closest("li");
    if (!draggableItem) throw new Error("Draggable item 'Note Beta' not found");

    fireEvent.dragStart(draggableItem);
    expect(mockHandleDragStart).toHaveBeenCalledWith(expect.any(Object), "n1");

    fireEvent.dragEnd(draggableItem);
    expect(mockHandleDragEnd).toHaveBeenCalledWith(expect.any(Object));
  });

  test("applies opacity when item is being dragged", () => {
    render(
      <FolderContents
        {...defaultProps}
        folder={folderWithChildren}
        draggedId="n1"
      />
    );
    const noteItemLi = screen.getByText("Note Beta").closest("li");
    expect(noteItemLi).toHaveClass("opacity-40");
  });

  test("shows folder icon correctly (open/closed)", () => {
    const { rerender } = render(
      <FolderContents
        {...defaultProps}
        folder={folderWithChildren}
        expandedItems={{ f2: false }}
      />
    );
    const subfolderItem = screen.getByText("Subfolder Alpha").closest("li");
    expect(within(subfolderItem).getByText("📁")).toBeInTheDocument(); // Closed folder icon

    rerender(
      <FolderContents
        {...defaultProps}
        folder={folderWithChildren}
        expandedItems={{ f2: true }}
      />
    );
    const openedSubfolderItem = screen
      .getByText("Subfolder Alpha")
      .closest("li");
    expect(within(openedSubfolderItem).getByText("📂")).toBeInTheDocument(); // Open folder icon
  });

  test("shows task completion status correctly", () => {
    render(<FolderContents {...defaultProps} folder={folderWithChildren} />);
    const taskDeltaItem = screen.getByText("Task Delta").closest("li"); // Completed
    expect(within(taskDeltaItem).getByText("✅")).toBeInTheDocument();
    expect(within(taskDeltaItem).getByText("Task Delta")).toHaveClass(
      "line-through"
    );

    const taskGammaItem = screen.getByText("Task Gamma").closest("li"); // Incomplete
    expect(within(taskGammaItem).getByText("⬜️")).toBeInTheDocument();
    expect(within(taskGammaItem).getByText("Task Gamma")).not.toHaveClass(
      "line-through"
    );
  });
});


--- tests\components\ImportDialog.test.jsx ---
// tests/components/ImportDialog.test.jsx
import React from 'react';
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import '@testing-library/jest-dom';
import ImportDialog from '../../src/components/ImportDialog';

describe('<ImportDialog />', () => {
  const mockOnClose = jest.fn();
  const mockOnImport = jest.fn();
  const selectedItemMock = { id: 'folder1', label: 'My Folder', type: 'folder' };

  const defaultProps = {
    isOpen: true,
    context: 'item', // Default to import under item
    selectedItem: selectedItemMock,
    onClose: mockOnClose,
    onImport: mockOnImport,
  };

  beforeEach(() => {
    mockOnClose.mockClear();
    mockOnImport.mockClear();
  });

  test('does not render when isOpen is false', () => {
    const { container } = render(<ImportDialog {...defaultProps} isOpen={false} />);
    expect(container.firstChild).toBeNull();
  });

  test('renders correctly for "import under item" context', () => {
    render(<ImportDialog {...defaultProps} />);
    expect(screen.getByRole('heading', { name: /Import Under "My Folder"/i })).toBeInTheDocument();
    expect(screen.getByLabelText(/Under Selected Item/i)).toBeChecked();
    expect(screen.getByLabelText(/Into empty tree or overwrite existing data/i)).not.toBeChecked();
    expect(screen.getByLabelText(/Select JSON File/i)).toBeInTheDocument();
    expect(screen.getByRole('button', { name: 'Import' })).toBeDisabled(); // No file selected
  });

  test('renders correctly for "tree" (full import) context', () => {
    render(<ImportDialog {...defaultProps} context="tree" selectedItem={null} />);
    expect(screen.getByRole('heading', { name: /Import Tree \(Overwrite Existing\)/i })).toBeInTheDocument();
    // Radio buttons might be hidden or "Replace Entire Tree" forced checked
    // Based on current ImportDialog, radio buttons are hidden if context="tree"
    expect(screen.queryByLabelText(/Under Selected Item/i)).not.toBeInTheDocument();
    expect(screen.queryByLabelText(/Into empty tree or overwrite existing data/i)).not.toBeInTheDocument();
    expect(screen.getByText(/This will replace your entire current tree/i)).toBeInTheDocument();
  });

  test('enables import button when a file is selected', async () => {
    const user = userEvent.setup();
    render(<ImportDialog {...defaultProps} />);
    const fileInput = screen.getByLabelText(/Select JSON File/i);
    const file = new File(['{"test":"data"}'], 'test.json', { type: 'application/json' });
    
    await user.upload(fileInput, file);
    expect(screen.getByText(/Selected: test.json/i)).toBeInTheDocument();
    expect(screen.getByRole('button', { name: 'Import' })).toBeEnabled();
  });

  test('calls onImport with file and target when Import button is clicked', async () => {
    const user = userEvent.setup();
    mockOnImport.mockResolvedValue({ success: true }); // Mock onImport to resolve
    render(<ImportDialog {...defaultProps} context="item" selectedItem={selectedItemMock} />);
    const fileInput = screen.getByLabelText(/Select JSON File/i);
    const file = new File(['{"id":"1","label":"Test"}'], 'import.json', { type: 'application/json' });
    await user.upload(fileInput, file);
    
    const importButton = screen.getByRole('button', { name: 'Import' });
    await user.click(importButton);

    await waitFor(() => {
      expect(mockOnImport).toHaveBeenCalledWith(file, 'selected'); // 'selected' because context is 'item'
    });
  });

  test('calls onImport with "entire" target if that option is selected', async () => {
    const user = userEvent.setup();
    mockOnImport.mockResolvedValue({ success: true });
     // Render without specific item context to allow radio button choice
    render(<ImportDialog isOpen={true} context="generic" selectedItem={null} onClose={mockOnClose} onImport={mockOnImport} />);
    
    const fileInput = screen.getByLabelText(/Select JSON File/i);
    const file = new File(['[{"id":"1"}]'], 'tree.json', { type: 'application/json' });
    await user.upload(fileInput, file);

    // Select "Replace Entire Tree"
    const entireTreeRadio = screen.getByLabelText(/Into empty tree or overwrite existing data/i);
    await user.click(entireTreeRadio);
    
    const importButton = screen.getByRole('button', { name: 'Import' });
    await user.click(importButton);

    await waitFor(() => {
      expect(mockOnImport).toHaveBeenCalledWith(file, 'entire');
    });
  });


  test('calls onClose when Cancel button is clicked', async () => {
    const user = userEvent.setup();
    render(<ImportDialog {...defaultProps} />);
    await user.click(screen.getByRole('button', { name: /Close/i })); // Changed from Cancel to Close
    expect(mockOnClose).toHaveBeenCalledTimes(1);
  });

  test('displays import message on success', async () => {
    const user = userEvent.setup();
    mockOnImport.mockResolvedValue({ success: true, message: "Test import successful" });
    render(<ImportDialog {...defaultProps} />);
    const fileInput = screen.getByLabelText(/Select JSON File/i);
    const file = new File(['{}'], 'test.json', { type: 'application/json' });
    await user.upload(fileInput, file);
    await user.click(screen.getByRole('button', { name: 'Import' }));

    await waitFor(() => {
      expect(screen.getByText("Test import successful")).toBeInTheDocument();
      expect(screen.getByText("Test import successful")).toHaveClass('bg-green-100');
    });
  });

  test('displays import message on failure', async () => {
    const user = userEvent.setup();
    mockOnImport.mockResolvedValue({ success: false, error: "Test import failed" });
    render(<ImportDialog {...defaultProps} />);
    const fileInput = screen.getByLabelText(/Select JSON File/i);
    const file = new File(['{}'], 'test.json', { type: 'application/json' });
    await user.upload(fileInput, file);
    await user.click(screen.getByRole('button', { name: 'Import' }));

    await waitFor(() => {
      expect(screen.getByText("Test import failed")).toBeInTheDocument();
      expect(screen.getByText("Test import failed")).toHaveClass('bg-red-100');
    });
  });
});

--- tests\components\Login.test.jsx ---
// tests/components/Login.test.jsx
import React from "react";
import { render, screen, fireEvent, waitFor } from "@testing-library/react";
import userEvent from "@testing-library/user-event";
import "@testing-library/jest-dom";
import Login from "../../src/components/Login";

const mockOnLoginSuccess = jest.fn();
const mockOnSwitchToRegister = jest.fn();

// Mock global.fetch
global.fetch = jest.fn();

// Mock VITE_API_BASE_URL
const originalEnv = { ...process.env };
beforeAll(() => {
  process.env.VITE_API_BASE_URL = "http://localhost:5001/api"; // Or your test API URL
});
afterAll(() => {
  process.env = originalEnv; // Restore original env
});

describe("<Login />", () => {
  beforeEach(() => {
    fetch.mockClear();
    mockOnLoginSuccess.mockClear();
    mockOnSwitchToRegister.mockClear();
  });

  test("renders login form correctly", () => {
    render(
      <Login
        onLoginSuccess={mockOnLoginSuccess}
        onSwitchToRegister={mockOnSwitchToRegister}
      />
    );
    expect(
      screen.getByRole("heading", { name: /Login to Notes & Tasks/i })
    ).toBeInTheDocument();
    expect(screen.getByLabelText(/Email Address/i)).toBeInTheDocument();
    expect(screen.getByLabelText(/Password/i)).toBeInTheDocument();
    expect(screen.getByRole("button", { name: /Login/i })).toBeInTheDocument();
    expect(
      screen.getByRole("button", { name: /Create one/i })
    ).toBeInTheDocument();
  });

  test("allows input for email and password", async () => {
    const user = userEvent.setup();
    render(
      <Login
        onLoginSuccess={mockOnLoginSuccess}
        onSwitchToRegister={mockOnSwitchToRegister}
      />
    );

    const emailInput = screen.getByLabelText(/Email Address/i);
    await user.type(emailInput, "test@example.com");
    expect(emailInput).toHaveValue("test@example.com");

    const passwordInput = screen.getByLabelText(/Password/i);
    await user.type(passwordInput, "password123");
    expect(passwordInput).toHaveValue("password123");
  });

  test("shows error message if fields are empty on submit", async () => {
    const user = userEvent.setup();
    render(
      <Login
        onLoginSuccess={mockOnLoginSuccess}
        onSwitchToRegister={mockOnSwitchToRegister}
      />
    );
    const loginButton = screen.getByRole("button", { name: /Login/i });
    await user.click(loginButton);
    expect(
      screen.getByText(/Please enter both email and password/i)
    ).toBeInTheDocument();
    expect(fetch).not.toHaveBeenCalled();
  });

  test("calls onLoginSuccess with user data on successful login", async () => {
    const user = userEvent.setup();
    const mockUserData = { id: "123", email: "test@example.com" };
    fetch.mockResolvedValueOnce({
      ok: true,
      json: async () => ({ token: "fake-jwt-token", user: mockUserData }),
    });

    render(
      <Login
        onLoginSuccess={mockOnLoginSuccess}
        onSwitchToRegister={mockOnSwitchToRegister}
      />
    );
    await user.type(
      screen.getByLabelText(/Email Address/i),
      "test@example.com"
    );
    await user.type(screen.getByLabelText(/Password/i), "password123");
    await user.click(screen.getByRole("button", { name: /Login/i }));

    await waitFor(() => {
      expect(fetch).toHaveBeenCalledWith(
        "http://localhost:5001/api/auth/login",
        expect.any(Object)
      );
      expect(mockOnLoginSuccess).toHaveBeenCalledWith(mockUserData);
    });
    expect(localStorage.getItem("userToken")).toBe("fake-jwt-token");
  });

  test("shows error message on failed login (invalid credentials)", async () => {
    const user = userEvent.setup();
    fetch.mockResolvedValueOnce({
      ok: false,
      status: 401,
      json: async () => ({ error: "Invalid credentials" }),
    });

    render(
      <Login
        onLoginSuccess={mockOnLoginSuccess}
        onSwitchToRegister={mockOnSwitchToRegister}
      />
    );
    await user.type(
      screen.getByLabelText(/Email Address/i),
      "test@example.com"
    );
    await user.type(screen.getByLabelText(/Password/i), "wrongpassword");
    await user.click(screen.getByRole("button", { name: /Login/i }));

    await waitFor(() => {
      expect(screen.getByText(/Invalid credentials/i)).toBeInTheDocument();
    });
    expect(mockOnLoginSuccess).not.toHaveBeenCalled();
  });

  test("shows error message on network error", async () => {
    const user = userEvent.setup();
    fetch.mockRejectedValueOnce(new Error("Network error"));

    render(
      <Login
        onLoginSuccess={mockOnLoginSuccess}
        onSwitchToRegister={mockOnSwitchToRegister}
      />
    );
    await user.type(
      screen.getByLabelText(/Email Address/i),
      "test@example.com"
    );
    await user.type(screen.getByLabelText(/Password/i), "password123");
    await user.click(screen.getByRole("button", { name: /Login/i }));

    await waitFor(() => {
      expect(
        screen.getByText(/Network error or server issue/i)
      ).toBeInTheDocument();
    });
  });

  test('calls onSwitchToRegister when "Create one" button is clicked', async () => {
    const user = userEvent.setup();
    render(
      <Login
        onLoginSuccess={mockOnLoginSuccess}
        onSwitchToRegister={mockOnSwitchToRegister}
      />
    );
    const createAccountButton = screen.getByRole("button", {
      name: /Create one/i,
    });
    await user.click(createAccountButton);
    expect(mockOnSwitchToRegister).toHaveBeenCalledTimes(1);
  });
});


--- tests\components\Register.test.jsx ---
// tests/components/Register.test.jsx
import React from "react";
import { render, screen, fireEvent, waitFor } from "@testing-library/react";
import userEvent from "@testing-library/user-event";
import "@testing-library/jest-dom";
import Register from "../../src/components/Register";

const mockOnRegisterSuccess = jest.fn();
const mockOnSwitchToLogin = jest.fn();

// Mock global.fetch
global.fetch = jest.fn();

// Mock VITE_API_BASE_URL
const originalEnv = { ...process.env };
beforeAll(() => {
  process.env.VITE_API_BASE_URL = "http://localhost:5001/api";
});
afterAll(() => {
  process.env = originalEnv;
});

describe("<Register />", () => {
  beforeEach(() => {
    fetch.mockClear();
    mockOnRegisterSuccess.mockClear();
    mockOnSwitchToLogin.mockClear();
  });

  test("renders registration form correctly", () => {
    render(
      <Register
        onRegisterSuccess={mockOnRegisterSuccess}
        onSwitchToLogin={mockOnSwitchToLogin}
      />
    );
    expect(
      screen.getByRole("heading", { name: /Create Account/i })
    ).toBeInTheDocument();
    expect(screen.getByLabelText(/Email Address/i)).toBeInTheDocument();
    expect(
      screen.getByLabelText(/Password \(min. 8 characters\)/i)
    ).toBeInTheDocument();
    expect(screen.getByLabelText(/Confirm Password/i)).toBeInTheDocument();
    expect(
      screen.getByRole("button", { name: /Create Account/i })
    ).toBeInTheDocument();
    expect(screen.getByRole("button", { name: /Log In/i })).toBeInTheDocument();
  });

  test("shows error if fields are empty on submit", async () => {
    const user = userEvent.setup();
    render(
      <Register
        onRegisterSuccess={mockOnRegisterSuccess}
        onSwitchToLogin={mockOnSwitchToLogin}
      />
    );
    await user.click(screen.getByRole("button", { name: /Create Account/i }));
    expect(screen.getByText(/Please fill in all fields/i)).toBeInTheDocument();
  });

  test("shows error if passwords do not match", async () => {
    const user = userEvent.setup();
    render(
      <Register
        onRegisterSuccess={mockOnRegisterSuccess}
        onSwitchToLogin={mockOnSwitchToLogin}
      />
    );
    await user.type(
      screen.getByLabelText(/Email Address/i),
      "test@example.com"
    );
    await user.type(screen.getByLabelText(/Password/i), "password123");
    await user.type(screen.getByLabelText(/Confirm Password/i), "password456");
    await user.click(screen.getByRole("button", { name: /Create Account/i }));
    expect(screen.getByText(/Passwords do not match/i)).toBeInTheDocument();
  });

  test("shows error if password is too short", async () => {
    const user = userEvent.setup();
    render(
      <Register
        onRegisterSuccess={mockOnRegisterSuccess}
        onSwitchToLogin={mockOnSwitchToLogin}
      />
    );
    await user.type(
      screen.getByLabelText(/Email Address/i),
      "test@example.com"
    );
    await user.type(screen.getByLabelText(/Password/i), "pass");
    await user.type(screen.getByLabelText(/Confirm Password/i), "pass");
    await user.click(screen.getByRole("button", { name: /Create Account/i }));
    expect(
      screen.getByText(/Password must be at least 8 characters long/i)
    ).toBeInTheDocument();
  });

  test("calls onRegisterSuccess on successful registration", async () => {
    const user = userEvent.setup();
    const mockServerResponse = {
      user: { id: "newUser123", email: "test@example.com" },
      token: "new-fake-token",
    }; // Assuming register might also return token
    fetch.mockResolvedValueOnce({
      ok: true,
      json: async () => mockServerResponse,
    });
    window.alert = jest.fn(); // Mock alert

    render(
      <Register
        onRegisterSuccess={mockOnRegisterSuccess}
        onSwitchToLogin={mockOnSwitchToLogin}
      />
    );
    await user.type(
      screen.getByLabelText(/Email Address/i),
      "test@example.com"
    );
    await user.type(screen.getByLabelText(/Password/i), "password123");
    await user.type(screen.getByLabelText(/Confirm Password/i), "password123");
    await user.click(screen.getByRole("button", { name: /Create Account/i }));

    await waitFor(() => {
      expect(fetch).toHaveBeenCalledWith(
        "http://localhost:5001/api/auth/register",
        expect.any(Object)
      );
      expect(mockOnRegisterSuccess).toHaveBeenCalledTimes(1);
      expect(window.alert).toHaveBeenCalledWith(
        "Registration successful! Please log in."
      );
    });
  });

  test("shows server error message on failed registration", async () => {
    const user = userEvent.setup();
    fetch.mockResolvedValueOnce({
      ok: false,
      json: async () => ({ error: "Email already exists" }),
    });
    render(
      <Register
        onRegisterSuccess={mockOnRegisterSuccess}
        onSwitchToLogin={mockOnSwitchToLogin}
      />
    );
    await user.type(
      screen.getByLabelText(/Email Address/i),
      "test@example.com"
    );
    await user.type(screen.getByLabelText(/Password/i), "password123");
    await user.type(screen.getByLabelText(/Confirm Password/i), "password123");
    await user.click(screen.getByRole("button", { name: /Create Account/i }));

    await waitFor(() => {
      expect(screen.getByText(/Email already exists/i)).toBeInTheDocument();
    });
  });

  test('calls onSwitchToLogin when "Log In" button is clicked', async () => {
    const user = userEvent.setup();
    render(
      <Register
        onRegisterSuccess={mockOnRegisterSuccess}
        onSwitchToLogin={mockOnSwitchToLogin}
      />
    );
    await user.click(screen.getByRole("button", { name: /Log In/i }));
    expect(mockOnSwitchToLogin).toHaveBeenCalledTimes(1);
  });
});


--- tests\components\RenameDialog.test.jsx ---
// tests/components/RenameDialog.test.jsx
import React from "react";
import { render, screen, fireEvent } from "@testing-library/react";
import "@testing-library/jest-dom";
import RenameDialog from "../../src/components/RenameDialog";

describe("<RenameDialog />", () => {
  const mockOnNameChange = jest.fn();
  const mockOnRename = jest.fn();
  const mockOnCancel = jest.fn();

  const defaultProps = {
    isOpen: true,
    item: { id: "1", label: "Old Label" },
    newName: "Old Label",
    onNameChange: mockOnNameChange,
    onRename: mockOnRename,
    onCancel: mockOnCancel,
  };

  beforeEach(() => {
    mockOnNameChange.mockClear();
    mockOnRename.mockClear();
    mockOnCancel.mockClear();
  });

  test("does not render when isOpen is false", () => {
    const { container } = render(
      <RenameDialog {...defaultProps} isOpen={false} />
    );
    expect(container.firstChild).toBeNull();
  });

  test("renders correct title with item label", () => {
    render(<RenameDialog {...defaultProps} />);
    expect(
      screen.getByRole("heading", { name: /Rename “Old Label”/i })
    ).toBeInTheDocument();
  });

  test("renders input with current name, calls onNameChange, and focuses input", () => {
    render(<RenameDialog {...defaultProps} />);
    const input = screen.getByDisplayValue("Old Label");
    expect(input).toBeInTheDocument();
    expect(input).toHaveFocus(); // autoFocus should work

    fireEvent.change(input, { target: { value: "New Label Value" } });
    expect(mockOnNameChange).toHaveBeenCalledTimes(1);
    // The event object itself is passed, so checking e.target.value is fine if needed by the handler
    // expect(mockOnNameChange).toHaveBeenCalledWith(expect.objectContaining({ target: { value: 'New Label Value' } }));
  });

  test("calls onCancel when Cancel button is clicked", () => {
    render(<RenameDialog {...defaultProps} />);
    fireEvent.click(screen.getByRole("button", { name: /Cancel/i }));
    expect(mockOnCancel).toHaveBeenCalledTimes(1);
  });

  test("calls onRename when Rename button is clicked", () => {
    render(<RenameDialog {...defaultProps} />);
    fireEvent.click(screen.getByRole("button", { name: /Rename/i }));
    expect(mockOnRename).toHaveBeenCalledTimes(1);
  });

  test("calls onRename when form is submitted", () => {
    render(<RenameDialog {...defaultProps} />);
    const form = screen
      .getByRole("button", { name: /Rename/i })
      .closest("form");
    if (!form) throw new Error("Form not found");
    fireEvent.submit(form);
    expect(mockOnRename).toHaveBeenCalledTimes(1);
  });
});


--- tests\components\SettingsDialog.test.jsx ---
// tests/components/SettingsDialog.test.jsx
import React from "react";
import { render, screen } from "@testing-library/react"; // fireEvent removed if not directly used
import userEvent from "@testing-library/user-event";
import "@testing-library/jest-dom";
import SettingsDialog from "../../src/components/SettingsDialog";
import {
  SettingsContext,
  defaultSettings,
} from "../../src/contexts/SettingsContext";

const mockUpdateSetting = jest.fn();
const mockResetSettings = jest.fn();
const mockResetApplicationData = jest.fn();

const customRender = (ui, { providerProps, ...renderOptions }) => {
  return render(
    <SettingsContext.Provider value={providerProps}>
      {ui}
    </SettingsContext.Provider>,
    renderOptions
  );
};

describe("<SettingsDialog />", () => {
  let providerProps;
  const originalConfirm = window.confirm;

  beforeEach(() => {
    mockUpdateSetting.mockClear();
    mockResetSettings.mockClear();
    mockResetApplicationData.mockClear();
    providerProps = {
      settings: { ...defaultSettings },
      updateSetting: mockUpdateSetting,
      resetSettings: mockResetSettings,
      resetApplicationData: mockResetApplicationData,
    };
    window.confirm = jest.fn(() => true); // Mock window.confirm
  });

  afterEach(() => {
    window.confirm = originalConfirm; // Restore window.confirm
  });

  test("does not render when isOpen is false", () => {
    const { container } = customRender(
      <SettingsDialog isOpen={false} onClose={jest.fn()} />,
      { providerProps }
    );
    expect(container.firstChild).toBeNull();
  });

  test("renders correctly when isOpen is true", () => {
    customRender(<SettingsDialog isOpen={true} onClose={jest.fn()} />, {
      providerProps,
    });
    expect(screen.getByTestId("settings-dialog-overlay")).toBeInTheDocument();
    expect(screen.getByTestId("settings-dialog-content")).toBeInTheDocument();
    expect(
      screen.getByRole("heading", { name: /Settings/i })
    ).toBeInTheDocument();
    // ... (other getByTestId checks for rows as in your original)
    expect(screen.getByTestId("setting-row-theme")).toBeInTheDocument();
    expect(
      screen.getByTestId("setting-row-autoExpandNewFolders")
    ).toBeInTheDocument();
  });

  test("calls onClose when header Close button is clicked", async () => {
    const mockOnClose = jest.fn();
    customRender(<SettingsDialog isOpen={true} onClose={mockOnClose} />, {
      providerProps,
    });
    await userEvent.click(screen.getByTestId("settings-close-button-header"));
    expect(mockOnClose).toHaveBeenCalledTimes(1);
  });

  test("calls onClose when footer Close button is clicked", async () => {
    const mockOnClose = jest.fn();
    customRender(<SettingsDialog isOpen={true} onClose={mockOnClose} />, {
      providerProps,
    });
    await userEvent.click(screen.getByTestId("settings-close-button-footer"));
    expect(mockOnClose).toHaveBeenCalledTimes(1);
  });

  test("updates theme setting when selection changes", async () => {
    customRender(<SettingsDialog isOpen={true} onClose={jest.fn()} />, {
      providerProps,
    });
    const themeSelect = screen.getByTestId("setting-theme-select");
    await userEvent.selectOptions(themeSelect, "dark");
    expect(mockUpdateSetting).toHaveBeenCalledWith("theme", "dark");
  });

  test("updates autoExpand setting when checkbox is clicked", async () => {
    customRender(<SettingsDialog isOpen={true} onClose={jest.fn()} />, {
      providerProps,
    });
    const checkbox = screen.getByTestId("setting-autoexpand-checkbox");
    expect(checkbox).toBeChecked(); // Default is true
    await userEvent.click(checkbox);
    expect(mockUpdateSetting).toHaveBeenCalledWith(
      "autoExpandNewFolders",
      false
    );
  });

  // ... (other specific setting change tests like fontFamily, fontSize, exportFormat as in your original)

  test("filters settings based on search term in label", async () => {
    customRender(<SettingsDialog isOpen={true} onClose={jest.fn()} />, {
      providerProps,
    });
    const searchInput = screen.getByTestId("settings-search-input");
    await userEvent.type(searchInput, "Theme");
    expect(screen.getByTestId("setting-row-theme")).toBeInTheDocument();
    expect(
      screen.queryByTestId("setting-row-autoExpandNewFolders")
    ).not.toBeInTheDocument();
  });

  test('displays "No settings found" message when search yields no results', async () => {
    customRender(<SettingsDialog isOpen={true} onClose={jest.fn()} />, {
      providerProps,
    });
    const searchInput = screen.getByTestId("settings-search-input");
    await userEvent.type(searchInput, "xyznonexistentxyz");
    expect(screen.getByTestId("settings-no-results")).toBeInTheDocument();
  });

  test("calls resetSettings when Reset Settings button is clicked and confirmed", async () => {
    customRender(<SettingsDialog isOpen={true} onClose={jest.fn()} />, {
      providerProps,
    });
    await userEvent.click(screen.getByTestId("setting-resetsettings-button"));
    expect(window.confirm).toHaveBeenCalledWith(
      expect.stringContaining("reset all settings")
    );
    expect(mockResetSettings).toHaveBeenCalledTimes(1);
  });

  test("calls resetApplicationData when Reset All Data button is clicked and confirmed", async () => {
    customRender(<SettingsDialog isOpen={true} onClose={jest.fn()} />, {
      providerProps,
    });
    await userEvent.click(screen.getByTestId("setting-resetdata-button"));
    expect(window.confirm).toHaveBeenCalledWith(
      expect.stringContaining("WARNING: This will permanently delete")
    );
    expect(mockResetApplicationData).toHaveBeenCalledTimes(1);
  });

  test("does NOT call resetSettings if confirm is cancelled", async () => {
    window.confirm.mockImplementationOnce(() => false); // Override for this test
    customRender(<SettingsDialog isOpen={true} onClose={jest.fn()} />, {
      providerProps,
    });
    await userEvent.click(screen.getByTestId("setting-resetsettings-button"));
    expect(window.confirm).toHaveBeenCalled();
    expect(mockResetSettings).not.toHaveBeenCalled();
  });
});


--- tests\components\TaskItem.test.jsx ---
// tests/components/TaskItem.test.jsx
import React from "react";
import { render, screen, fireEvent } from "@testing-library/react";
import "@testing-library/jest-dom";
import TaskItem from "../../src/components/TaskItem";

describe("<TaskItem /> Component", () => {
  const mockToggle = jest.fn();

  beforeEach(() => {
    mockToggle.mockClear();
  });

  test("returns null if no task prop is provided", () => {
    const { container } = render(<TaskItem onToggle={mockToggle} />);
    expect(container.firstChild).toBeNull();
  });

  test("renders task label and unchecked checkbox for incomplete task", () => {
    const task = {
      id: "t1",
      type: "task",
      label: "Test Task Incomplete",
      completed: false,
    };
    render(<TaskItem task={task} onToggle={mockToggle} />);
    const checkbox = screen.getByRole("checkbox");
    const label = screen.getByText(task.label);
    expect(checkbox).not.toBeChecked();
    expect(label).not.toHaveClass("line-through");
  });

  test("renders task label and checked checkbox for completed task", () => {
    const task = {
      id: "t2",
      type: "task",
      label: "Test Task Complete",
      completed: true,
    };
    render(<TaskItem task={task} onToggle={mockToggle} />);
    const checkbox = screen.getByRole("checkbox");
    const label = screen.getByText(task.label);
    expect(checkbox).toBeChecked();
    expect(label).toHaveClass("line-through");
  });

  test("calls onToggle with true when incomplete task checkbox is clicked", () => {
    const task = {
      id: "t1",
      type: "task",
      label: "Test Task",
      completed: false,
    };
    render(<TaskItem task={task} onToggle={mockToggle} />);
    fireEvent.click(screen.getByRole("checkbox"));
    expect(mockToggle).toHaveBeenCalledWith(true);
  });

  test("calls onToggle with false when completed task checkbox is clicked", () => {
    const task = {
      id: "t2",
      type: "task",
      label: "Test Task",
      completed: true,
    };
    render(<TaskItem task={task} onToggle={mockToggle} />);
    fireEvent.click(screen.getByRole("checkbox"));
    expect(mockToggle).toHaveBeenCalledWith(false);
  });

  test("calls onToggle when label is clicked", () => {
    const task = {
      id: "t1",
      type: "task",
      label: "Clickable Label",
      completed: false,
    };
    render(<TaskItem task={task} onToggle={mockToggle} />);
    fireEvent.click(screen.getByText(task.label));
    expect(mockToggle).toHaveBeenCalledWith(true);
  });
});


--- tests\components\Tree.test.jsx ---
// tests/components/Tree.test.jsx
import React from "react";
import { render, screen, fireEvent } from "@testing-library/react";
import userEvent from "@testing-library/user-event";
import "@testing-library/jest-dom";
import Tree from "../../src/components/Tree";

// Mock lucide-react MoreVertical icon
jest.mock("lucide-react", () => ({
  ...jest.requireActual("lucide-react"), // Import and retain default behavior
  MoreVertical: () => <svg data-testid="icon-more-vertical" />,
}));

const mockHandlers = {
  onSelect: jest.fn(),
  onToggleExpand: jest.fn(),
  onToggleTask: jest.fn(),
  onDragStart: jest.fn(),
  onDrop: jest.fn(),
  onNativeContextMenu: jest.fn(), // Updated prop name
  onShowItemMenu: jest.fn(), // New prop for button menu
  onRename: jest.fn(), // This is for initiating rename (e.g. F2 or dblclick)
  onAttemptRename: jest.fn(), // For when inline input blurs or Enter pressed
  cancelInlineRename: jest.fn(),
  setInlineRenameValue: jest.fn(),
  onDragEnd: jest.fn(),
  setUiError: jest.fn(),
};

const sampleItems = [
  {
    id: "f1",
    type: "folder",
    label: "Folder 1",
    children: [
      { id: "f1-n1", type: "note", label: "Note 1.1" },
      { id: "f1-t1", type: "task", label: "Task 1.1", completed: true },
    ],
  },
  { id: "f2", type: "folder", label: "Folder 2", children: [] },
  { id: "n1", type: "note", label: "Note Alpha" }, // Changed for sort testing
  { id: "t1", type: "task", label: "Task Beta", completed: false },
];

describe("<Tree /> Component", () => {
  let user;

  beforeEach(() => {
    user = userEvent.setup();
    Object.values(mockHandlers).forEach((mock) => mock.mockClear());
  });

  const defaultProps = {
    items: [],
    selectedItemId: null,
    inlineRenameId: null,
    inlineRenameValue: "",
    expandedFolders: {},
    draggedId: null,
    uiError: "",
    ...mockHandlers,
  };

  test("renders navigation role", () => {
    render(<Tree {...defaultProps} />);
    expect(
      screen.getByRole("navigation", { name: "Notes and Tasks Tree" })
    ).toBeInTheDocument();
  });

  test("renders and sorts top-level items correctly", () => {
    render(<Tree {...defaultProps} items={sampleItems} />);
    // Items are sorted: Folder 1, Folder 2, Note Alpha, Task Beta
    const renderedItems = screen.getAllByRole("listitem");
    expect(renderedItems[0]).toHaveTextContent("Folder 1");
    expect(renderedItems[1]).toHaveTextContent("Folder 2");
    expect(renderedItems[2]).toHaveTextContent("Note Alpha");
    expect(renderedItems[3]).toHaveTextContent("Task Beta");
  });

  test("calls onSelect when an item main div is clicked", async () => {
    render(<Tree {...defaultProps} items={sampleItems} />);
    // Find the div that handles selection click (not buttons within the item)
    const noteItemDiv = screen
      .getByText("Note Alpha")
      .closest('div[role="button"]'); // The div that has the onClick for selection
    if (!noteItemDiv)
      throw new Error("Clickable div for 'Note Alpha' not found");
    await user.click(noteItemDiv);
    expect(mockHandlers.onSelect).toHaveBeenCalledWith("n1");
  });

  test("calls onToggleExpand when folder expand button is clicked", async () => {
    render(<Tree {...defaultProps} items={sampleItems} expandedFolders={{}} />);
    const folder1Item = screen.getByText("Folder 1").closest("li");
    const expandButton = within(folder1Item).getByRole("button", {
      name: /Expand Folder 1/i,
    });
    await user.click(expandButton);
    expect(mockHandlers.onToggleExpand).toHaveBeenCalledWith("f1");
  });

  test("calls onToggleTask when task checkbox area is clicked", async () => {
    render(<Tree {...defaultProps} items={sampleItems} />);
    const taskItem = screen.getByText("Task Beta").closest("li");
    // The checkbox itself is a button in the implementation
    const checkboxButton = within(taskItem).getByRole("checkbox", {
      name: /Mark task Task Beta as complete/i,
    });
    await user.click(checkboxButton);
    expect(mockHandlers.onToggleTask).toHaveBeenCalledWith("t1", true); // true because initial was false
  });

  test("calls onShowItemMenu when more options button is clicked", async () => {
    render(<Tree {...defaultProps} items={sampleItems} />);
    const noteItem = screen.getByText("Note Alpha").closest("li");
    const moreButton = within(noteItem).getByRole("button", {
      name: /More options for Note Alpha/i,
    });
    await user.click(moreButton);
    expect(mockHandlers.onShowItemMenu).toHaveBeenCalledWith(
      expect.objectContaining({ id: "n1", label: "Note Alpha" }), // The item object
      expect.any(HTMLElement) // The button element
    );
  });

  test("calls onNativeContextMenu when tree area is right-clicked (empty area)", async () => {
    render(<Tree {...defaultProps} items={sampleItems} />);
    const treeNav = screen.getByRole("navigation", {
      name: "Notes and Tasks Tree",
    });
    fireEvent.contextMenu(treeNav);
    expect(mockHandlers.onSelect).toHaveBeenCalledWith(null); // Selects null for empty area
    expect(mockHandlers.onNativeContextMenu).toHaveBeenCalledWith(
      expect.any(Object),
      null
    );
  });

  test("calls onNativeContextMenu when an item is right-clicked", async () => {
    render(<Tree {...defaultProps} items={sampleItems} />);
    const noteItemLi = screen.getByText("Note Alpha").closest("li");
    if (!noteItemLi) throw new Error("Note Alpha list item not found");
    fireEvent.contextMenu(noteItemLi);
    expect(mockHandlers.onSelect).toHaveBeenCalledWith("n1"); // Selects the item first
    expect(mockHandlers.onNativeContextMenu).toHaveBeenCalledWith(
      expect.any(Object), // The event
      expect.objectContaining({ id: "n1" }) // The item
    );
  });

  test("renders inline rename input when inlineRenameId matches an item", () => {
    render(
      <Tree
        {...defaultProps}
        items={sampleItems}
        inlineRenameId="n1"
        inlineRenameValue="Renaming Note"
      />
    );
    const input = screen.getByDisplayValue("Renaming Note");
    expect(input).toBeInTheDocument();
    expect(input.tagName).toBe("INPUT");
    // The original label "Note Alpha" should not be visible for this item
    expect(
      screen.queryByText("Note Alpha", { selector: "span" })
    ).not.toBeInTheDocument();
  });

  test("displays uiError message when inline renaming and error exists", () => {
    const errorMessage = "Name conflict!";
    render(
      <Tree
        {...defaultProps}
        items={sampleItems}
        inlineRenameId="n1"
        uiError={errorMessage}
      />
    );
    expect(screen.getByText(errorMessage)).toBeInTheDocument();
    // Check ARIA attributes on the input
    const input = screen.getByRole("textbox"); // Assuming rename input becomes a textbox
    expect(input).toHaveAttribute("aria-invalid", "true");
    expect(input).toHaveAttribute("aria-describedby", "n1-rename-error");
  });
});


--- tests\hooks\useTree.test.js ---
// tests/hooks/useTree.test.js
import { renderHook, act } from '@testing-library/react';
import { useTree } from '../../src/hooks/useTree';
import { LOCAL_STORAGE_KEY } from '../../src/utils/constants';

// Mocking fetch
global.fetch = jest.fn();

// Mock unicode-bidirectional
jest.mock('unicode-bidirectional', () => ({
  __esModule: true, // This is important for modules with default exports when mocking
  embeddingLevels: jest.fn(() => []), // Mock implementation
  reorder: jest.fn(text => text),     // Mock implementation
}));

// Mock SettingsContext
jest.mock('../../src/contexts/SettingsContext', () => ({
  useSettings: () => ({
    settings: {
      theme: 'system',
      defaultSortOrder: 'foldersFirstAlpha',
      autoExpandNewFolders: true,
      editorFontFamily: 'Arial',
      editorFontSize: '3',
      defaultExportFormat: 'json',
    },
    // Mock functions if your hook uses them directly, otherwise not strictly needed for all tests
    updateSetting: jest.fn(),
    resetSettings: jest.fn(),
    resetApplicationData: jest.fn(),
  }),
  // Exporting defaultSettings isn't strictly necessary for the mock if useSettings provides it
  defaultSettings: { /* your default settings object */ },
}));

// LocalStorage mock
const localStorageMock = (() => {
  let store = {};
  return {
    getItem: jest.fn(key => store[key] || null),
    setItem: jest.fn((key, value) => { store[key] = value.toString(); }),
    removeItem: jest.fn(key => { delete store[key]; }),
    clear: jest.fn(() => { store = {}; }),
    hasOwnProperty: jest.fn(key => store.hasOwnProperty(key)), // Added for completeness
    length: Object.keys(store).length, // Added for completeness
    key: jest.fn(index => Object.keys(store)[index] || null) // Added for completeness
  };
})();
Object.defineProperty(window, 'localStorage', { value: localStorageMock });


describe('useTree Hook', () => {
  beforeEach(() => {
    localStorageMock.clear();
    jest.clearAllMocks(); // Clears all mocks including fetch
    // Provide a default successful fetch response for initial load
    fetch.mockResolvedValueOnce({
      ok: true,
      json: async () => ({ notesTree: [] }), // Default to empty tree
    });
  });

  test('initializes with an attempt to fetch tree if token exists', async () => {
    localStorageMock.setItem('userToken', 'fake-token'); // Simulate logged-in user
    const { result } = renderHook(() => useTree());

    // Wait for async operations in useEffect to complete if necessary
    // For this initial test, we check immediate state before async fetch might complete in test env
    expect(result.current.tree).toEqual([]); // Initial state before fetch completes
    expect(result.current.expandedFolders).toEqual({});

    // Check that fetch was called (due to useEffect in useTree)
    // await waitFor(() => expect(fetch).toHaveBeenCalledTimes(1));
    // The above waitFor might be tricky depending on how useEffect and async calls are handled in test renderer
    // For now, we know fetch should be called if token exists
  });

  test('initializes with empty tree if localStorage is empty and no token', () => {
    localStorageMock.removeItem('userToken'); // Ensure no token
    fetch.mockResolvedValueOnce({ // Mock fetch in case it's called even without token (though it shouldn't)
      ok: true,
      json: async () => ({ notesTree: [] }),
    });
    const { result } = renderHook(() => useTree());
    expect(result.current.tree).toEqual([]);
    expect(result.current.expandedFolders).toEqual({});
    expect(localStorageMock.getItem).toHaveBeenCalledWith(LOCAL_STORAGE_KEY);
    expect(localStorageMock.getItem).toHaveBeenCalledWith(`${LOCAL_STORAGE_KEY}_expanded`);
  });


  test('loads tree from localStorage if present (and no token initially for fetch)', () => {
    const storedTree = [{ id: 'f1', type: 'folder', label: 'Folder 1', children: [] }];
    localStorageMock.setItem(LOCAL_STORAGE_KEY, JSON.stringify(storedTree));
    localStorageMock.removeItem('userToken'); // Ensure no token for this specific test case focus

    fetch.mockResolvedValueOnce({ // Mock fetch if it's still called
      ok: true,
      json: async () => ({ notesTree: [] }), // Return empty from fetch to ensure localStorage is preferred
    });

    const { result } = renderHook(() => useTree());

    // If fetch is prioritized over localStorage load, this might need adjustment
    // The current useTree loads from localStorage, then useEffect fetches if token.
    expect(result.current.tree).toEqual(storedTree);
  });

  // More comprehensive tests for addItem, deleteItem, etc., would require:
  // - Mocking `Workspace` for each specific API call (POST, PATCH, DELETE).
  // - Using `act()` from `@testing-library/react` to wrap state updates.
  // - Verifying that `setTreeWithUndo` is called with the expected new tree state.
  // These become more like integration tests for the hook.

  test.skip('addItem successfully updates the tree after API call', async () => {
    // Example of a more involved test (SKIPPED for brevity, needs full setup)
    const initialItems = [];
    localStorageMock.setItem(LOCAL_STORAGE_KEY, JSON.stringify(initialItems));
    localStorageMock.setItem('userToken', 'fake-token');

    const mockNewItemFromServer = { id: 'server-id-1', type: 'note', label: 'New Note from Server', content: '' };
    fetch.mockResolvedValueOnce({ // For initial fetch
      ok: true,
      json: async () => ({ notesTree: initialItems }),
    }).mockResolvedValueOnce({ // For the POST request in addItem
      ok: true,
      json: async () => mockNewItemFromServer,
    });

    const { result } = renderHook(() => useTree());

    await act(async () => {
      await result.current.addItem({ label: 'New Note', type: 'note' }, null);
    });

    // This assertion depends on how `insertItemRecursive` and `setTreeWithUndo` update the state
    // expect(result.current.tree).toEqual(expect.arrayContaining([mockNewItemFromServer]));
  });

});

--- tests\hooks\useTree.test.js ---
// tests/hooks/useTree.test.js
import { renderHook, act } from '@testing-library/react';
import { useTree } from '../../src/hooks/useTree';
import { LOCAL_STORAGE_KEY } from '../../src/utils/constants';

// Mocking fetch
global.fetch = jest.fn();

// Mock unicode-bidirectional
jest.mock('unicode-bidirectional', () => ({
  __esModule: true, // This is important for modules with default exports when mocking
  embeddingLevels: jest.fn(() => []), // Mock implementation
  reorder: jest.fn(text => text),     // Mock implementation
}));

// Mock SettingsContext
jest.mock('../../src/contexts/SettingsContext', () => ({
  useSettings: () => ({
    settings: {
      theme: 'system',
      defaultSortOrder: 'foldersFirstAlpha',
      autoExpandNewFolders: true,
      editorFontFamily: 'Arial',
      editorFontSize: '3',
      defaultExportFormat: 'json',
    },
    // Mock functions if your hook uses them directly, otherwise not strictly needed for all tests
    updateSetting: jest.fn(),
    resetSettings: jest.fn(),
    resetApplicationData: jest.fn(),
  }),
  // Exporting defaultSettings isn't strictly necessary for the mock if useSettings provides it
  defaultSettings: { /* your default settings object */ },
}));

// LocalStorage mock
const localStorageMock = (() => {
  let store = {};
  return {
    getItem: jest.fn(key => store[key] || null),
    setItem: jest.fn((key, value) => { store[key] = value.toString(); }),
    removeItem: jest.fn(key => { delete store[key]; }),
    clear: jest.fn(() => { store = {}; }),
    hasOwnProperty: jest.fn(key => store.hasOwnProperty(key)), // Added for completeness
    length: Object.keys(store).length, // Added for completeness
    key: jest.fn(index => Object.keys(store)[index] || null) // Added for completeness
  };
})();
Object.defineProperty(window, 'localStorage', { value: localStorageMock });


describe('useTree Hook', () => {
  beforeEach(() => {
    localStorageMock.clear();
    jest.clearAllMocks(); // Clears all mocks including fetch
    // Provide a default successful fetch response for initial load
    fetch.mockResolvedValueOnce({
      ok: true,
      json: async () => ({ notesTree: [] }), // Default to empty tree
    });
  });

  test('initializes with an attempt to fetch tree if token exists', async () => {
    localStorageMock.setItem('userToken', 'fake-token'); // Simulate logged-in user
    const { result } = renderHook(() => useTree());

    // Wait for async operations in useEffect to complete if necessary
    // For this initial test, we check immediate state before async fetch might complete in test env
    expect(result.current.tree).toEqual([]); // Initial state before fetch completes
    expect(result.current.expandedFolders).toEqual({});

    // Check that fetch was called (due to useEffect in useTree)
    // await waitFor(() => expect(fetch).toHaveBeenCalledTimes(1));
    // The above waitFor might be tricky depending on how useEffect and async calls are handled in test renderer
    // For now, we know fetch should be called if token exists
  });

  test('initializes with empty tree if localStorage is empty and no token', () => {
    localStorageMock.removeItem('userToken'); // Ensure no token
    fetch.mockResolvedValueOnce({ // Mock fetch in case it's called even without token (though it shouldn't)
      ok: true,
      json: async () => ({ notesTree: [] }),
    });
    const { result } = renderHook(() => useTree());
    expect(result.current.tree).toEqual([]);
    expect(result.current.expandedFolders).toEqual({});
    expect(localStorageMock.getItem).toHaveBeenCalledWith(LOCAL_STORAGE_KEY);
    expect(localStorageMock.getItem).toHaveBeenCalledWith(`${LOCAL_STORAGE_KEY}_expanded`);
  });


  test('loads tree from localStorage if present (and no token initially for fetch)', () => {
    const storedTree = [{ id: 'f1', type: 'folder', label: 'Folder 1', children: [] }];
    localStorageMock.setItem(LOCAL_STORAGE_KEY, JSON.stringify(storedTree));
    localStorageMock.removeItem('userToken'); // Ensure no token for this specific test case focus

    fetch.mockResolvedValueOnce({ // Mock fetch if it's still called
      ok: true,
      json: async () => ({ notesTree: [] }), // Return empty from fetch to ensure localStorage is preferred
    });

    const { result } = renderHook(() => useTree());

    // If fetch is prioritized over localStorage load, this might need adjustment
    // The current useTree loads from localStorage, then useEffect fetches if token.
    expect(result.current.tree).toEqual(storedTree);
  });

  // More comprehensive tests for addItem, deleteItem, etc., would require:
  // - Mocking `Workspace` for each specific API call (POST, PATCH, DELETE).
  // - Using `act()` from `@testing-library/react` to wrap state updates.
  // - Verifying that `setTreeWithUndo` is called with the expected new tree state.
  // These become more like integration tests for the hook.

  test.skip('addItem successfully updates the tree after API call', async () => {
    // Example of a more involved test (SKIPPED for brevity, needs full setup)
    const initialItems = [];
    localStorageMock.setItem(LOCAL_STORAGE_KEY, JSON.stringify(initialItems));
    localStorageMock.setItem('userToken', 'fake-token');

    const mockNewItemFromServer = { id: 'server-id-1', type: 'note', label: 'New Note from Server', content: '' };
    fetch.mockResolvedValueOnce({ // For initial fetch
      ok: true,
      json: async () => ({ notesTree: initialItems }),
    }).mockResolvedValueOnce({ // For the POST request in addItem
      ok: true,
      json: async () => mockNewItemFromServer,
    });

    const { result } = renderHook(() => useTree());

    await act(async () => {
      await result.current.addItem({ label: 'New Note', type: 'note' }, null);
    });

    // This assertion depends on how `insertItemRecursive` and `setTreeWithUndo` update the state
    // expect(result.current.tree).toEqual(expect.arrayContaining([mockNewItemFromServer]));
  });

});

--- tests\utils\constants.test.js ---
import { LOCAL_STORAGE_KEY } from '../../src/utils/constants';

describe('constants', () => {
  test('LOCAL_STORAGE_KEY is correct', () => {
    expect(LOCAL_STORAGE_KEY).toBe('myNotesTasksTree');
  });
});


--- tests\utils\treeUtils.test.js ---
import {
    sortItems,
    handleDrop,
    deleteItemRecursive,
    renameItemRecursive,
    insertItemRecursive,
    findItemById,
    findParentAndSiblings,
    hasSiblingWithName,
    isSelfOrDescendant,
} from '../../src/utils/treeUtils';

import {
    assignNewIds
} from '../../src/hooks/useTree';

// --- Tests for sortItems ---
describe('treeUtils.sortItems', () => { /* ... Your existing sortItems tests ... */
    test('returns empty array for invalid input', () => {
        expect(sortItems(null)).toEqual([]);
        expect(sortItems(undefined)).toEqual([]);
        expect(sortItems({})).toEqual([]);
        expect(sortItems("string")).toEqual([]);
    });
    test('returns a new sorted array, does not mutate original', () => {
        const items = [{ type: 'note', label: 'b', id: '2' }, { type: 'folder', label: 'a', id: '1' }];
        const originalItems = [...items];
        const sorted = sortItems(items);
        expect(sorted).not.toBe(items);
        expect(items).toEqual(originalItems);
        expect(sorted[0].label).toBe('a');
        expect(sorted[1].label).toBe('b');
    });
    test('sorts folders first, then notes, then tasks, then alphabetically', () => {
        const items = [{ id: 't1', type: 'task', label: 'Task A' }, { id: 'f1', type: 'folder', label: 'Folder C' }, { id: 'n1', type: 'note', label: 'Note B' }, { id: 'f2', type: 'folder', label: 'Folder A' }, { id: 't2', type: 'task', label: 'Task B' }, { id: 'n2', type: 'note', label: 'Note A' }, { id: 'f3', type: 'folder', label: 'Folder B' },];
        const sorted = sortItems(items);
        expect(sorted.map(i => i.label)).toEqual(['Folder A', 'Folder B', 'Folder C', 'Note A', 'Note B', 'Task A', 'Task B']);
        expect(sorted.map(i => i.type)).toEqual(['folder', 'folder', 'folder', 'note', 'note', 'task', 'task']);
    });
    test('handles items with missing/null properties gracefully', () => {
        const items = [{ id: '1', type: 'folder', label: 'A' }, { id: '2', type: null, label: 'B' }, { id: '3', type: 'note' }, { id: '4' }, { id: '5', type: 'task', label: 'C' },];
        expect(() => sortItems(items)).not.toThrow();
        const sorted = sortItems(items);
        expect(sorted[0].label).toBe('A');
    });
    test('handles items with children correctly (does not sort children)', () => {
        const items = [{ id: 'f1', type: 'folder', label: 'B', children: [{ id: 'f1n1', type: 'note', label: 'Z' }] }, { id: 'f2', type: 'folder', label: 'A', children: [{ id: 'f2n1', type: 'note', label: 'X' }] },];
        const sorted = sortItems(items);
        expect(sorted.map(i => i.label)).toEqual(['A', 'B']);
        expect(sorted[0].children[0].label).toBe('X');
        expect(sorted[1].children[0].label).toBe('Z');
    });
});

// --- Tests for findItemById ---
describe('treeUtils.findItemById', () => { /* ... Your existing findItemById tests ... */
    const tree = [{ id: 'f1', type: 'folder', label: 'F1', children: [{ id: 'f1n1', type: 'note', label: 'N1' }, { id: 'f1f1', type: 'folder', label: 'F11', children: [{ id: 'f1f1t1', type: 'task', label: 'T1' }] }] }, { id: 'f2', type: 'folder', label: 'F2', children: [] }, { id: 'n2', type: 'note', label: 'N2' }];
    test('returns the item if found at root', () => expect(findItemById(tree, 'n2')).toBe(tree[2]));
    test('returns the item if found nested', () => { expect(findItemById(tree, 'f1n1')).toBe(tree[0].children[0]); expect(findItemById(tree, 'f1f1t1')).toBe(tree[0].children[1].children[0]); });
    test('returns null if item not found', () => expect(findItemById(tree, 'nonexistent')).toBeNull());
    test('returns null for invalid input', () => { expect(findItemById(null, 'f1')).toBeNull(); expect(findItemById(tree, null)).toBeNull(); expect(findItemById([], 'f1')).toBeNull(); });
});

// --- Tests for findParentAndSiblings ---
describe('treeUtils.findParentAndSiblings', () => { /* ... Your existing findParentAndSiblings tests ... */
    const tree = [{ id: 'f1', type: 'folder', label: 'F1', children: [{ id: 'f1n1', type: 'note', label: 'N1' }, { id: 'f1f1', type: 'folder', label: 'F11', children: [{ id: 'f1f1t1', type: 'task', label: 'T1' }] }] }, { id: 'f2', type: 'folder', label: 'F2', children: [] }, { id: 'n2', type: 'note', label: 'N2' }];
    const treeWithEmptyFolder = [{ id: 'f1', type: 'folder', label: 'F1', children: [] }];
    test('returns correct parent and siblings for root item', () => { const result = findParentAndSiblings(tree, 'n2'); expect(result.parent).toBeNull(); expect(result.siblings).toBe(tree); expect(result.siblings.length).toBe(3); });
    test('returns correct parent and siblings for nested item', () => { const result = findParentAndSiblings(tree, 'f1n1'); expect(result.parent).toBe(tree[0]); expect(result.siblings).toBe(tree[0].children); expect(result.siblings.length).toBe(2); });
    test('returns correct parent and siblings for deeply nested item', () => { const result = findParentAndSiblings(tree, 'f1f1t1'); expect(result.parent).toBe(tree[0].children[1]); expect(result.siblings).toBe(tree[0].children[1].children); expect(result.siblings.length).toBe(1); });
    test('returns null parent and empty siblings if item not found', () => { const result = findParentAndSiblings(tree, 'nonexistent'); expect(result.parent).toBeNull(); expect(result.siblings).toEqual([]); });
    test('returns null parent and root siblings if itemId is null', () => { const result = findParentAndSiblings(tree, null); expect(result.parent).toBeNull(); expect(result.siblings).toBe(tree); });
    test('returns empty siblings for invalid tree input', () => { const result = findParentAndSiblings(null, 'f1'); expect(result.parent).toBeNull(); expect(result.siblings).toEqual([]); });
    test('handles empty children array correctly', () => { const result = findParentAndSiblings(treeWithEmptyFolder, 'f1'); expect(result.parent).toBeNull(); expect(result.siblings).toBe(treeWithEmptyFolder); });
});

// --- Tests for hasSiblingWithName ---
describe('treeUtils.hasSiblingWithName', () => { /* ... Your existing hasSiblingWithName tests ... */
    const siblings = [{ id: '1', label: 'Apple' }, { id: '2', label: 'Banana ' }, { id: '3', label: 'cherry' }, { id: '4', label: null }, { id: '5' }];
    test('returns true if name exists (case-insensitive, trimmed)', () => { expect(hasSiblingWithName(siblings, 'apple')).toBe(true); expect(hasSiblingWithName(siblings, ' APPLE ')).toBe(true); expect(hasSiblingWithName(siblings, 'Banana')).toBe(true); expect(hasSiblingWithName(siblings, 'Cherry')).toBe(true); });
    test('returns false if name does not exist', () => { expect(hasSiblingWithName(siblings, 'Orange')).toBe(false); expect(hasSiblingWithName(siblings, 'Appl')).toBe(false); });
    test('returns false for invalid input', () => { expect(hasSiblingWithName(null, 'Apple')).toBe(false); expect(hasSiblingWithName([], 'Apple')).toBe(false); expect(hasSiblingWithName(siblings, null)).toBe(false); expect(hasSiblingWithName(siblings, '')).toBe(false); expect(hasSiblingWithName(siblings, '   ')).toBe(false); });
    test('excludes item with excludeId', () => { expect(hasSiblingWithName(siblings, 'Apple', '1')).toBe(false); expect(hasSiblingWithName(siblings, 'Banana', '1')).toBe(true); expect(hasSiblingWithName(siblings, 'Banana', '2')).toBe(false); });
    test('handles siblings with null/missing labels gracefully', () => { expect(hasSiblingWithName(siblings, 'Some Name')).toBe(false); expect(hasSiblingWithName(siblings, null)).toBe(false); });
});

// --- Tests for isSelfOrDescendant ---
describe('treeUtils.isSelfOrDescendant', () => { /* ... Your existing isSelfOrDescendant tests ... */
    const tree = [{ id: 'f1', type: 'folder', label: 'F1', children: [{ id: 'f1n1', type: 'note', label: 'N1' }, { id: 'f1f1', type: 'folder', label: 'F11', children: [{ id: 'f1f1t1', type: 'task', label: 'T1' }] }] }, { id: 'f2', type: 'folder', label: 'F2', children: [] }, { id: 'n2', type: 'note', label: 'N2' }];
    test('returns true if checkItemId equals potentialTargetId', () => { expect(isSelfOrDescendant(tree, 'f1', 'f1')).toBe(true); expect(isSelfOrDescendant(tree, 'f1n1', 'f1n1')).toBe(true); });
    test('returns true if potentialTargetId is a direct child', () => { expect(isSelfOrDescendant(tree, 'f1', 'f1n1')).toBe(true); expect(isSelfOrDescendant(tree, 'f1', 'f1f1')).toBe(true); });
    test('returns true if potentialTargetId is a nested descendant', () => expect(isSelfOrDescendant(tree, 'f1', 'f1f1t1')).toBe(true));
    test('returns false if potentialTargetId is not a descendant', () => { expect(isSelfOrDescendant(tree, 'f1', 'f2')).toBe(false); expect(isSelfOrDescendant(tree, 'f1', 'n2')).toBe(false); expect(isSelfOrDescendant(tree, 'f2', 'f1n1')).toBe(false); });
    test('returns false if checkItem is not a folder (and not self)', () => { expect(isSelfOrDescendant(tree, 'f1n1', 'f1f1t1')).toBe(false); expect(isSelfOrDescendant(tree, 'n2', 'f1')).toBe(false); });
    test('returns false for invalid IDs or tree', () => { expect(isSelfOrDescendant(null, 'f1', 'f1n1')).toBe(false); expect(isSelfOrDescendant(tree, null, 'f1n1')).toBe(false); expect(isSelfOrDescendant(tree, 'f1', null)).toBe(false); expect(isSelfOrDescendant(tree, 'nonexistent', 'f1n1')).toBe(false); expect(isSelfOrDescendant(tree, 'f1', 'nonexistent')).toBe(false); });
});

// --- Tests for deleteItemRecursive ---
describe('treeUtils.deleteItemRecursive', () => { /* ... Your existing deleteItemRecursive tests ... */
    const tree = [{ id: 'f1', type: 'folder', label: 'F1', children: [{ id: 'f1n1', type: 'note', label: 'N1' }] }, { id: 'n2', type: 'note', label: 'N2' }];
    test('removes root item', () => { const result = deleteItemRecursive(tree, 'n2'); expect(result.length).toBe(1); expect(result[0].id).toBe('f1'); });
    test('removes nested item', () => { const result = deleteItemRecursive(tree, 'f1n1'); expect(result.length).toBe(2); expect(result[0].id).toBe('f1'); expect(result[0].children.length).toBe(0); });
    test('returns new tree instance if ID not found but is an array', () => { const result = deleteItemRecursive(tree, 'nonexistent'); expect(result).toEqual(tree); expect(result).not.toBe(tree); });
    test('handles invalid input', () => { expect(deleteItemRecursive(null, 'id')).toEqual([]); expect(deleteItemRecursive(tree, null)).toEqual(tree); });
});

// --- Tests for renameItemRecursive ---
describe('treeUtils.renameItemRecursive', () => { /* ... Your existing renameItemRecursive tests ... */
    const tree = [{ id: 'f1', type: 'folder', label: 'F1', children: [{ id: 'f1n1', type: 'note', label: 'N1' }] }, { id: 'n2', type: 'note', label: 'N2' }];
    test('renames root item', () => { const result = renameItemRecursive(tree, 'n2', ' New Name '); expect(result[1].label).toBe('New Name'); expect(result[0].label).toBe('F1'); });
    test('renames nested item', () => { const result = renameItemRecursive(tree, 'f1n1', 'Nested New'); expect(result[0].children[0].label).toBe('Nested New'); expect(result[0].label).toBe('F1'); });
    test('returns new tree instance if ID not found but is an array', () => { const result = renameItemRecursive(tree, 'nonexistent', 'New Name'); expect(result).toEqual(tree); expect(result).not.toBe(tree); });
    test('handles invalid input', () => { expect(renameItemRecursive(null, 'id', 'Name')).toEqual([]); expect(renameItemRecursive(tree, null, 'Name')).toEqual(tree); });
});

// --- Tests for insertItemRecursive ---
describe('treeUtils.insertItemRecursive', () => { /* ... Your existing insertItemRecursive tests ... */
    const tree = [{ id: 'f1', type: 'folder', label: 'F1', children: [{ id: 'f1n1', type: 'note', label: 'N1' }] }, { id: 'n2', type: 'note', label: 'N2' }];
    const newItem = { id: 'new', type: 'task', label: 'New Task' };
    test('inserts item at root if targetFolderId is null', () => { const result = insertItemRecursive(tree, null, newItem); expect(result.length).toBe(3); expect(result.map(i => i.id)).toEqual(['f1', 'n2', 'new']); });
    test('inserts item into target folder and sorts', () => { const newItemB = { id: 'newB', type: 'task', label: 'B Task' }; const result = insertItemRecursive(tree, 'f1', newItemB); expect(result[0].id).toBe('f1'); expect(result[0].children.length).toBe(2); expect(result[0].children.map(c => c.label)).toEqual(['N1', 'B Task']); });
    test('returns new tree instance if targetFolderId not found', () => { const result = insertItemRecursive(tree, 'nonexistent', newItem); expect(result).toEqual(tree); expect(result).not.toBe(tree); });
    test('returns new tree instance if target is not a folder', () => { const result = insertItemRecursive(tree, 'n2', newItem); expect(result).toEqual(tree); expect(result).not.toBe(tree); });
    test('handles invalid input', () => { expect(insertItemRecursive(null, null, newItem)).toEqual([newItem]); expect(insertItemRecursive(null, 'f1', newItem)).toEqual([]); expect(insertItemRecursive([], null, newItem)).toEqual([newItem]); });
});

// --- Tests for handleDrop (Validation Focus) ---
describe('treeUtils.handleDrop (Validation Focus)', () => { /* ... Your existing handleDrop tests ... */
    let initialTree; const alertSpy = jest.spyOn(window, 'alert').mockImplementation(() => { });
    beforeEach(() => { initialTree = [{ id: 'f1', type: 'folder', label: 'Folder 1', children: [{ id: 'n1', type: 'note', label: 'Note 1' }] }, { id: 'f2', type: 'folder', label: 'Folder 2', children: [{ id: 'n2', type: 'note', label: 'Note 1' }] }]; alertSpy.mockClear(); });
    afterAll(() => { alertSpy.mockRestore(); });
    test('returns null if dropping folder into self (no alert)', () => { expect(handleDrop(initialTree, 'f1', 'f1')).toBeNull(); expect(alertSpy).not.toHaveBeenCalled(); }); // Self-drop handled by initial check
    test('returns null and alerts if dropping parent folder into child', () => { const treeWithNest = [{ id: 'a', type: 'folder', children: [{ id: 'b', type: 'folder' }] }]; expect(handleDrop(treeWithNest, 'b', 'a')).toBeNull(); expect(alertSpy).toHaveBeenCalledWith(expect.stringContaining("Cannot drop folder")); });
    test('returns null and alerts if name conflict exists in target', () => { expect(handleDrop(initialTree, 'f2', 'n1')).toBeNull(); expect(alertSpy).toHaveBeenCalledWith(expect.stringContaining("already exists in the target folder 'Folder 2'")); });
    test('allows drop if name conflict does NOT exist', () => { const tree = [{ id: 'f1', type: 'folder', label: 'Folder 1', children: [{ id: 'n1', type: 'note', label: 'Unique Note' }] }, { id: 'f2', type: 'folder', label: 'Folder 2', children: [{ id: 'n2', type: 'note', label: 'Another Note' }] }]; const newTree = handleDrop(tree, 'f2', 'n1'); expect(newTree).not.toBeNull(); expect(alertSpy).not.toHaveBeenCalled(); const targetFolder = newTree.find(i => i.id === 'f2'); expect(targetFolder.children.length).toBe(2); expect(targetFolder.children.map(c => c.label)).toContain('Unique Note'); });
});

describe('treeUtils.assignNewIds', () => {
    test('assigns a new ID if isDuplication is true', () => {
        const item = { id: 'old-id', label: 'Test', type: 'note' };
        const newItem = assignNewIds(item, true);
        expect(newItem.id).not.toBe('old-id');
        expect(newItem.id).toMatch(/^client-/);
    });

    test('assigns a new ID if item has no ID', () => {
        const item = { label: 'Test', type: 'note' }; // No id
        const newItem = assignNewIds(item, false);
        expect(newItem.id).toMatch(/^client-/);
    });

    test('assigns a new ID if item ID starts with "temp-"', () => {
        const item = { id: 'temp-123', label: 'Test', type: 'note' };
        const newItem = assignNewIds(item, false);
        expect(newItem.id).not.toBe('temp-123');
        expect(newItem.id).toMatch(/^client-/);
    });

    test('assigns a new ID if item ID starts with "client-" and isDuplication is true', () => {
        const item = { id: 'client-abc', label: 'Test', type: 'note' };
        const newItem = assignNewIds(item, true); // Duplicating an already client-ID'd item
        expect(newItem.id).not.toBe('client-abc');
        expect(newItem.id).toMatch(/^client-/);
    });

    test('keeps existing ID if not duplication and ID is not temp/client', () => {
        const item = { id: 'server-id-123', label: 'Test', type: 'note' };
        const newItem = assignNewIds(item, false);
        expect(newItem.id).toBe('server-id-123');
    });

    test('recursively assigns new IDs to children of a folder if isDuplication is true', () => {
        const folder = {
            id: 'f-old', type: 'folder', label: 'F',
            children: [
                { id: 'c1-old', type: 'note', label: 'N1' },
                {
                    id: 'c2-old', type: 'folder', label: 'SF', children: [
                        { id: 'gc1-old', type: 'task', label: 'T1' }
                    ]
                }
            ]
        };
        const newFolder = assignNewIds(folder, true);
        expect(newFolder.id).not.toBe('f-old');
        expect(newFolder.id).toMatch(/^client-/);
        expect(newFolder.children[0].id).not.toBe('c1-old');
        expect(newFolder.children[0].id).toMatch(/^client-/);
        expect(newFolder.children[1].id).not.toBe('c2-old');
        expect(newFolder.children[1].id).toMatch(/^client-/);
        expect(newFolder.children[1].children[0].id).not.toBe('gc1-old');
        expect(newFolder.children[1].children[0].id).toMatch(/^client-/);
    });

    test('does not change children IDs if not duplication and parent ID is stable', () => {
        const folder = {
            id: 'server-f', type: 'folder', label: 'F',
            children: [{ id: 'server-c1', type: 'note', label: 'N1' }]
        };
        const newFolder = assignNewIds(folder, false);
        expect(newFolder.id).toBe('server-f');
        expect(newFolder.children[0].id).toBe('server-c1');
    });
});

--- tests\utils\constants.test.js ---
import { LOCAL_STORAGE_KEY } from '../../src/utils/constants';

describe('constants', () => {
  test('LOCAL_STORAGE_KEY is correct', () => {
    expect(LOCAL_STORAGE_KEY).toBe('myNotesTasksTree');
  });
});


--- tests\utils\treeUtils.test.js ---
import {
    sortItems,
    handleDrop,
    deleteItemRecursive,
    renameItemRecursive,
    insertItemRecursive,
    findItemById,
    findParentAndSiblings,
    hasSiblingWithName,
    isSelfOrDescendant,
} from '../../src/utils/treeUtils';

import {
    assignNewIds
} from '../../src/hooks/useTree';

// --- Tests for sortItems ---
describe('treeUtils.sortItems', () => { /* ... Your existing sortItems tests ... */
    test('returns empty array for invalid input', () => {
        expect(sortItems(null)).toEqual([]);
        expect(sortItems(undefined)).toEqual([]);
        expect(sortItems({})).toEqual([]);
        expect(sortItems("string")).toEqual([]);
    });
    test('returns a new sorted array, does not mutate original', () => {
        const items = [{ type: 'note', label: 'b', id: '2' }, { type: 'folder', label: 'a', id: '1' }];
        const originalItems = [...items];
        const sorted = sortItems(items);
        expect(sorted).not.toBe(items);
        expect(items).toEqual(originalItems);
        expect(sorted[0].label).toBe('a');
        expect(sorted[1].label).toBe('b');
    });
    test('sorts folders first, then notes, then tasks, then alphabetically', () => {
        const items = [{ id: 't1', type: 'task', label: 'Task A' }, { id: 'f1', type: 'folder', label: 'Folder C' }, { id: 'n1', type: 'note', label: 'Note B' }, { id: 'f2', type: 'folder', label: 'Folder A' }, { id: 't2', type: 'task', label: 'Task B' }, { id: 'n2', type: 'note', label: 'Note A' }, { id: 'f3', type: 'folder', label: 'Folder B' },];
        const sorted = sortItems(items);
        expect(sorted.map(i => i.label)).toEqual(['Folder A', 'Folder B', 'Folder C', 'Note A', 'Note B', 'Task A', 'Task B']);
        expect(sorted.map(i => i.type)).toEqual(['folder', 'folder', 'folder', 'note', 'note', 'task', 'task']);
    });
    test('handles items with missing/null properties gracefully', () => {
        const items = [{ id: '1', type: 'folder', label: 'A' }, { id: '2', type: null, label: 'B' }, { id: '3', type: 'note' }, { id: '4' }, { id: '5', type: 'task', label: 'C' },];
        expect(() => sortItems(items)).not.toThrow();
        const sorted = sortItems(items);
        expect(sorted[0].label).toBe('A');
    });
    test('handles items with children correctly (does not sort children)', () => {
        const items = [{ id: 'f1', type: 'folder', label: 'B', children: [{ id: 'f1n1', type: 'note', label: 'Z' }] }, { id: 'f2', type: 'folder', label: 'A', children: [{ id: 'f2n1', type: 'note', label: 'X' }] },];
        const sorted = sortItems(items);
        expect(sorted.map(i => i.label)).toEqual(['A', 'B']);
        expect(sorted[0].children[0].label).toBe('X');
        expect(sorted[1].children[0].label).toBe('Z');
    });
});

// --- Tests for findItemById ---
describe('treeUtils.findItemById', () => { /* ... Your existing findItemById tests ... */
    const tree = [{ id: 'f1', type: 'folder', label: 'F1', children: [{ id: 'f1n1', type: 'note', label: 'N1' }, { id: 'f1f1', type: 'folder', label: 'F11', children: [{ id: 'f1f1t1', type: 'task', label: 'T1' }] }] }, { id: 'f2', type: 'folder', label: 'F2', children: [] }, { id: 'n2', type: 'note', label: 'N2' }];
    test('returns the item if found at root', () => expect(findItemById(tree, 'n2')).toBe(tree[2]));
    test('returns the item if found nested', () => { expect(findItemById(tree, 'f1n1')).toBe(tree[0].children[0]); expect(findItemById(tree, 'f1f1t1')).toBe(tree[0].children[1].children[0]); });
    test('returns null if item not found', () => expect(findItemById(tree, 'nonexistent')).toBeNull());
    test('returns null for invalid input', () => { expect(findItemById(null, 'f1')).toBeNull(); expect(findItemById(tree, null)).toBeNull(); expect(findItemById([], 'f1')).toBeNull(); });
});

// --- Tests for findParentAndSiblings ---
describe('treeUtils.findParentAndSiblings', () => { /* ... Your existing findParentAndSiblings tests ... */
    const tree = [{ id: 'f1', type: 'folder', label: 'F1', children: [{ id: 'f1n1', type: 'note', label: 'N1' }, { id: 'f1f1', type: 'folder', label: 'F11', children: [{ id: 'f1f1t1', type: 'task', label: 'T1' }] }] }, { id: 'f2', type: 'folder', label: 'F2', children: [] }, { id: 'n2', type: 'note', label: 'N2' }];
    const treeWithEmptyFolder = [{ id: 'f1', type: 'folder', label: 'F1', children: [] }];
    test('returns correct parent and siblings for root item', () => { const result = findParentAndSiblings(tree, 'n2'); expect(result.parent).toBeNull(); expect(result.siblings).toBe(tree); expect(result.siblings.length).toBe(3); });
    test('returns correct parent and siblings for nested item', () => { const result = findParentAndSiblings(tree, 'f1n1'); expect(result.parent).toBe(tree[0]); expect(result.siblings).toBe(tree[0].children); expect(result.siblings.length).toBe(2); });
    test('returns correct parent and siblings for deeply nested item', () => { const result = findParentAndSiblings(tree, 'f1f1t1'); expect(result.parent).toBe(tree[0].children[1]); expect(result.siblings).toBe(tree[0].children[1].children); expect(result.siblings.length).toBe(1); });
    test('returns null parent and empty siblings if item not found', () => { const result = findParentAndSiblings(tree, 'nonexistent'); expect(result.parent).toBeNull(); expect(result.siblings).toEqual([]); });
    test('returns null parent and root siblings if itemId is null', () => { const result = findParentAndSiblings(tree, null); expect(result.parent).toBeNull(); expect(result.siblings).toBe(tree); });
    test('returns empty siblings for invalid tree input', () => { const result = findParentAndSiblings(null, 'f1'); expect(result.parent).toBeNull(); expect(result.siblings).toEqual([]); });
    test('handles empty children array correctly', () => { const result = findParentAndSiblings(treeWithEmptyFolder, 'f1'); expect(result.parent).toBeNull(); expect(result.siblings).toBe(treeWithEmptyFolder); });
});

// --- Tests for hasSiblingWithName ---
describe('treeUtils.hasSiblingWithName', () => { /* ... Your existing hasSiblingWithName tests ... */
    const siblings = [{ id: '1', label: 'Apple' }, { id: '2', label: 'Banana ' }, { id: '3', label: 'cherry' }, { id: '4', label: null }, { id: '5' }];
    test('returns true if name exists (case-insensitive, trimmed)', () => { expect(hasSiblingWithName(siblings, 'apple')).toBe(true); expect(hasSiblingWithName(siblings, ' APPLE ')).toBe(true); expect(hasSiblingWithName(siblings, 'Banana')).toBe(true); expect(hasSiblingWithName(siblings, 'Cherry')).toBe(true); });
    test('returns false if name does not exist', () => { expect(hasSiblingWithName(siblings, 'Orange')).toBe(false); expect(hasSiblingWithName(siblings, 'Appl')).toBe(false); });
    test('returns false for invalid input', () => { expect(hasSiblingWithName(null, 'Apple')).toBe(false); expect(hasSiblingWithName([], 'Apple')).toBe(false); expect(hasSiblingWithName(siblings, null)).toBe(false); expect(hasSiblingWithName(siblings, '')).toBe(false); expect(hasSiblingWithName(siblings, '   ')).toBe(false); });
    test('excludes item with excludeId', () => { expect(hasSiblingWithName(siblings, 'Apple', '1')).toBe(false); expect(hasSiblingWithName(siblings, 'Banana', '1')).toBe(true); expect(hasSiblingWithName(siblings, 'Banana', '2')).toBe(false); });
    test('handles siblings with null/missing labels gracefully', () => { expect(hasSiblingWithName(siblings, 'Some Name')).toBe(false); expect(hasSiblingWithName(siblings, null)).toBe(false); });
});

// --- Tests for isSelfOrDescendant ---
describe('treeUtils.isSelfOrDescendant', () => { /* ... Your existing isSelfOrDescendant tests ... */
    const tree = [{ id: 'f1', type: 'folder', label: 'F1', children: [{ id: 'f1n1', type: 'note', label: 'N1' }, { id: 'f1f1', type: 'folder', label: 'F11', children: [{ id: 'f1f1t1', type: 'task', label: 'T1' }] }] }, { id: 'f2', type: 'folder', label: 'F2', children: [] }, { id: 'n2', type: 'note', label: 'N2' }];
    test('returns true if checkItemId equals potentialTargetId', () => { expect(isSelfOrDescendant(tree, 'f1', 'f1')).toBe(true); expect(isSelfOrDescendant(tree, 'f1n1', 'f1n1')).toBe(true); });
    test('returns true if potentialTargetId is a direct child', () => { expect(isSelfOrDescendant(tree, 'f1', 'f1n1')).toBe(true); expect(isSelfOrDescendant(tree, 'f1', 'f1f1')).toBe(true); });
    test('returns true if potentialTargetId is a nested descendant', () => expect(isSelfOrDescendant(tree, 'f1', 'f1f1t1')).toBe(true));
    test('returns false if potentialTargetId is not a descendant', () => { expect(isSelfOrDescendant(tree, 'f1', 'f2')).toBe(false); expect(isSelfOrDescendant(tree, 'f1', 'n2')).toBe(false); expect(isSelfOrDescendant(tree, 'f2', 'f1n1')).toBe(false); });
    test('returns false if checkItem is not a folder (and not self)', () => { expect(isSelfOrDescendant(tree, 'f1n1', 'f1f1t1')).toBe(false); expect(isSelfOrDescendant(tree, 'n2', 'f1')).toBe(false); });
    test('returns false for invalid IDs or tree', () => { expect(isSelfOrDescendant(null, 'f1', 'f1n1')).toBe(false); expect(isSelfOrDescendant(tree, null, 'f1n1')).toBe(false); expect(isSelfOrDescendant(tree, 'f1', null)).toBe(false); expect(isSelfOrDescendant(tree, 'nonexistent', 'f1n1')).toBe(false); expect(isSelfOrDescendant(tree, 'f1', 'nonexistent')).toBe(false); });
});

// --- Tests for deleteItemRecursive ---
describe('treeUtils.deleteItemRecursive', () => { /* ... Your existing deleteItemRecursive tests ... */
    const tree = [{ id: 'f1', type: 'folder', label: 'F1', children: [{ id: 'f1n1', type: 'note', label: 'N1' }] }, { id: 'n2', type: 'note', label: 'N2' }];
    test('removes root item', () => { const result = deleteItemRecursive(tree, 'n2'); expect(result.length).toBe(1); expect(result[0].id).toBe('f1'); });
    test('removes nested item', () => { const result = deleteItemRecursive(tree, 'f1n1'); expect(result.length).toBe(2); expect(result[0].id).toBe('f1'); expect(result[0].children.length).toBe(0); });
    test('returns new tree instance if ID not found but is an array', () => { const result = deleteItemRecursive(tree, 'nonexistent'); expect(result).toEqual(tree); expect(result).not.toBe(tree); });
    test('handles invalid input', () => { expect(deleteItemRecursive(null, 'id')).toEqual([]); expect(deleteItemRecursive(tree, null)).toEqual(tree); });
});

// --- Tests for renameItemRecursive ---
describe('treeUtils.renameItemRecursive', () => { /* ... Your existing renameItemRecursive tests ... */
    const tree = [{ id: 'f1', type: 'folder', label: 'F1', children: [{ id: 'f1n1', type: 'note', label: 'N1' }] }, { id: 'n2', type: 'note', label: 'N2' }];
    test('renames root item', () => { const result = renameItemRecursive(tree, 'n2', ' New Name '); expect(result[1].label).toBe('New Name'); expect(result[0].label).toBe('F1'); });
    test('renames nested item', () => { const result = renameItemRecursive(tree, 'f1n1', 'Nested New'); expect(result[0].children[0].label).toBe('Nested New'); expect(result[0].label).toBe('F1'); });
    test('returns new tree instance if ID not found but is an array', () => { const result = renameItemRecursive(tree, 'nonexistent', 'New Name'); expect(result).toEqual(tree); expect(result).not.toBe(tree); });
    test('handles invalid input', () => { expect(renameItemRecursive(null, 'id', 'Name')).toEqual([]); expect(renameItemRecursive(tree, null, 'Name')).toEqual(tree); });
});

// --- Tests for insertItemRecursive ---
describe('treeUtils.insertItemRecursive', () => { /* ... Your existing insertItemRecursive tests ... */
    const tree = [{ id: 'f1', type: 'folder', label: 'F1', children: [{ id: 'f1n1', type: 'note', label: 'N1' }] }, { id: 'n2', type: 'note', label: 'N2' }];
    const newItem = { id: 'new', type: 'task', label: 'New Task' };
    test('inserts item at root if targetFolderId is null', () => { const result = insertItemRecursive(tree, null, newItem); expect(result.length).toBe(3); expect(result.map(i => i.id)).toEqual(['f1', 'n2', 'new']); });
    test('inserts item into target folder and sorts', () => { const newItemB = { id: 'newB', type: 'task', label: 'B Task' }; const result = insertItemRecursive(tree, 'f1', newItemB); expect(result[0].id).toBe('f1'); expect(result[0].children.length).toBe(2); expect(result[0].children.map(c => c.label)).toEqual(['N1', 'B Task']); });
    test('returns new tree instance if targetFolderId not found', () => { const result = insertItemRecursive(tree, 'nonexistent', newItem); expect(result).toEqual(tree); expect(result).not.toBe(tree); });
    test('returns new tree instance if target is not a folder', () => { const result = insertItemRecursive(tree, 'n2', newItem); expect(result).toEqual(tree); expect(result).not.toBe(tree); });
    test('handles invalid input', () => { expect(insertItemRecursive(null, null, newItem)).toEqual([newItem]); expect(insertItemRecursive(null, 'f1', newItem)).toEqual([]); expect(insertItemRecursive([], null, newItem)).toEqual([newItem]); });
});

// --- Tests for handleDrop (Validation Focus) ---
describe('treeUtils.handleDrop (Validation Focus)', () => { /* ... Your existing handleDrop tests ... */
    let initialTree; const alertSpy = jest.spyOn(window, 'alert').mockImplementation(() => { });
    beforeEach(() => { initialTree = [{ id: 'f1', type: 'folder', label: 'Folder 1', children: [{ id: 'n1', type: 'note', label: 'Note 1' }] }, { id: 'f2', type: 'folder', label: 'Folder 2', children: [{ id: 'n2', type: 'note', label: 'Note 1' }] }]; alertSpy.mockClear(); });
    afterAll(() => { alertSpy.mockRestore(); });
    test('returns null if dropping folder into self (no alert)', () => { expect(handleDrop(initialTree, 'f1', 'f1')).toBeNull(); expect(alertSpy).not.toHaveBeenCalled(); }); // Self-drop handled by initial check
    test('returns null and alerts if dropping parent folder into child', () => { const treeWithNest = [{ id: 'a', type: 'folder', children: [{ id: 'b', type: 'folder' }] }]; expect(handleDrop(treeWithNest, 'b', 'a')).toBeNull(); expect(alertSpy).toHaveBeenCalledWith(expect.stringContaining("Cannot drop folder")); });
    test('returns null and alerts if name conflict exists in target', () => { expect(handleDrop(initialTree, 'f2', 'n1')).toBeNull(); expect(alertSpy).toHaveBeenCalledWith(expect.stringContaining("already exists in the target folder 'Folder 2'")); });
    test('allows drop if name conflict does NOT exist', () => { const tree = [{ id: 'f1', type: 'folder', label: 'Folder 1', children: [{ id: 'n1', type: 'note', label: 'Unique Note' }] }, { id: 'f2', type: 'folder', label: 'Folder 2', children: [{ id: 'n2', type: 'note', label: 'Another Note' }] }]; const newTree = handleDrop(tree, 'f2', 'n1'); expect(newTree).not.toBeNull(); expect(alertSpy).not.toHaveBeenCalled(); const targetFolder = newTree.find(i => i.id === 'f2'); expect(targetFolder.children.length).toBe(2); expect(targetFolder.children.map(c => c.label)).toContain('Unique Note'); });
});

describe('treeUtils.assignNewIds', () => {
    test('assigns a new ID if isDuplication is true', () => {
        const item = { id: 'old-id', label: 'Test', type: 'note' };
        const newItem = assignNewIds(item, true);
        expect(newItem.id).not.toBe('old-id');
        expect(newItem.id).toMatch(/^client-/);
    });

    test('assigns a new ID if item has no ID', () => {
        const item = { label: 'Test', type: 'note' }; // No id
        const newItem = assignNewIds(item, false);
        expect(newItem.id).toMatch(/^client-/);
    });

    test('assigns a new ID if item ID starts with "temp-"', () => {
        const item = { id: 'temp-123', label: 'Test', type: 'note' };
        const newItem = assignNewIds(item, false);
        expect(newItem.id).not.toBe('temp-123');
        expect(newItem.id).toMatch(/^client-/);
    });

    test('assigns a new ID if item ID starts with "client-" and isDuplication is true', () => {
        const item = { id: 'client-abc', label: 'Test', type: 'note' };
        const newItem = assignNewIds(item, true); // Duplicating an already client-ID'd item
        expect(newItem.id).not.toBe('client-abc');
        expect(newItem.id).toMatch(/^client-/);
    });

    test('keeps existing ID if not duplication and ID is not temp/client', () => {
        const item = { id: 'server-id-123', label: 'Test', type: 'note' };
        const newItem = assignNewIds(item, false);
        expect(newItem.id).toBe('server-id-123');
    });

    test('recursively assigns new IDs to children of a folder if isDuplication is true', () => {
        const folder = {
            id: 'f-old', type: 'folder', label: 'F',
            children: [
                { id: 'c1-old', type: 'note', label: 'N1' },
                {
                    id: 'c2-old', type: 'folder', label: 'SF', children: [
                        { id: 'gc1-old', type: 'task', label: 'T1' }
                    ]
                }
            ]
        };
        const newFolder = assignNewIds(folder, true);
        expect(newFolder.id).not.toBe('f-old');
        expect(newFolder.id).toMatch(/^client-/);
        expect(newFolder.children[0].id).not.toBe('c1-old');
        expect(newFolder.children[0].id).toMatch(/^client-/);
        expect(newFolder.children[1].id).not.toBe('c2-old');
        expect(newFolder.children[1].id).toMatch(/^client-/);
        expect(newFolder.children[1].children[0].id).not.toBe('gc1-old');
        expect(newFolder.children[1].children[0].id).toMatch(/^client-/);
    });

    test('does not change children IDs if not duplication and parent ID is stable', () => {
        const folder = {
            id: 'server-f', type: 'folder', label: 'F',
            children: [{ id: 'server-c1', type: 'note', label: 'N1' }]
        };
        const newFolder = assignNewIds(folder, false);
        expect(newFolder.id).toBe('server-f');
        expect(newFolder.children[0].id).toBe('server-c1');
    });
});

