--- src\components\AboutDialog.jsx ---
// src/components/AboutDialog.jsx
import React from "react";
import packageJson from "../../package.json";

const AboutDialog = ({ isOpen, onClose }) => {
  if (!isOpen) return null;

  const appName = "Notes & Tasks App";
  const appVersion = packageJson.version; // Replace this dynamically if needed
  const currentYear = new Date().getFullYear();

  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex justify-center items-center z-50">
      <div className="bg-white dark:bg-zinc-800 p-6 rounded shadow-lg w-96 text-center">
        <h2 className="text-xl font-bold mb-4">About {appName}</h2>
        <div className="space-y-2 mb-6 text-zinc-800 dark:text-zinc-200">
          <p>{appName} &copy; {currentYear}</p>
          <p>Version: {appVersion}</p>
        </div>
        <button
          onClick={onClose}
          className="px-5 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50"
          autoFocus
        >
          Close
        </button>
      </div>
    </div>
  );
};

export default AboutDialog;


--- src\components\AddDialog.jsx ---
// src/components/AddDialog.jsx
import React, { useEffect } from "react"; // Import useEffect

const AddDialog = ({
  isOpen,
  newItemType,
  newItemLabel,
  // showError, // Replaced by errorMessage
  onLabelChange,
  onAdd,
  onCancel,
  errorMessage, // New prop for specific error messages
}) => {
  if (!isOpen) return null;

  const inputRef = React.useRef(null); // Ref for the input element

  // Focus the input when the dialog opens
  useEffect(() => {
    if (isOpen && inputRef.current) {
      inputRef.current.focus();
      // Select text if it's not empty (useful if reopening after error)
      // if (newItemLabel) {
      //   inputRef.current.select();
      // }
    }
  }, [isOpen]); // Dependency array includes isOpen


  const handleSubmit = (e) => {
    e.preventDefault();
    onAdd(); // onAdd should now handle validation feedback
  };

  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex justify-center items-center z-50">
      <div className="bg-white dark:bg-zinc-800 p-6 rounded shadow-lg w-96">
        <h2 className="text-lg font-bold mb-4">Add {newItemType}</h2>
        <form onSubmit={handleSubmit}>
          <input
            ref={inputRef} // Assign ref to the input
            type="text"
            value={newItemLabel}
            onChange={onLabelChange}
            className={`border p-2 rounded w-full mb-2 text-gray-900 dark:text-gray ${errorMessage ? 'border-red-500' : 'border-gray-300 dark:border-gray-600'}`} // Highlight if error
            placeholder={`Enter ${newItemType} name`}
            // autoFocus // Replaced by useEffect focus management
            aria-invalid={!!errorMessage} // Accessibility
            aria-describedby={errorMessage ? "add-error-message" : undefined}
          />
          {/* Display specific error message */}
          {errorMessage && (
            <p id="add-error-message" className="text-red-600 text-sm mb-2">{errorMessage}</p>
          )}
          <div className="mt-4 flex justify-end space-x-2">
            <button
              type="button"
              onClick={onCancel}
              className="px-4 py-2 border rounded dark:border-gray-600 hover:bg-gray-100 dark:hover:bg-gray-700"
            >
              Cancel
            </button>
            <button
              type="submit"
              className="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 disabled:opacity-50"
              // Optionally disable add button if label is empty, though validation handles it
              // disabled={!newItemLabel.trim()}
            >
              Add
            </button>
          </div>
        </form>
      </div>
    </div>
  );
};

export default AddDialog;

--- src\components\ContentEditor.jsx ---
// src/components/ContentEditor.jsx
import React, { useState, useEffect, useCallback } from "react";
import EditorPane from "./EditorPane";

// Debounce function (from previous step)
function debounce(func, delay) {
  let timeoutId;
  return function (...args) {
    clearTimeout(timeoutId);
    timeoutId = setTimeout(() => {
      func.apply(this, args);
    }, delay);
  };
}

const ContentEditor = ({
  item,
  onSaveContent,
  defaultFontFamily,
  defaultFontSize,
}) => {
  if (!item) {
    console.error(
      "ContentEditor RENDER ERROR: Received null or undefined 'item' prop."
    );
    return (
      <div className="p-4 text-red-500 dark:text-red-400">
        Error: Item data is missing. Cannot display editor.
      </div>
    );
  }

  const [body, setBody] = useState(item.content ?? "");

  useEffect(() => {
    setBody(item.content ?? "");
  }, [item.content, item.id]);

  const debouncedSaveContent = useCallback(
    debounce((itemId, newHtml) => {
      onSaveContent(itemId, newHtml);
    }, 1000),
    [onSaveContent]
  );

  const handleChange = (html) => {
    setBody(html);
    debouncedSaveContent(item.id, html);
  };

  return (
    // This div defines the overall structure for the content view area.
    // - flex flex-col: Stacks children (title, editor pane) vertically.
    // - h-full: Takes the full height available from its parent Panel in App.jsx.
    // - overflow-hidden: Crucial. Ensures that this container doesn't scroll.
    //                    Instead, EditorPane's internal scrollable area will handle it.
    <div className="flex flex-col h-full overflow-hidden">
      {/* Item Title */}
      {/* - flex-shrink-0: Prevents this title area from shrinking if space is scarce. */}
      {/* - Styling classes for padding, font, color, etc. */}
      <h2 className="text-xl font-semibold mb-3 px-4 pt-4 break-words text-zinc-800 dark:text-zinc-100 flex-shrink-0">
        {item.label}
      </h2>

      {/* Editor Pane */}
      {/* - EditorPane itself is now responsible for its internal layout:
            - Toolbar fixed at its top.
            - Content area below toolbar scrollable.
          - It will grow to fill the remaining vertical space in this flex container (due to flex-grow in its own root).
      */}
      <EditorPane
        html={body}
        onChange={handleChange}
        defaultFontFamily={defaultFontFamily}
        defaultFontSize={defaultFontSize}
      />
    </div>
  );
};

export default ContentEditor;


--- src\components\ContextMenu.jsx ---
// src/components/ContextMenu.jsx
import React, { useRef, useEffect } from "react";
import { Scissors, Copy, ClipboardPaste, Upload, Download } from "lucide-react";

const ContextMenu = ({
  visible,
  x,
  y,
  item,
  isEmptyArea,
  clipboardItem,
  // Actions
  onAddRootFolder,
  onAddFolder,
  onAddNote,
  onAddTask,
  onRename,
  onDelete,
  onCopy,
  onCut,
  onPaste,
  onDuplicate,
  // Modified Import/Export handlers accepting context
  onExportItem,
  onImportItem,
  onExportTree,
  onImportTree,
  onClose,
}) => {
  const contextMenuRef = useRef(null);

  useEffect(() => {
    const handleOutsideClick = (e) => {
      if (
        visible &&
        contextMenuRef.current &&
        !contextMenuRef.current.contains(e.target)
      ) {
        onClose();
      }
    };
    const handleEscapeKey = (e) => {
      if (e.key === "Escape" && visible) {
        onClose();
      }
    };
    window.addEventListener("mousedown", handleOutsideClick);
    window.addEventListener("keydown", handleEscapeKey);
    return () => {
      window.removeEventListener("mousedown", handleOutsideClick);
      window.removeEventListener("keydown", handleEscapeKey);
    };
  }, [visible, onClose]);

  if (!visible) return null;

  const canPaste = !!clipboardItem;
  const itemPadding = "px-4 py-2.5 sm:py-2"; // Consistent padding for items

  return (
    <div
      ref={contextMenuRef}
      className="fixed z-50 bg-white dark:bg-zinc-800 border border-zinc-500 rounded shadow-md text-base md:text-sm min-w-[180px]" // Adjusted base font size
      style={{ top: y, left: x }}
    >
      {/* --- Actions for Empty Area --- */}
      {isEmptyArea && (
        <>
          <button
            className={`block w-full ${itemPadding} text-left hover:bg-zinc-100 dark:hover:bg-zinc-700 flex items-center gap-2`}
            onClick={() => {
              onAddRootFolder();
              onClose();
            }}
          >
            ‚ûï Add Root Folder
          </button>
          <hr className="my-1 border-zinc-300 dark:border-zinc-600" />
          {canPaste && (
            <button
              className={`block w-full ${itemPadding} text-left flex items-center gap-2 hover:bg-zinc-100 dark:hover:bg-zinc-700`}
              onClick={() => {
                onPaste();
                onClose();
              }}
              title="Paste item at root"
            >
              <ClipboardPaste className="w-4 h-4" /> Paste
            </button>
          )}
          {canPaste && (
            <hr className="my-1 border-zinc-300 dark:border-zinc-600" />
          )}
          <button
            className={`block w-full ${itemPadding} text-left hover:bg-zinc-100 dark:hover:bg-zinc-700 flex items-center gap-2`}
            onClick={() => {
              onExportTree();
              onClose();
            }}
            title="Export the entire tree"
          >
            <Download className="w-4 h-4" /> Export Full Tree...
          </button>
          <button
            className={`block w-full ${itemPadding} text-left hover:bg-zinc-100 dark:hover:bg-zinc-700 flex items-center gap-2`}
            onClick={() => {
              onImportTree();
              onClose();
            }}
            title="Import items into the tree"
          >
            <Upload className="w-4 h-4" /> Import Full Tree...
          </button>
        </>
      )}

      {/* --- Actions for Existing Item --- */}
      {!isEmptyArea && item && (
        <>
          {item.type === "folder" && (
            <>
              <button
                className={`block w-full ${itemPadding} text-left hover:bg-zinc-100 dark:hover:bg-zinc-700 flex items-center gap-2`}
                onClick={() => {
                  onAddFolder();
                  onClose();
                }}
              >
                ‚ûï Add Folder Here
              </button>
              <button
                className={`block w-full ${itemPadding} text-left hover:bg-zinc-100 dark:hover:bg-zinc-700 flex items-center gap-2`}
                onClick={() => {
                  onAddNote();
                  onClose();
                }}
              >
                ‚ûï Add Note Here
              </button>
              <button
                className={`block w-full ${itemPadding} text-left hover:bg-zinc-100 dark:hover:bg-zinc-700 flex items-center gap-2`}
                onClick={() => {
                  onAddTask();
                  onClose();
                }}
              >
                ‚ûï Add Task Here
              </button>
              <hr className="my-1 border-zinc-300 dark:border-zinc-600" />
            </>
          )}

          <button
            className={`block w-full ${itemPadding} text-left hover:bg-zinc-100 dark:hover:bg-zinc-700 flex items-center gap-2`}
            onClick={() => {
              onCut();
              onClose();
            }}
          >
            <Scissors className="w-4 h-4" /> Cut
          </button>
          <button
            className={`block w-full ${itemPadding} text-left hover:bg-zinc-100 dark:hover:bg-zinc-700 flex items-center gap-2`}
            onClick={() => {
              onCopy();
              onClose();
            }}
          >
            <Copy className="w-4 h-4" /> Copy
          </button>
          <button
            className={`block w-full ${itemPadding} text-left hover:bg-zinc-100 dark:hover:bg-zinc-700 flex items-center gap-2`}
            onClick={() => {
              onDuplicate();
              onClose();
            }}
          >
            <Copy className="w-4 h-4 opacity-0" aria-hidden="true" />
            Duplicate
          </button>
          {item.type === "folder" && canPaste && (
            <button
              className={`block w-full ${itemPadding} text-left flex items-center gap-2 hover:bg-zinc-100 dark:hover:bg-zinc-700`}
              onClick={() => {
                onPaste();
                onClose();
              }}
              title={`Paste item into ${item.label}`}
            >
              <ClipboardPaste className="w-4 h-4" /> Paste Here
            </button>
          )}
          <hr className="my-1 border-zinc-300 dark:border-zinc-600" />

          <button
            className={`block w-full ${itemPadding} text-left hover:bg-zinc-100 dark:hover:bg-zinc-700 flex items-center gap-2`}
            onClick={() => {
              onExportItem();
              onClose();
            }}
            title={`Export '${item.label}' and its contents`}
          >
            <Download className="w-4 h-4" /> Export Item...
          </button>
          {item.type === "folder" && (
            <button
              className={`block w-full ${itemPadding} text-left hover:bg-zinc-100 dark:hover:bg-zinc-700 flex items-center gap-2`}
              onClick={() => {
                onImportItem();
                onClose();
              }}
              title={`Import items under '${item.label}'`}
            >
              <Upload className="w-4 h-4" /> Import under Item...
            </button>
          )}
          <hr className="my-1 border-zinc-300 dark:border-zinc-600" />

          <button
            className={`block w-full ${itemPadding} text-left hover:bg-zinc-100 dark:hover:bg-zinc-700 flex items-center gap-2`}
            onClick={() => {
              onRename();
              onClose();
            }}
          >
            ‚úèÔ∏è Rename
          </button>
          <button
            className={`block w-full ${itemPadding} text-left hover:bg-zinc-100 dark:hover:bg-zinc-700 flex items-center gap-2`}
            onClick={() => {
              onDelete();
              onClose();
            }}
          >
            üóëÔ∏è Delete
          </button>
        </>
      )}
    </div>
  );
};

export default ContextMenu;


--- src\components\EditorPane.jsx ---
// src/components/EditorPane.jsx
import React, { useState, useRef, useEffect, useCallback } from "react";
import {
  Undo,
  Redo,
  Bold as BoldIcon,
  Italic as ItalicIcon,
  Underline as UnderlineIcon,
  Scissors,
  Copy,
  ClipboardPaste,
  TextSelect,
  AlignLeft,
  AlignRight,
  AlignCenter,
  Type,
  Link as LinkIcon,
  Code as CodeIcon,
  SquareCode as CodeBlockIcon,
  TerminalSquare as ShellIcon,
  List as UnorderedListIcon,
  ListOrdered as OrderedListIcon,
  // ImageIcon is removed as per the new request to only support pasting images
} from "lucide-react";

const FONT_FAMILIES = [
  "Arial",
  "Times New Roman",
  "Courier New",
  "Georgia",
  "Verdana",
];
const FONT_SIZES = ["1", "2", "3", "4", "5", "6", "7"];
const URL_REGEX = /(https?:\/\/[^\s]+|www\.[^\s]+)/gi;

const ensureProtocol = (url) => {
  if (!url) return "";
  let fullUrl = url.trim();
  fullUrl = fullUrl.replace(/[.,;!?]*$/, "");
  if (!/^(?:https?|ftp):\/\//i.test(fullUrl)) {
    if (fullUrl.startsWith("www.")) {
      fullUrl = `https://${fullUrl}`;
    } else if (fullUrl.includes(".") && !fullUrl.includes(" ")) {
      fullUrl = `https://${fullUrl}`;
    }
  }
  return fullUrl;
};

const createLinkHtml = (url, text) => {
  const safeUrl = ensureProtocol(url);
  if (safeUrl.startsWith("http") || safeUrl.startsWith("ftp")) {
    const encodedUrl = encodeURI(safeUrl)
      .replace(/"/g, "&quot;")
      .replace(/'/g, "&#39;");
    const safeText =
      text && text.trim().length > 0
        ? text.replace(/</g, "&lt;").replace(/>/g, "&gt;")
        : safeUrl;
    return `<a href="${encodedUrl}" target="_blank" rel="noopener noreferrer">${safeText}</a>`;
  }
  return text && text.trim().length > 0
    ? text.replace(/</g, "&lt;").replace(/>/g, "&gt;")
    : url;
};

const isValidNode = (node) => {
  return node && node.nodeType && document.body.contains(node);
};

const EditorPane = ({
  html = "",
  onChange,
  defaultFontFamily,
  defaultFontSize,
}) => {
  const [fontFamily, setFontFamily] = useState(
    defaultFontFamily || FONT_FAMILIES[0]
  );
  const [fontSize, setFontSize] = useState(defaultFontSize || FONT_SIZES[2]);
  const [isRTL, setIsRTL] = useState(false);
  const editorRef = useRef(null);
  const propUpdateInProgress = useRef(false);
  const [typingTimeout, setTypingTimeout] = useState(null);

  const handleContentChangeInternal = useCallback(
    (newHtml) => {
      if (onChange) {
        onChange(newHtml);
      }
    },
    [onChange]
  );

  useEffect(() => {
    if (editorRef.current && html !== editorRef.current.innerHTML) {
      propUpdateInProgress.current = true;
      const currentScrollTop = editorRef.current.scrollTop;
      const selection = window.getSelection();
      const range =
        selection && selection.rangeCount > 0
          ? selection.getRangeAt(0).cloneRange()
          : null;
      const activeElement = document.activeElement;

      editorRef.current.innerHTML = html;
      editorRef.current.scrollTop = currentScrollTop;

      try {
        if (range && editorRef.current.contains(activeElement)) {
          if (
            isValidNode(range.startContainer) &&
            isValidNode(range.endContainer)
          ) {
            selection.removeAllRanges();
            selection.addRange(range);
          }
        }
      } catch (e) {
        console.warn("Could not restore selection after HTML prop update:", e);
      }
      requestAnimationFrame(() => {
        propUpdateInProgress.current = false;
      });
    }
  }, [html]);

  useEffect(() => {
    if (editorRef.current) {
      editorRef.current.dir = isRTL ? "rtl" : "ltr";
    }
  }, [isRTL]);

  // Modified Paste Handler
  useEffect(() => {
    const editor = editorRef.current;
    if (!editor) return;

    const handlePasteEvent = (e) => {
      const clipboardData = e.clipboardData;
      if (!clipboardData) return;

      // Check for image files in the clipboard
      const items = clipboardData.items;
      let imageFile = null;
      for (let i = 0; i < items.length; i++) {
        if (items[i].type.indexOf("image") !== -1) {
          imageFile = items[i].getAsFile();
          break;
        }
      }

      if (imageFile) {
        e.preventDefault(); // Prevent default paste behavior for the image
        const reader = new FileReader();
        reader.onload = (event) => {
          const base64ImageData = event.target.result;
          const imgHtml = `<img src="${base64ImageData}" alt="Pasted Image" style="max-width: 100%; height: auto; display: block; margin: 10px 0;" />`;
          editorRef.current?.focus(); // Ensure editor is focused
          document.execCommand("insertHTML", false, imgHtml);
          requestAnimationFrame(() => {
            if (editorRef.current)
              handleContentChangeInternal(editorRef.current.innerHTML);
          });
        };
        reader.readAsDataURL(imageFile);
      } else {
        // If no image, handle as text (for URL auto-linking, etc.)
        e.preventDefault(); // Still prevent default to control how text is inserted
        const text = clipboardData.getData("text/plain");
        if (!text) return;

        const linkedHtml = text.replace(URL_REGEX, (match) =>
          createLinkHtml(match, match)
        );
        editorRef.current?.focus();
        document.execCommand("insertHTML", false, linkedHtml);
        requestAnimationFrame(() => {
          if (editorRef.current)
            handleContentChangeInternal(editorRef.current.innerHTML);
        });
      }
    };

    editor.addEventListener("paste", handlePasteEvent);
    return () => {
      if (editorRef.current) {
        editorRef.current.removeEventListener("paste", handlePasteEvent);
      }
    };
  }, [handleContentChangeInternal]); // handleContentChangeInternal is a dependency

  useEffect(() => {
    const editor = editorRef.current;
    if (!editor) return;
    const handleClick = (event) => {
      let targetElement = event.target;
      while (targetElement && targetElement !== editor) {
        if (targetElement.tagName === "A" && targetElement.href) {
          event.preventDefault();
          window.open(targetElement.href, "_blank", "noopener,noreferrer");
          return;
        }
        targetElement = targetElement.parentNode;
      }
    };
    editor.addEventListener("click", handleClick);
    return () => {
      if (editorRef.current) {
        editorRef.current.removeEventListener("click", handleClick);
      }
    };
  }, []);

  useEffect(() => {
    return () => {
      if (typingTimeout) clearTimeout(typingTimeout);
    };
  }, [typingTimeout]);

  const applyCommand = useCallback(
    (cmd, value = null) => {
      editorRef.current?.focus();
      try {
        document.execCommand(cmd, false, value);
      } catch (error) {
        console.error(`Error executing command ${cmd}:`, error);
      }
      if (cmd !== "paste") {
        requestAnimationFrame(() => {
          if (editorRef.current)
            handleContentChangeInternal(editorRef.current.innerHTML);
        });
      }
    },
    [handleContentChangeInternal]
  );

  const handleInput = useCallback(
    (event) => {
      if (!editorRef.current || propUpdateInProgress.current) return;
      const newHtml = event.target.innerHTML;
      if (typingTimeout) clearTimeout(typingTimeout);
      setTypingTimeout(
        setTimeout(() => {
          if (!editorRef.current) return;
          const selection = window.getSelection();
          let originalRange = null;
          if (selection && selection.rangeCount > 0) {
            originalRange = selection.getRangeAt(0).cloneRange();
          }
          let madeChanges = false;
          const tempDiv = document.createElement("div");
          tempDiv.innerHTML = editorRef.current.innerHTML;
          const textNodesToProcess = [];
          const walker = document.createTreeWalker(
            tempDiv,
            NodeFilter.SHOW_TEXT,
            (node) =>
              node.parentNode.nodeName !== "A"
                ? NodeFilter.FILTER_ACCEPT
                : NodeFilter.FILTER_REJECT,
            false
          );
          let node;
          while ((node = walker.nextNode())) {
            textNodesToProcess.push(node);
          }
          textNodesToProcess.forEach((textNode) => {
            const text = textNode.nodeValue;
            const fragment = document.createDocumentFragment();
            let lastIndex = 0;
            const urlMatches = [...text.matchAll(URL_REGEX)];
            urlMatches.forEach((match) => {
              const url = match[0];
              const matchIndex = match.index;
              const isCompleteUrl =
                (matchIndex + url.length === text.length ||
                  /[\s.,;!?)]/.test(text[matchIndex + url.length])) &&
                (matchIndex === 0 || /[\s.,;!?(]/.test(text[matchIndex - 1]));
              if (isCompleteUrl) {
                if (matchIndex > lastIndex) {
                  fragment.appendChild(
                    document.createTextNode(
                      text.substring(lastIndex, matchIndex)
                    )
                  );
                }
                const linkHtml = createLinkHtml(url, url);
                const tempLinkContainer = document.createElement("div");
                tempLinkContainer.innerHTML = linkHtml;
                if (tempLinkContainer.firstChild) {
                  fragment.appendChild(tempLinkContainer.firstChild);
                } else {
                  fragment.appendChild(document.createTextNode(url));
                }
                lastIndex = matchIndex + url.length;
                madeChanges = true;
              }
            });
            if (lastIndex < text.length) {
              fragment.appendChild(
                document.createTextNode(text.substring(lastIndex))
              );
            }
            if (madeChanges && textNode.parentNode) {
              textNode.parentNode.replaceChild(fragment, textNode);
            }
          });

          if (madeChanges) {
            editorRef.current.innerHTML = tempDiv.innerHTML;
            if (originalRange && selection) {
              try {
                if (
                  isValidNode(originalRange.startContainer) &&
                  isValidNode(originalRange.endContainer) &&
                  editorRef.current.contains(originalRange.startContainer) &&
                  editorRef.current.contains(originalRange.endContainer)
                ) {
                  selection.removeAllRanges();
                  selection.addRange(originalRange);
                } else {
                  const endRange = document.createRange();
                  endRange.selectNodeContents(editorRef.current);
                  endRange.collapse(false);
                  selection.removeAllRanges();
                  selection.addRange(endRange);
                }
              } catch (e) {
                console.warn("Auto-link cursor restoration error:", e);
                const endRange = document.createRange();
                endRange.selectNodeContents(editorRef.current);
                endRange.collapse(false);
                if (selection) {
                  selection.removeAllRanges();
                  selection.addRange(endRange);
                }
              }
            }
            handleContentChangeInternal(editorRef.current.innerHTML);
          }
        }, 700)
      );
      handleContentChangeInternal(newHtml);
    },
    [handleContentChangeInternal, typingTimeout]
  );

  const handlePasteFromClipboard = useCallback(async () => {
    // This function is now primarily for explicit paste button, main logic in useEffect
    if (!navigator.clipboard?.readText) {
      applyCommand("paste");
      return;
    }
    editorRef.current?.focus();
    try {
      const text = await navigator.clipboard.readText();
      if (text) {
        const htmlToInsert = text
          .replace(/&/g, "&amp;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;")
          .replace(/"/g, "&quot;")
          .replace(/'/g, "&#039;")
          .replace(/\r?\n/g, "<br>");
        document.execCommand("insertHTML", false, htmlToInsert);
      }
      requestAnimationFrame(() => {
        if (editorRef.current)
          handleContentChangeInternal(editorRef.current.innerHTML);
      });
    } catch (err) {
      console.error("Failed to read clipboard or insert HTML: ", err);
      try {
        const success = document.execCommand("paste", false, null);
        if (success && editorRef.current) {
          requestAnimationFrame(() => {
            if (editorRef.current)
              handleContentChangeInternal(editorRef.current.innerHTML);
          });
        } else if (!success) {
          console.warn("Fallback execCommand('paste') also failed.");
        }
      } catch (execErr) {
        console.error("Error during fallback execCommand('paste'):", execErr);
      }
    }
    editorRef.current?.focus();
  }, [applyCommand, handleContentChangeInternal]);

  const applyBlockStyle = useCallback(
    (tag, className = null) => {
      editorRef.current?.focus();
      document.execCommand("formatBlock", false, `<${tag}>`);
      if (className) {
        const selection = window.getSelection();
        if (selection && selection.rangeCount > 0) {
          let container = selection.getRangeAt(0).commonAncestorContainer;
          while (container && container !== editorRef.current) {
            if (container.nodeName === tag.toUpperCase()) {
              container.className = className;
              break;
            }
            container = container.parentNode;
          }
        }
      }
      if (tag === "pre" && editorRef.current) {
        const selection = window.getSelection();
        if (selection && selection.rangeCount > 0) {
          let block = selection.getRangeAt(0).commonAncestorContainer;
          while (
            block &&
            block.nodeName !== "PRE" &&
            block !== editorRef.current
          ) {
            block = block.parentNode;
          }
          if (
            block &&
            block.nodeName === "PRE" &&
            !block.querySelector("code")
          ) {
            const codeElement = document.createElement("code");
            while (block.firstChild) {
              codeElement.appendChild(block.firstChild);
            }
            block.appendChild(codeElement);
          }
        }
      }
      requestAnimationFrame(() => {
        if (editorRef.current)
          handleContentChangeInternal(editorRef.current.innerHTML);
      });
    },
    [handleContentChangeInternal]
  );

  const applyInlineStyle = useCallback(
    (tag) => {
      editorRef.current?.focus();
      let command = tag;
      if (tag === "code") {
        const selection = window.getSelection();
        if (!selection || selection.rangeCount === 0 || selection.isCollapsed)
          return;
        const range = selection.getRangeAt(0);
        const selectedText = range.toString();
        let parent = range.commonAncestorContainer;
        if (parent.nodeType !== Node.ELEMENT_NODE) {
          parent = parent.parentNode;
        }
        if (
          parent &&
          parent.nodeName === "CODE" &&
          parent.closest(".editor-pane") === editorRef.current
        ) {
          const textNode = document.createTextNode(parent.textContent);
          parent.parentNode.replaceChild(textNode, parent);
          range.selectNodeContents(textNode);
          selection.removeAllRanges();
          selection.addRange(range);
        } else {
          const codeNode = document.createElement("code");
          codeNode.textContent = selectedText
            .replace(/</g, "&lt;")
            .replace(/>/g, "&gt;");
          range.deleteContents();
          range.insertNode(codeNode);
          range.selectNodeContents(codeNode);
          selection.removeAllRanges();
          selection.addRange(range);
        }
        command = null;
      } else {
        document.execCommand(command, false, null);
      }
      requestAnimationFrame(() => {
        if (editorRef.current)
          handleContentChangeInternal(editorRef.current.innerHTML);
      });
    },
    [handleContentChangeInternal]
  );

  const handleCreateLink = useCallback(() => {
    editorRef.current?.focus();
    const selection = window.getSelection();
    const selectedText = selection ? selection.toString().trim() : "";
    let url = prompt(
      "Enter the URL:",
      selectedText.startsWith("http") || selectedText.startsWith("www.")
        ? selectedText
        : "https://"
    );
    if (!url) return;
    const linkHtml = createLinkHtml(url, selectedText);
    if (selection && selection.rangeCount > 0 && !selection.isCollapsed) {
      document.execCommand("insertHTML", false, linkHtml);
    } else {
      document.execCommand("insertHTML", false, linkHtml);
    }
    requestAnimationFrame(() => {
      if (editorRef.current)
        handleContentChangeInternal(editorRef.current.innerHTML);
    });
  }, [handleContentChangeInternal]);

  // handleInsertImage by URL is removed as per request to only support pasting.

  const toggleDirection = useCallback(() => {
    setIsRTL((prev) => !prev);
  }, []);
  const handleFontChange = useCallback(
    (command, value) => {
      applyCommand(command, value);
      if (command === "fontName") setFontFamily(value);
      if (command === "fontSize") setFontSize(value);
    },
    [applyCommand]
  );

  const buttonBaseClass =
    "p-1.5 sm:p-1 hover:bg-zinc-100 dark:hover:bg-zinc-700 rounded";

  return (
    <div className="flex flex-col flex-grow overflow-hidden border rounded bg-transparent dark:border-zinc-700">
      <div className="flex flex-wrap items-center gap-x-3 gap-y-1.5 sm:gap-y-1 p-2 border-b border-zinc-200 dark:border-zinc-700 flex-shrink-0">
        <button
          onClick={() => applyCommand("undo")}
          title="Undo"
          className={buttonBaseClass}
        >
          {" "}
          <Undo className="w-5 h-5" />{" "}
        </button>
        <button
          onClick={() => applyCommand("redo")}
          title="Redo"
          className={buttonBaseClass}
        >
          {" "}
          <Redo className="w-5 h-5" />{" "}
        </button>
        <button
          onClick={() => applyCommand("cut")}
          title="Cut"
          className={buttonBaseClass}
        >
          {" "}
          <Scissors className="w-5 h-5" />{" "}
        </button>
        <button
          onClick={() => applyCommand("copy")}
          title="Copy"
          className={buttonBaseClass}
        >
          {" "}
          <Copy className="w-5 h-5" />{" "}
        </button>
        <button
          onClick={handlePasteFromClipboard}
          title="Paste"
          className={buttonBaseClass}
        >
          {" "}
          <ClipboardPaste className="w-5 h-5" />{" "}
        </button>
        <button
          onClick={() => applyInlineStyle("bold")}
          title="Bold"
          className={buttonBaseClass}
        >
          {" "}
          <BoldIcon className="w-5 h-5" />{" "}
        </button>
        <button
          onClick={() => applyInlineStyle("italic")}
          title="Italic"
          className={buttonBaseClass}
        >
          {" "}
          <ItalicIcon className="w-5 h-5" />{" "}
        </button>
        <button
          onClick={() => applyInlineStyle("underline")}
          title="Underline"
          className={buttonBaseClass}
        >
          {" "}
          <UnderlineIcon className="w-5 h-5" />{" "}
        </button>
        {/* Image button for URL insert is removed */}
        <button
          onClick={() => applyInlineStyle("code")}
          title="Inline Code"
          className={buttonBaseClass}
        >
          {" "}
          <CodeIcon className="w-5 h-5" />{" "}
        </button>
        <button
          onClick={() => applyBlockStyle("pre")}
          title="Code Block"
          className={buttonBaseClass}
        >
          {" "}
          <CodeBlockIcon className="w-5 h-5" />{" "}
        </button>
        <button
          onClick={() => applyBlockStyle("div", "shell-command")}
          title="Shell Command Block"
          className={buttonBaseClass}
        >
          {" "}
          <ShellIcon className="w-5 h-5" />{" "}
        </button>
        <button
          onClick={() => applyCommand("justifyLeft")}
          title="Align Left"
          className={buttonBaseClass}
        >
          {" "}
          <AlignLeft className="w-5 h-5" />{" "}
        </button>
        <button
          onClick={() => applyCommand("justifyCenter")}
          title="Align Center"
          className={buttonBaseClass}
        >
          {" "}
          <AlignCenter className="w-5 h-5" />{" "}
        </button>
        <button
          onClick={() => applyCommand("justifyRight")}
          title="Align Right"
          className={buttonBaseClass}
        >
          {" "}
          <AlignRight className="w-5 h-5" />{" "}
        </button>
        <button
          onClick={() => applyCommand("selectAll")}
          title="Select All"
          className={buttonBaseClass}
        >
          {" "}
          <TextSelect className="w-5 h-5" />{" "}
        </button>
        <button
          onClick={() => applyCommand("insertUnorderedList")}
          title="Bulleted List"
          className={buttonBaseClass}
        >
          {" "}
          <UnorderedListIcon className="w-5 h-5" />{" "}
        </button>
        <button
          onClick={() => applyCommand("insertOrderedList")}
          title="Numbered List"
          className={buttonBaseClass}
        >
          {" "}
          <OrderedListIcon className="w-5 h-5" />{" "}
        </button>
        <button
          onClick={handleCreateLink}
          title="Create Link"
          className={buttonBaseClass}
        >
          {" "}
          <LinkIcon className="w-5 h-5" />{" "}
        </button>
        <button
          onClick={toggleDirection}
          title={`Text Direction: ${isRTL ? "RTL" : "LTR"}`}
          className={`p-1.5 sm:p-1 flex items-center ${
            isRTL ? "bg-blue-100 dark:bg-blue-900" : ""
          } hover:bg-zinc-100 dark:hover:bg-zinc-700 rounded`}
        >
          {" "}
          <Type className="w-5 h-5 mr-1" /> <span>{isRTL ? "RTL" : "LTR"}</span>{" "}
        </button>
        <select
          title="Font Family"
          className="p-1.5 sm:p-1 text-base md:text-sm border rounded bg-white dark:bg-zinc-700 border-zinc-300 dark:border-zinc-600 focus:outline-none focus:ring-1 focus:ring-blue-500"
          value={fontFamily}
          onChange={(e) => handleFontChange("fontName", e.target.value)}
        >
          {FONT_FAMILIES.map((f) => (
            <option key={f} value={f}>
              {f}
            </option>
          ))}
        </select>
        <select
          title="Font Size"
          className="p-1.5 sm:p-1 text-base md:text-sm border rounded bg-white dark:bg-zinc-700 border-zinc-300 dark:border-zinc-600 focus:outline-none focus:ring-1 focus:ring-blue-500"
          value={fontSize}
          onChange={(e) => handleFontChange("fontSize", e.target.value)}
        >
          {FONT_SIZES.map((s) => (
            <option key={s} value={s}>
              {s}
            </option>
          ))}
        </select>
      </div>

      <div
        ref={editorRef}
        dir={isRTL ? "rtl" : "ltr"}
        contentEditable
        suppressContentEditableWarning
        onInput={handleInput} // This will also trigger for pastes if not handled by paste event exclusively
        className="editor-pane prose prose-base md:prose-sm dark:prose-invert max-w-none w-full flex-grow p-3 border-t border-zinc-300 dark:border-zinc-600 rounded-b resize-y overflow-auto focus:outline-none focus:ring-1 focus:ring-blue-500 dark:text-zinc-100 prose-a:text-blue-600 dark:prose-a:text-blue-400 hover:prose-a:underline whitespace-pre-wrap prose-code:before:content-none prose-code:after:content-none prose-pre:bg-inherit dark:prose-pre:bg-inherit prose-pre:p-0"
        role="textbox"
        aria-multiline="true"
      />
    </div>
  );
};

export default EditorPane;


--- src\components\ExportDialog.jsx ---
// src/components/ExportDialog.jsx
import React, { useState, useEffect } from "react";

// Added defaultFormat prop
const ExportDialog = ({ isOpen, context, onClose, onExport, defaultFormat = 'json' }) => {
  // Initialize target based on context, default to 'selected' if no context
  const [target, setTarget] = useState(() => {
    if (context === 'tree') return 'entire';
    if (context === 'item') return 'selected';
    return 'selected';
  });

  // NEW: State for selected format, initialized by prop
  const [format, setFormat] = useState(defaultFormat);

  // Update target if context changes
  useEffect(() => {
     if (isOpen) {
        if (context === 'tree') setTarget('entire');
        else if (context === 'item') setTarget('selected');
        setFormat(defaultFormat); // Reset format on open based on default
     }
  }, [context, isOpen, defaultFormat]); // Add defaultFormat dependency

  if (!isOpen) return null;

  const handleExportClick = () => {
    onExport(target, format); // Pass the currently selected format state
    onClose();
  };

  const showRadioButtons = context !== 'item' && context !== 'tree';
  const dialogTitle = context === 'tree' ? "Export Full Tree"
                      : context === 'item' ? "Export Selected Item"
                      : "Export Options";

  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex justify-center items-center z-50">
      <div className="bg-white dark:bg-zinc-800 p-6 rounded shadow-lg w-80">
        <h2 className="text-xl font-bold mb-4">{dialogTitle}</h2>

        {/* Conditionally render Target Radio Buttons */}
        {showRadioButtons && (
           <div className="mb-4">
             <p className="mb-2 font-medium">Export Target</p>
             <label className="inline-flex items-center mr-4"> <input type="radio" name="exportTarget" value="selected" checked={target === "selected"} onChange={() => setTarget("selected")} /> <span className="ml-2">Selected Item</span> </label>
             <label className="inline-flex items-center"> <input type="radio" name="exportTarget" value="entire" checked={target === "entire"} onChange={() => setTarget("entire")} /> <span className="ml-2">Entire Tree</span> </label>
           </div>
        )}

        {/* Format Selection */}
        <div className="mb-4">
          <p className="mb-2 font-medium">Format</p>
          {/* UPDATED: Use radio buttons for format selection */}
           <div className="flex space-x-4">
               <label className="flex items-center space-x-1 cursor-pointer">
                   <input
                       type="radio"
                       name="exportFormat"
                       value="json"
                       checked={format === 'json'}
                       onChange={(e) => setFormat(e.target.value)}
                       className="form-radio text-blue-600"
                   />
                   <span>JSON</span>
               </label>
               <label className="flex items-center space-x-1 cursor-pointer">
                   <input
                       type="radio"
                       name="exportFormat"
                       value="pdf"
                       checked={format === 'pdf'}
                       onChange={(e) => setFormat(e.target.value)}
                       className="form-radio text-green-600"
                   />
                   <span>PDF</span>
               </label>
           </div>
        </div>

        {/* Export Button */}
        <button
          onClick={handleExportClick} // Call unified handler
          className={`w-full px-4 py-2 text-white rounded mt-4 ${format === 'json' ? 'bg-blue-600 hover:bg-blue-700' : 'bg-green-600 hover:bg-green-700'}`}
        >
          Export as {format.toUpperCase()}
        </button>

        {/* Cancel Button */}
        <button
           onClick={onClose}
           className="w-full px-4 py-2 border dark:border-zinc-600 rounded mt-2 hover:bg-zinc-100 dark:hover:bg-zinc-700"
         >
          Cancel
        </button>
      </div>
    </div>
  );
};

export default ExportDialog;

--- src\components\FolderContents.jsx ---
// src/components/FolderContents.jsx
import React from "react";
import { sortItems } from "../utils/treeUtils";
// --- MODIFICATION: Import MoreVertical icon ---
import { MoreVertical } from "lucide-react";
// --- END MODIFICATION ---

const FolderContents = ({
  folder,
  onSelect,
  handleDragStart,
  handleDragEnter,
  handleDragOver,
  handleDragLeave,
  handleDrop,
  handleDragEnd,
  draggedId,
  dragOverItemId,
  onToggleExpand,
  expandedItems,
  // --- MODIFICATION: Add prop for menu button click ---
  onShowItemMenu,
  // --- END MODIFICATION ---
}) => {
  const hasChildren =
    folder && Array.isArray(folder.children) && folder.children.length > 0;

  if (!hasChildren) {
    return (
      <p className="text-zinc-500 dark:text-zinc-400 italic p-3">
        This folder is empty.
      </p>
    );
  }

  return (
    <div>
      <ul className="space-y-1 sm:space-y-2">
        {sortItems(folder.children).map((child) => {
          const isBeingDragged = child.id === draggedId;
          const isDragOverTarget =
            child.id === dragOverItemId && child.type === "folder";

          return (
            <li
              key={child.id}
              data-item-id={`item-${child.id}`}
              // --- MODIFICATION: Added group class for hover effect on button ---
              className={`group relative flex items-center p-3 sm:p-2 hover:bg-zinc-100 dark:hover:bg-zinc-700 rounded cursor-pointer ${
                isBeingDragged ? "opacity-40" : ""
              }`}
              // --- END MODIFICATION ---
              onClick={() => onSelect && onSelect(child.id)} // Keep main click for selection
              role="button"
              tabIndex={0}
              onKeyDown={(e) => {
                if (e.key === "Enter" || e.key === " ") {
                  onSelect && onSelect(child.id);
                }
              }}
              draggable={true}
              onDragStart={(e) =>
                handleDragStart && handleDragStart(e, child.id)
              }
              onDragEnter={(e) =>
                handleDragEnter && handleDragEnter(e, child.id)
              }
              onDragOver={(e) => handleDragOver && handleDragOver(e)}
              onDragLeave={(e) => handleDragLeave && handleDragLeave(e)}
              onDrop={(e) => handleDrop && handleDrop(e, child.id)}
              onDragEnd={(e) => handleDragEnd && handleDragEnd(e)}
              aria-label={`${child.label} (${
                child.type.charAt(0).toUpperCase() + child.type.slice(1)
              })`}
              // --- MODIFICATION: Removed context menu handler from li, moved to button ---
              // onContextMenu={(e) => { ... }}
              // --- END MODIFICATION ---
            >
              {isDragOverTarget && (
                <div
                  data-item-id="drag-over-indicator"
                  className="absolute inset-y-0 left-0 right-0 bg-blue-200 dark:bg-blue-800 opacity-30 rounded pointer-events-none z-0"
                  aria-hidden="true"
                ></div>
              )}
              {/* Expand/Collapse Button & Icon Area */}
              <div className="w-6 h-6 flex-shrink-0 flex items-center justify-center mr-1 z-10">
                {child.type === "folder" && onToggleExpand && expandedItems ? (
                  <button
                    onClick={(e) => {
                      e.stopPropagation();
                      onToggleExpand(child.id);
                    }}
                    className={`flex items-center justify-center h-full w-full focus:outline-none text-xs rounded-sm p-0.5 text-zinc-500 dark:text-zinc-400 hover:bg-black/10 dark:hover:bg-white/10`}
                    aria-expanded={!!expandedItems[child.id]}
                    aria-label={
                      expandedItems[child.id]
                        ? `Collapse ${child.label}`
                        : `Expand ${child.label}`
                    }
                    title={expandedItems[child.id] ? `Collapse` : `Expand`}
                  >
                    {" "}
                    {expandedItems[child.id] ? "‚ñæ" : "‚ñ∏"}{" "}
                  </button>
                ) : (
                  <span
                    className="inline-block w-full h-full"
                    aria-hidden="true"
                  >
                    &nbsp;
                  </span>
                )}
              </div>
              {/* Item Icon */}
              <div className="w-6 h-6 flex-shrink-0 flex items-center justify-center mr-1.5 sm:mr-1 z-10">
                {child.type === "folder"
                  ? expandedItems && expandedItems[child.id]
                    ? "üìÇ"
                    : "üìÅ"
                  : child.type === "note"
                  ? "üìù"
                  : child.completed
                  ? "‚úÖ"
                  : "‚¨úÔ∏è"}
              </div>
              {/* Label */}
              <span
                className={`flex-grow truncate z-10 text-base md:text-sm ${
                  child.type === "task" && child.completed
                    ? "line-through text-zinc-500 dark:text-zinc-400"
                    : ""
                }`}
              >
                {child.label}
              </span>
              {/* Type Indicator */}
              <span className="ml-2 text-zinc-500 text-xs sm:text-sm z-10 flex-shrink-0">
                {" "}
                {/* Added flex-shrink-0 */}(
                {child.type.charAt(0).toUpperCase() + child.type.slice(1)})
              </span>
              {/* --- MODIFICATION: Add More Options Button --- */}
              <button
                onClick={(e) => {
                  e.preventDefault();
                  e.stopPropagation(); // Prevent the li's onClick
                  if (onShowItemMenu) {
                    onShowItemMenu(child, e.currentTarget); // Pass item and button element
                  }
                }}
                className={`ml-1 p-1 rounded hover:bg-black/10 dark:hover:bg-white/20 text-zinc-500 dark:text-zinc-400 opacity-0 group-hover:opacity-100 focus:opacity-100 flex-shrink-0`} // Show on hover/focus
                aria-label={`More options for ${child.label}`}
                title="More options"
              >
                <MoreVertical className="w-4 h-4" />
              </button>
              {/* --- END MODIFICATION --- */}
            </li>
          );
        })}
      </ul>
    </div>
  );
};

export default FolderContents;


--- src\components\ImportDialog.jsx ---
// src/components/ImportDialog.jsx
import React, { useState, useEffect } from "react";

const ImportDialog = ({ isOpen, context, onClose, onImport, selectedItem }) => {
  // target will be 'entire' (for full tree) or 'selected' (for under item)
  const [target, setTarget] = useState("entire"); // Default, will be overridden by context
  const [file, setFile] = useState(null);
  const [importing, setImporting] = useState(false);
  const [importMessage, setImportMessage] = useState("");

  useEffect(() => {
    if (isOpen) {
      // Set target based on the context the dialog was opened with
      if (context === "tree") {
        setTarget("entire");
      } else if (context === "item") {
        setTarget("selected");
      } else {
        // Fallback or default if context is not specific
        // e.g., default to 'entire' if no item selected, else 'selected'
        setTarget(selectedItem ? "selected" : "entire");
      }
      setFile(null);
      setImporting(false);
      setImportMessage("");
    }
  }, [context, isOpen, selectedItem]); // Add selectedItem to dependencies

  if (!isOpen) return null;

  const handleFileChange = (e) => {
    if (e.target.files && e.target.files[0]) {
      setFile(e.target.files[0]);
      setImportMessage("");
    } else {
      setFile(null);
    }
  };

  const handleImportClick = async () => {
    if (file) {
      setImporting(true);
      setImportMessage("Importing...");
      const result = await onImport(file, target); // onImport is async handleFileImport from App.jsx
      setImporting(false);
      if (result && result.success) {
        setImportMessage(result.message || "Import successful!");
        // Dialog is closed by App.jsx by calling onClose via setImportDialogState
      } else {
        setImportMessage(result?.error || "Import failed. Please try again.");
      }
    } else {
      setImportMessage("Please select a file first.");
    }
  };

  const isFullTreeImportContext = context === "tree";
  const isImportUnderItemContext = context === "item";

  let dialogTitle = "Import Data";
  if (isFullTreeImportContext) {
    dialogTitle = "Import Tree (Overwrite Existing)";
  } else if (isImportUnderItemContext && selectedItem) {
    dialogTitle = `Import Under "${selectedItem.label}"`;
  }

  return (
    <div className="fixed inset-0 bg-black bg-opacity-60 flex justify-center items-center z-50 p-4 backdrop-blur-sm">
      <div className="bg-white dark:bg-zinc-800 p-6 rounded-lg shadow-xl w-full max-w-md sm:max-w-sm">
        <h2 className="text-lg sm:text-xl font-semibold mb-4 text-zinc-900 dark:text-zinc-100">
          {dialogTitle}
        </h2>

        {/* Only show target options if the context doesn't strictly define it */}
        {/* Or if you always want to allow changing, but pre-select based on context */}
        {!isFullTreeImportContext && ( // Don't show radio buttons if importing full tree via specific menu action
          <div className="mb-4">
            <p className="mb-2 font-medium text-sm text-zinc-700 dark:text-zinc-300">
              Import Target
            </p>
            <div className="space-y-2">
              <label className="flex items-center cursor-pointer p-2 rounded-md hover:bg-zinc-50 dark:hover:bg-zinc-700/50">
                <input
                  type="radio"
                  name="importTarget"
                  value="selected"
                  checked={target === "selected"}
                  onChange={() => {
                    setTarget("selected");
                    setImportMessage("");
                  }}
                  disabled={importing || !selectedItem} // Disable if no item is selected for this option
                  className="form-radio h-4 w-4 text-blue-600 disabled:opacity-50 dark:focus:ring-blue-500 focus:ring-offset-0 dark:bg-zinc-700 dark:border-zinc-600"
                />
                <span
                  className={`ml-2 text-sm text-zinc-700 dark:text-zinc-200 ${
                    !selectedItem ? "opacity-50" : ""
                  }`}
                >
                  Under Selected Item{" "}
                  {selectedItem
                    ? `(${selectedItem.label})`
                    : "(No item selected)"}
                </span>
              </label>
              <label className="flex items-center cursor-pointer p-2 rounded-md hover:bg-zinc-50 dark:hover:bg-zinc-700/50">
                <input
                  type="radio"
                  name="importTarget"
                  value="entire"
                  checked={target === "entire"}
                  onChange={() => {
                    setTarget("entire");
                    setImportMessage("");
                  }}
                  disabled={importing}
                  className="form-radio h-4 w-4 text-blue-600 dark:focus:ring-blue-500 focus:ring-offset-0 dark:bg-zinc-700 dark:border-zinc-600"
                />
                <span className="ml-2 text-sm text-zinc-700 dark:text-zinc-200">
                  Into empty tree or overwrite existing data
                </span>
              </label>
            </div>
          </div>
        )}
        {isFullTreeImportContext && (
          <p className="mb-4 text-sm text-zinc-600 dark:text-zinc-400">
            This will replace your entire current tree with the contents of the
            JSON file.
          </p>
        )}

        <div className="mb-6">
          <label
            className="block mb-2 text-sm font-medium text-zinc-700 dark:text-zinc-300"
            htmlFor="import-file"
          >
            Select JSON File
          </label>
          <input /* ... (input field as before) ... */
            type="file"
            id="import-file"
            accept=".json,application/json"
            onChange={handleFileChange}
            disabled={importing}
            className="block w-full text-sm text-zinc-500 dark:text-zinc-300
                       file:mr-4 file:py-2 file:px-4
                       file:rounded-md file:border-0
                       file:text-sm file:font-semibold
                       file:bg-blue-100 dark:file:bg-zinc-700
                       file:text-blue-700 dark:file:text-blue-300
                       hover:file:bg-blue-200 dark:hover:file:bg-zinc-600
                       focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 dark:focus:ring-offset-zinc-800
                       disabled:opacity-50"
          />
          {file && (
            <p className="mt-1 text-xs text-zinc-500 dark:text-zinc-400">
              Selected: {file.name}
            </p>
          )}
        </div>

        {importMessage && (
          <p
            className={`text-sm mb-4 p-2 rounded ${
              (importMessage.toLowerCase().includes("successful") ||
                importMessage.toLowerCase().includes("saved")) &&
              !importMessage.toLowerCase().includes("failed") &&
              !importMessage.toLowerCase().includes("error")
                ? "bg-green-100 dark:bg-green-900/60 text-green-700 dark:text-green-300 border border-green-300 dark:border-green-700"
                : "bg-red-100 dark:bg-red-900/60 text-red-700 dark:text-red-300 border border-red-300 dark:border-red-700"
            }`}
          >
            {importMessage}
          </p>
        )}

        <div className="mt-6 flex flex-col sm:flex-row-reverse gap-3">
          <button /* ... (Import button as before) ... */
            onClick={handleImportClick}
            disabled={
              !file ||
              importing ||
              (target === "selected" &&
                !selectedItem &&
                !isFullTreeImportContext)
            } // Also disable "Import" if target is "selected" but no item is selected
            className="w-full sm:w-auto inline-flex justify-center rounded-md border border-transparent shadow-sm px-4 py-2 bg-blue-600 text-base font-medium text-white hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 dark:focus:ring-offset-zinc-800 focus:ring-blue-500 sm:text-sm disabled:opacity-50 disabled:cursor-not-allowed"
          >
            {importing ? "Importing..." : "Import"}
          </button>
          <button /* ... (Cancel button as before) ... */
            type="button"
            onClick={onClose}
            disabled={importing}
            className="w-full sm:w-auto inline-flex justify-center rounded-md border border-zinc-300 dark:border-zinc-600 shadow-sm px-4 py-2 bg-white dark:bg-zinc-700 text-base font-medium text-zinc-700 dark:text-zinc-200 hover:bg-zinc-50 dark:hover:bg-zinc-600 focus:outline-none focus:ring-2 focus:ring-offset-2 dark:focus:ring-offset-zinc-800 focus:ring-indigo-500 sm:text-sm disabled:opacity-50"
          >
            Close
          </button>
        </div>
      </div>
    </div>
  );
};

export default ImportDialog;


--- src\components\Login.jsx ---
// src/components/Login.jsx
import React, { useState } from "react";

// Use import.meta.env for Vite environment variables in client-side code
const API_BASE_URL =
  import.meta.env.VITE_API_BASE_URL || "http://localhost:5001/api/fallback";

const Login = ({ onLoginSuccess, onSwitchToRegister }) => {
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const [error, setError] = useState("");
  const [isLoading, setIsLoading] = useState(false);

  // Optional: Log state on every render for debugging this specific test
  // console.log(`[Login.jsx RENDER] email: '${email}', password: '${password}', error: '${error}'`);

  const handleSubmit = async (e) => {
    e.preventDefault();
    // ----- VERY IMPORTANT LOG: This should be the FIRST line executed in handleSubmit -----
    console.log(
      `-----> [Login.jsx handleSubmit ENTRY] email_state_is: '${email}', password_state_is: '${password}' <-----`
    );
    // ------------------------------------------------------------------------------------

    setError("");
    setIsLoading(true);

    if (!email || !password) {
      // This log is also critical for the failing test:
      console.log(
        `-----> [Login.jsx handleSubmit] EMPTY FIELDS VALIDATION HIT! Setting error to "Please enter both email and password."`
      );
      setError("Please enter both email and password.");
      setIsLoading(false); // Ensure isLoading is reset on validation failure
      return;
    }

    // This log should only appear if the condition above was false.
    console.log(
      `-----> [Login.jsx handleSubmit] Fields were NOT empty. Proceeding...`
    );

    try {
      const fetchUrl = `${API_BASE_URL}/auth/login`;
      const fetchOptions = {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ email, password }),
      };
      // console.log(`[Login.jsx DEBUG] Fetching URL: ${fetchUrl}`);
      // console.log("[Login.jsx DEBUG] Fetching Options:", JSON.stringify(fetchOptions, null, 2));

      const response = await fetch(fetchUrl, fetchOptions);
      const data = await response.json();
      setIsLoading(false);

      if (!response.ok) {
        setError(data.error || "Login failed. Please check your credentials.");
        return;
      }

      if (data.token) {
        localStorage.setItem("userToken", data.token);
        // console.log("Login successful, token saved.");
        if (onLoginSuccess) {
          onLoginSuccess(data.user);
        }
      } else {
        setError("Login failed: No token received from server.");
      }
    } catch (err) {
      setIsLoading(false);
      // console.error("Login request error:", err);
      setError("Network error or server issue. Please try again.");
    }
  };

  return (
    <div className="flex items-center justify-center min-h-screen bg-zinc-100 dark:bg-zinc-900">
      <div className="p-8 bg-white dark:bg-zinc-800 rounded-lg shadow-xl w-full max-w-md">
        <h2 className="text-2xl font-semibold text-center text-zinc-900 dark:text-white mb-6">
          Login to Notes & Tasks
        </h2>
        {error && (
          <p
            data-item-id="login-error-message"
            className="text-red-500 dark:text-red-400 text-sm mb-4 p-3 bg-red-100 dark:bg-red-900/30 rounded"
          >
            {error}
          </p>
        )}
        {/* Ensure your test environment's getByTestId looks for "data-item-id" if you use that here */}
        <form onSubmit={handleSubmit} data-item-id="login-form">
          <div className="mb-4">
            <label
              className="block text-sm font-medium text-zinc-700 dark:text-zinc-300 mb-1"
              htmlFor="email-login"
            >
              Email Address
            </label>
            <input
              type="email"
              id="email-login"
              value={email}
              onChange={(e) => setEmail(e.target.value)}
              className="w-full px-4 py-2.5 border border-zinc-300 dark:border-zinc-600 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 bg-white dark:bg-zinc-700 text-zinc-900 dark:text-white"
              required
              placeholder="you@example.com"
            />
          </div>
          <div className="mb-6">
            <label
              className="block text-sm font-medium text-zinc-700 dark:text-zinc-300 mb-1"
              htmlFor="password-login"
            >
              Password
            </label>
            <input
              type="password"
              id="password-login"
              value={password}
              onChange={(e) => setPassword(e.target.value)}
              className="w-full px-4 py-2.5 border border-zinc-300 dark:border-zinc-600 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 bg-white dark:bg-zinc-700 text-zinc-900 dark:text-white"
              required
              placeholder="‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢"
            />
          </div>
          <button
            type="submit"
            disabled={isLoading}
            className="w-full bg-blue-600 text-white py-2.5 px-4 rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 dark:focus:ring-offset-zinc-800 transition duration-150 ease-in-out disabled:opacity-50"
          >
            {isLoading ? "Logging in..." : "Login"}
          </button>
        </form>
        <p className="mt-6 text-sm text-center text-zinc-600 dark:text-zinc-400">
          Don't have an account?{" "}
          <button
            onClick={onSwitchToRegister}
            className="font-medium text-blue-600 hover:text-blue-500 dark:text-blue-400 dark:hover:text-blue-300"
          >
            Create one
          </button>
        </p>
      </div>
    </div>
  );
};

export default Login;


--- src\components\Register.jsx ---
// src/components/Register.jsx
import React, { useState } from "react";

const API_BASE_URL =
  import.meta.env.VITE_API_BASE_URL || "http://localhost:5001/api";

const Register = ({ onRegisterSuccess, onSwitchToLogin }) => {
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const [confirmPassword, setConfirmPassword] = useState("");
  const [error, setError] = useState("");
  const [isLoading, setIsLoading] = useState(false);

  // console.log(`[Register.jsx RENDER] email: '${email}', password: '${password}', confirmPassword: '${confirmPassword}', error: '${error}'`);

  const handleSubmit = async (e) => {
    e.preventDefault();
    console.log(
      `[Register.jsx handleSubmit DEBUG] ENTRY - email: '${email}', password: '${password}', confirmPassword: '${confirmPassword}'`
    );

    setError(""); // Clear previous errors

    if (!email || !password || !confirmPassword) {
      console.log(
        "[Register.jsx handleSubmit DEBUG] Empty fields validation hit! Setting error."
      );
      setError("Please fill in all fields.");
      return;
    }
    if (password !== confirmPassword) {
      console.log(
        "[Register.jsx handleSubmit DEBUG] Passwords do not match! Setting error."
      );
      setError("Passwords do not match.");
      return;
    }
    if (password.length < 8) {
      console.log(
        "[Register.jsx handleSubmit DEBUG] Password too short! Setting error."
      );
      setError("Password must be at least 8 characters long.");
      return;
    }

    console.log(
      "[Register.jsx handleSubmit DEBUG] All validations passed. Proceeding to fetch."
    );
    setIsLoading(true);
    try {
      const fetchUrl = `${API_BASE_URL}/auth/register`;
      const fetchOptions = {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ email, password }),
      };
      console.log(`[Register.jsx DEBUG] Fetching URL: ${fetchUrl}`);
      console.log(
        "[Register.jsx DEBUG] Fetching Options:",
        JSON.stringify(fetchOptions)
      );

      const response = await fetch(fetchUrl, fetchOptions);
      const data = await response.json();
      setIsLoading(false);

      if (!response.ok) {
        setError(data.error || "Registration failed. Please try again.");
        return;
      }
      alert("Registration successful! Please log in."); // Consider replacing alert in tests
      if (onRegisterSuccess) {
        onRegisterSuccess();
      }
    } catch (err) {
      setIsLoading(false);
      console.error("Registration request error:", err);
      setError("Network error or server issue. Please try again.");
    }
  };

  return (
    <div className="flex items-center justify-center min-h-screen bg-zinc-100 dark:bg-zinc-900">
      <div className="p-8 bg-white dark:bg-zinc-800 rounded-lg shadow-xl w-full max-w-md">
        <h2 className="text-2xl font-semibold text-center text-zinc-900 dark:text-white mb-6">
          Create Account
        </h2>
        {error && (
          // Ensure your tests look for data-item-id if your environment expects it
          <p
            data-item-id="register-error-message"
            className="text-red-500 dark:text-red-400 text-sm mb-4 p-3 bg-red-100 dark:bg-red-900/30 rounded"
          >
            {error}
          </p>
        )}
        <form onSubmit={handleSubmit} data-item-id="register-form">
          <div className="mb-4">
            <label
              className="block text-sm font-medium text-zinc-700 dark:text-zinc-300 mb-1"
              htmlFor="email-register"
            >
              Email Address
            </label>
            <input
              type="email"
              id="email-register"
              value={email}
              onChange={(e) => setEmail(e.target.value)}
              className="w-full px-4 py-2.5 border border-zinc-300 dark:border-zinc-600 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 bg-white dark:bg-zinc-700 text-zinc-900 dark:text-white"
              required
              placeholder="you@example.com"
            />
          </div>
          <div className="mb-4">
            <label
              className="block text-sm font-medium text-zinc-700 dark:text-zinc-300 mb-1"
              htmlFor="password-register"
            >
              Password (min. 8 characters)
            </label>
            <input
              type="password"
              id="password-register"
              value={password}
              onChange={(e) => setPassword(e.target.value)}
              className="w-full px-4 py-2.5 border border-zinc-300 dark:border-zinc-600 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 bg-white dark:bg-zinc-700 text-zinc-900 dark:text-white"
              required
              placeholder="‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢"
            />
          </div>
          <div className="mb-6">
            <label
              className="block text-sm font-medium text-zinc-700 dark:text-zinc-300 mb-1"
              htmlFor="confirmPassword-register"
            >
              Confirm Password
            </label>
            <input
              type="password"
              id="confirmPassword-register"
              value={confirmPassword}
              onChange={(e) => setConfirmPassword(e.target.value)}
              className="w-full px-4 py-2.5 border border-zinc-300 dark:border-zinc-600 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 bg-white dark:bg-zinc-700 text-zinc-900 dark:text-white"
              required
              placeholder="‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢"
            />
          </div>
          <button
            type="submit"
            disabled={isLoading}
            className="w-full bg-green-600 text-white py-2.5 px-4 rounded-md hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-offset-2 dark:focus:ring-offset-zinc-800 transition duration-150 ease-in-out disabled:opacity-50"
          >
            {isLoading ? "Registering..." : "Create Account"}
          </button>
        </form>
        <p className="mt-6 text-sm text-center text-zinc-600 dark:text-zinc-400">
          Already have an account?{" "}
          <button
            onClick={onSwitchToLogin}
            className="font-medium text-blue-600 hover:text-blue-500 dark:text-blue-400 dark:hover:text-blue-300"
          >
            Log In
          </button>
        </p>
      </div>
    </div>
  );
};

export default Register;


--- src\components\RenameDialog.jsx ---
import React from "react";

const RenameDialog = ({
  isOpen,
  item,
  newName,
  onNameChange,
  onRename,
  onCancel,
}) => {
  if (!isOpen) return null;

  const handleSubmit = (e) => {
    e.preventDefault();
    onRename();
  };

  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex justify-center items-center z-50">
      <div className="bg-white dark:bg-zinc-800 p-6 rounded shadow-lg w-96">
        <h2 className="text-lg font-bold mb-4">Rename ‚Äú{item.label}‚Äù</h2>
        <form onSubmit={handleSubmit}>
          <input
            type="text"
            value={newName}
            onChange={onNameChange}
            className="border p-2 rounded w-full mb-2 text-gray-900 dark:text-gray"
            autoFocus
          />
          <div className="mt-4 flex justify-end space-x-2">
            <button
              type="button"
              onClick={onCancel}
              className="px-4 py-2 border rounded"
            >
              Cancel
            </button>
            <button
              type="submit"
              className="px-4 py-2 bg-blue-600 text-white rounded"
            >
              Rename
            </button>
          </div>
        </form>
      </div>
    </div>
  );
};

export default RenameDialog;


--- src\components\SearchPanel.jsx ---
import React, { useState, useEffect } from "react";
import { matchText } from "../utils/searchUtils";

const defaultOptions = { caseSensitive: false, wholeWord: false, useRegex: false };

export default function SearchPanel({ searchItems, initialQuery = "", options = defaultOptions, onClose }) {
  const [query, setQuery] = useState(initialQuery);
  const [opts, setOpts] = useState(options);
  const [results, setResults] = useState([]);
  const [preview, setPreview] = useState(null);

  useEffect(() => {
    if (query) {
      const hits = searchItems(query, opts);
      setResults(hits);
      setPreview(hits[0] || null);
    } else {
      setResults([]);
      setPreview(null);
    }
  }, [query, opts, searchItems]);

  
  if (results.length === 0) {
    return (
      <div className="flex flex-col h-full bg-zinc-900 border-l border-zinc-700">
        <div className="p-4 text-sm text-zinc-400">No matches found.</div>
      </div>
    );
  }

return (
    <div className="flex flex-col h-full bg-zinc-900 border-l border-zinc-700 shadow-lg">
      {/* Header */}
      <div className="p-2 border-b border-zinc-700 flex items-center space-x-2">
        <input
          autoFocus
          type="text"
          className="flex-1 px-2 py-1 rounded bg-zinc-800 focus:outline-none"
          placeholder="Search..."
          value={query}
          onChange={(e) => setQuery(e.target.value)}
        />
        <button
          onClick={onClose}
          className="px-2 py-1 rounded hover:bg-zinc-700"
          title="Close"
        >
          ‚úï
        </button>
      </div>
      {/* Options */}
      <div className="p-2 flex space-x-3 text-xs">
        <label className="flex items-center space-x-1">
          <input
            type="checkbox"
            checked={opts.caseSensitive}
            onChange={(e) => setOpts({ ...opts, caseSensitive: e.target.checked })}
          />
          <span>Case</span>
        </label>
        <label className="flex items-center space-x-1">
          <input
            type="checkbox"
            checked={opts.wholeWord}
            onChange={(e) => setOpts({ ...opts, wholeWord: e.target.checked })}
          />
          <span>Whole</span>
        </label>
        <label className="flex items-center space-x-1">
          <input
            type="checkbox"
            checked={opts.useRegex}
            onChange={(e) => setOpts({ ...opts, useRegex: e.target.checked })}
          />
          <span>RegEx</span>
        </label>
      </div>
      {/* Body */}
      <div className="flex flex-1 overflow-hidden">
        {/* Results list */}
        <div className="w-44 border-r border-zinc-800 overflow-auto">
          {results.map((item) => (
            <div
              key={item.id}
              onClick={() => setPreview(item)}
              className="p-2 cursor-pointer border-b border-zinc-800 hover:bg-zinc-800"
            >
              <p className="text-sm font-medium">{item.label || item.title}</p>
            </div>
          ))}
        </div>
        {/* Preview */}
        <div className="flex-1 overflow-auto p-4">
          {preview ? (
            <>
              <h3 className="text-lg font-semibold mb-2">{preview.label || preview.title}</h3>
              <pre className="whitespace-pre-wrap">{preview.content || preview.text}</pre>
            </>
          ) : (
            <p className="text-zinc-500">Select a result to preview.</p>
          )}
        </div>
      </div>
    </div>
  );
}

--- src\components\SearchResultsPane.jsx ---
// src/components/SearchResultsPane.jsx
import React from "react";
import { CaseSensitive, WholeWord, Regex, XCircle } from "lucide-react";

function escapeRegex(string) {
  return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}

const HighlightMultiple = ({ text, query, opts }) => {
  if (!text || !query) {
    return <>{text}</>;
  }
  const flags = opts.caseSensitive ? "g" : "gi";
  let regex;
  try {
    const pattern = opts.useRegex ? query : escapeRegex(query);
    regex = new RegExp(pattern, flags);
  } catch (e) {
    return <>{text}</>;
  }
  const parts = [];
  let lastIndex = 0;
  let match;
  const textToSearch = String(text);

  while ((match = regex.exec(textToSearch)) !== null) {
    if (match.index > lastIndex) {
      parts.push(textToSearch.substring(lastIndex, match.index));
    }
    parts.push(
      <strong
        key={match.index + "-" + match[0]}
        className="text-yellow-600 dark:text-yellow-300 bg-yellow-200 dark:bg-yellow-700/50 px-0.5 rounded"
      >
        {match[0]}
      </strong>
    );
    lastIndex = regex.lastIndex;
    if (opts.useRegex && match[0].length === 0) {
      regex.lastIndex++;
    }
  }
  if (lastIndex < textToSearch.length) {
    parts.push(textToSearch.substring(lastIndex));
  }
  return parts.length > 0 ? <>{parts}</> : <>{text}</>;
};

const HighlightedPathLabel = ({ pathString, itemLabel, highlightDetails }) => {
  if (!pathString) return <>{pathString}</>;
  const pathParts = pathString.split(" / ");
  const labelFromPath = pathParts[pathParts.length - 1];

  if (
    labelFromPath === itemLabel &&
    highlightDetails &&
    highlightDetails.start !== -1 &&
    highlightDetails.end > highlightDetails.start
  ) {
    const prefix = itemLabel.substring(0, highlightDetails.start);
    const highlighted = itemLabel.substring(
      highlightDetails.start,
      highlightDetails.end
    );
    const suffix = itemLabel.substring(highlightDetails.end);

    pathParts[pathParts.length - 1] = (
      <>
        {prefix}
        <strong className="text-purple-500 dark:text-purple-400 bg-purple-200 dark:bg-purple-700/30 px-0.5 rounded">
          {highlighted}
        </strong>
        {suffix}
      </>
    );
    return (
      <>
        {pathParts.map((part, index) => (
          <React.Fragment key={index}>
            {index > 0 && " / "}
            {part}
          </React.Fragment>
        ))}
      </>
    );
  }
  return <>{pathString}</>;
};

export default function SearchResultsPane({
  query,
  onQueryChange,
  results,
  onSelectResult,
  onClose,
  opts,
  setOpts,
  headerHeightClass,
}) {
  const isRegexEnabledCurrently = false;
  return (
    <div className="flex flex-col h-full bg-zinc-50 dark:bg-zinc-900 text-zinc-900 dark:text-zinc-100">
      <div
        className={`flex items-center space-x-2 p-2 sm:p-3 border-b border-zinc-200 dark:border-zinc-700 flex-shrink-0 ${headerHeightClass}`} // Adjusted padding
      >
        <input
          id="global-search-input"
          className="flex-1 px-3 sm:px-2 py-2 sm:py-1 rounded bg-white dark:bg-zinc-800 focus:outline-none text-zinc-900 dark:text-zinc-100 text-base md:text-sm" // Adjusted padding and font
          placeholder="Search..."
          value={query || ""}
          onChange={(e) => onQueryChange(e.target.value)}
          autoFocus
        />
        <div className="flex items-center space-x-1">
          {[
            {
              key: "caseSensitive",
              label: "Case Sensitive",
              Icon: CaseSensitive,
              disabled: false,
            },
            {
              key: "wholeWord",
              label: "Whole Word",
              Icon: WholeWord,
              disabled: false,
            },
            {
              key: "useRegex",
              label: "Use Regular Expression",
              Icon: Regex,
              disabled: !isRegexEnabledCurrently,
            },
          ].map(({ key, label, Icon, disabled }) => (
            <button
              key={key}
              title={disabled ? `${label} (Disabled)` : label}
              onClick={() => {
                if (!disabled) {
                  setOpts((prevOpts) => ({
                    ...prevOpts,
                    [key]: !prevOpts[key],
                  }));
                }
              }}
              disabled={disabled}
              className={`p-1.5 sm:p-1 rounded focus:outline-none focus:ring-1 focus:ring-blue-500 ${
                // Adjusted padding
                disabled
                  ? "text-zinc-400 dark:text-zinc-600 cursor-not-allowed"
                  : opts[key]
                  ? "bg-blue-600 text-white hover:bg-blue-700"
                  : "text-zinc-500 dark:text-zinc-400 hover:bg-zinc-200 dark:hover:bg-zinc-700"
              }`}
            >
              <Icon className="w-5 h-5 sm:w-4 sm:h-4" />{" "}
              {/* Adjusted icon size */}
            </button>
          ))}
        </div>
        <button
          onClick={onClose}
          className="p-1.5 sm:p-1 text-zinc-500 dark:text-zinc-400 hover:bg-zinc-200 dark:hover:bg-zinc-700 rounded" // Adjusted padding
          title="Close Search"
        >
          <XCircle className="w-5 h-5" />
        </button>
      </div>

      <div className="flex-1 overflow-auto">
        {results.length === 0 ? (
          <p className="p-4 text-sm text-zinc-500 dark:text-zinc-400">
            No matches.
          </p>
        ) : (
          results.map(
            (
              item // item is a processed search result entry
            ) => (
              <div
                key={item.id}
                onClick={() => onSelectResult(item)}
                className="p-3 sm:p-2 border-b border-zinc-200 dark:border-zinc-800 cursor-pointer hover:bg-zinc-100 dark:hover:bg-zinc-700" // Increased base padding
              >
                {item.path && (
                  <p
                    className="text-xs text-zinc-500 dark:text-zinc-400 truncate mb-0.5"
                    title={item.path}
                  >
                    <HighlightedPathLabel
                      pathString={item.path}
                      itemLabel={item.label || item.title || ""}
                      highlightDetails={item.pathLabelHighlight}
                    />
                    {item.matchSource && (
                      <span
                        className={`text-xs ml-1 ${
                          item.matchSource === "label"
                            ? "text-blue-400"
                            : item.matchSource === "content"
                            ? "text-green-400"
                            : "text-gray-400"
                        }`}
                      >
                        ({item.matchSource})
                      </span>
                    )}
                  </p>
                )}

                <p
                  className="text-base md:text-sm text-zinc-800 dark:text-zinc-200 max-w-full truncate" // Adjusted font size
                  title={item.displaySnippetText}
                >
                  <HighlightMultiple
                    text={item.displaySnippetText}
                    query={query}
                    opts={opts}
                  />
                </p>
              </div>
            )
          )
        )}
      </div>
    </div>
  );
}


--- src\components\SettingsDialog.jsx ---
// src/components/SettingsDialog.jsx
import React, { useState, useMemo } from "react"; // Removed useCallback as handleDirectorySelect is removed
import { X, Search, RotateCcw, AlertTriangle } from "lucide-react"; // Removed FolderOutput
import {
  useSettings,
  defaultSettings,
  themeOptions,
  exportFormatOptions,
  editorFontFamilyOptions,
  editorFontSizeOptions,
} from "../contexts/SettingsContext";

function valueLabel(setting, currentSettings) {
  const v = currentSettings[setting.id];
  if (typeof v === "boolean") return v ? "Enabled" : "Disabled";
  if (setting.options) {
    const o = setting.options.find((opt) => opt.value === v);
    if (o) return o.label;
  }
  if (setting.id === "defaultExportFormat") {
    const o = exportFormatOptions.find((opt) => opt.value === v);
    if (o) return o.label;
  }
  if (setting.id === "autoExportIntervalMinutes")
    return v ? `${v} minutes` : "Not set";
  // autoExportDirectory is removed, so no special handling needed here for it

  return String(v);
}

export default function SettingsDialog({ isOpen, onClose }) {
  let context;
  try {
    context = useSettings();
  } catch {
    context = {
      settings: defaultSettings,
      updateSetting: () => {},
      resetSettings: () => {},
      resetApplicationData: () => {},
    };
  }
  const { settings, updateSetting, resetSettings, resetApplicationData } =
    context;
  const [search, setSearch] = useState("");

  // handleDirectorySelect is removed

  const allSettingsDescriptors = useMemo(
    () => [
      {
        id: "theme",
        label: "Theme",
        desc: "Select the application color scheme.",
        options: themeOptions,
        control: (
          <select
            id="theme"
            data-item-id="setting-theme-select"
            value={settings.theme}
            onChange={(e) => updateSetting("theme", e.target.value)}
            className="p-1 border rounded bg-white dark:bg-zinc-700 dark:border-zinc-600 min-w-[150px]"
          >
            {themeOptions.map((o) => (
              <option key={o.value} value={o.value}>
                {o.label}
              </option>
            ))}
          </select>
        ),
      },
      {
        id: "autoExpandNewFolders",
        label: "Auto-Expand New Folders",
        desc: "Automatically expand parent folders when adding a new item.",
        control: (
          <input
            id="autoExpandNewFolders"
            type="checkbox"
            data-item-id="setting-autoexpand-checkbox"
            checked={!!settings.autoExpandNewFolders}
            onChange={(e) =>
              updateSetting("autoExpandNewFolders", e.target.checked)
            }
            className="form-checkbox h-5 w-5 text-blue-600 rounded cursor-pointer"
          />
        ),
      },
      {
        id: "editorFontFamily",
        label: "Default Editor Font",
        desc: "Default font family for the note/task editor.",
        options: editorFontFamilyOptions,
        control: (
          <select
            id="editorFontFamily"
            data-item-id="setting-fontfamily-select"
            value={settings.editorFontFamily}
            onChange={(e) => updateSetting("editorFontFamily", e.target.value)}
            className="p-1 border rounded bg-white dark:bg-zinc-700 dark:border-zinc-600 min-w-[150px]"
          >
            {editorFontFamilyOptions.map((o) => (
              <option key={o.value} value={o.value}>
                {o.label}
              </option>
            ))}
          </select>
        ),
      },
      {
        id: "editorFontSize",
        label: "Default Editor Font Size",
        desc: "Default font size for the note/task editor.",
        options: editorFontSizeOptions,
        control: (
          <select
            id="editorFontSize"
            data-item-id="setting-fontsize-select"
            value={settings.editorFontSize}
            onChange={(e) => updateSetting("editorFontSize", e.target.value)}
            className="p-1 border rounded bg-white dark:bg-zinc-700 dark:border-zinc-600 min-w-[150px]"
          >
            {editorFontSizeOptions.map((o) => (
              <option key={o.value} value={o.value}>
                {o.label}
              </option>
            ))}
          </select>
        ),
      },
      {
        id: "defaultExportFormat",
        label: "Default Export Format",
        desc: "Pre-selected format when exporting items or the tree.",
        control: (
          <div className="flex space-x-3">
            {exportFormatOptions.map((o) => (
              <label
                key={o.value}
                className="flex items-center space-x-1 cursor-pointer"
              >
                <input
                  type="radio"
                  name="defaultExportFormat"
                  data-item-id={`setting-exportformat-${o.value}`}
                  value={o.value}
                  checked={settings.defaultExportFormat === o.value}
                  onChange={(e) =>
                    updateSetting("defaultExportFormat", e.target.value)
                  }
                  className="form-radio text-blue-600 cursor-pointer"
                />
                <span>{o.label}</span>
              </label>
            ))}
          </div>
        ),
      },
      {
        id: "autoExportGroup",
        type: "group",
        label: "Automatic Backup (Auto Export)",
        desc: "Configure periodic automatic export of the entire tree. Exports trigger standard browser downloads.",
        settings: [
          {
            id: "autoExportEnabled",
            label: "Enable Auto Export",
            desc: "Toggle automatic background tree exports.",
            control: (
              <input
                id="autoExportEnabled"
                type="checkbox"
                data-item-id="setting-autoexportenabled-checkbox"
                checked={!!settings.autoExportEnabled}
                onChange={(e) =>
                  updateSetting("autoExportEnabled", e.target.checked)
                }
                className="form-checkbox h-5 w-5 text-blue-600 rounded cursor-pointer"
              />
            ),
          },
          {
            id: "autoExportIntervalMinutes",
            label: "Export Interval",
            desc: "In minutes (minimum 5).",
            control: (
              <input
                id="autoExportIntervalMinutes"
                type="number"
                data-item-id="setting-autoexportinterval-input"
                value={settings.autoExportIntervalMinutes || 30}
                onChange={(e) =>
                  updateSetting(
                    "autoExportIntervalMinutes",
                    Math.max(5, parseInt(e.target.value, 10) || 5)
                  )
                }
                className="p-1 border rounded bg-white dark:bg-zinc-700 dark:border-zinc-600 w-24 text-center"
                min="5"
                step="1"
              />
            ),
          },
          // Removed autoExportDirectory setting row from here
        ],
      },
      {
        id: "resetSettings",
        label: "Reset Settings",
        desc: "Reset all settings to their default values.",
        control: (
          <button
            type="button"
            data-item-id="setting-resetsettings-button"
            onClick={() => {
              if (window.confirm("Reset all settings to default?"))
                resetSettings();
            }}
            className="px-3 py-1 text-sm bg-yellow-500 text-white rounded hover:bg-yellow-600 flex items-center"
          >
            <RotateCcw className="w-4 h-4 mr-1" /> Reset
          </button>
        ),
      },
      {
        id: "resetData",
        label: "Reset Application Data",
        desc: "WARNING: Deletes all notes, tasks, folders, and resets settings. Requires manual tree data clearing.",
        control: (
          <button
            type="button"
            data-item-id="setting-resetdata-button"
            onClick={() => {
              if (
                window.confirm(
                  "WARNING: This will permanently delete all application data (including settings and potentially tree data if not cleared separately). Are you sure?"
                )
              ) {
                resetApplicationData();
              }
            }}
            className="px-3 py-1 text-sm bg-red-600 text-white rounded hover:bg-red-700 flex items-center"
          >
            <AlertTriangle className="w-4 h-4 mr-1" /> Reset All Data
          </button>
        ),
      },
    ],
    [
      settings.autoExportEnabled,
      settings.autoExportIntervalMinutes,
      /* removed settings.autoExportDirectory */ settings.theme,
      settings.autoExpandNewFolders,
      settings.editorFontFamily,
      settings.editorFontSize,
      settings.defaultExportFormat,
      updateSetting,
      resetSettings,
      resetApplicationData /* removed handleDirectorySelect */,
    ]
  );

  const filteredSettings = useMemo(() => {
    if (!search) return allSettingsDescriptors;
    const term = search.toLowerCase();
    return allSettingsDescriptors.filter((s) => {
      if (s.type === "group") {
        if (
          s.label.toLowerCase().includes(term) ||
          (s.desc && s.desc.toLowerCase().includes(term))
        ) {
          return true;
        }
        return s.settings.some(
          (sub) =>
            sub.label.toLowerCase().includes(term) ||
            (sub.desc && sub.desc.toLowerCase().includes(term)) ||
            valueLabel(sub, settings).toLowerCase().includes(term)
        );
      } else {
        return (
          s.label.toLowerCase().includes(term) ||
          (s.desc && s.desc.toLowerCase().includes(term)) ||
          valueLabel(s, settings).toLowerCase().includes(term)
        );
      }
    });
  }, [allSettingsDescriptors, search, settings]);

  if (!isOpen) return null;

  return (
    <div
      data-item-id="settings-dialog-overlay"
      className="fixed inset-0 bg-black bg-opacity-60 flex justify-center items-center z-50 p-4 backdrop-blur-sm transition-opacity duration-200"
    >
      <div
        data-item-id="settings-dialog-content"
        className="bg-white dark:bg-zinc-800 p-5 rounded-lg shadow-xl w-full max-w-3xl max-h-[85vh] flex flex-col border border-zinc-200 dark:border-zinc-700"
      >
        <div className="flex justify-between items-center mb-4 border-b pb-3 dark:border-zinc-600 flex-shrink-0">
          <h2 className="text-xl font-semibold">Settings</h2>
          <button
            onClick={onClose}
            aria-label="Close Settings"
            data-item-id="settings-close-button-header"
            className="p-1 rounded-full text-zinc-500 dark:text-zinc-400 hover:bg-zinc-200 dark:hover:bg-zinc-700"
          >
            {" "}
            <X className="w-5 h-5" />{" "}
          </button>
        </div>
        <div className="mb-4 relative flex-shrink-0">
          <input
            data-item-id="settings-search-input"
            type="text"
            placeholder="Search settings..."
            value={search}
            onChange={(e) => setSearch(e.target.value)}
            className="w-full p-2 pl-10 border rounded dark:bg-zinc-700 dark:border-zinc-600 focus:outline-none focus:ring-2 focus:ring-blue-500"
          />
          <Search className="w-5 h-5 text-zinc-400 absolute left-3 top-1/2 transform -translate-y-1/2 pointer-events-none" />
        </div>
        <div className="flex-grow overflow-y-auto space-y-3 pr-2 -mr-2 custom-scrollbar">
          {filteredSettings.length ? (
            filteredSettings.map((s) => {
              if (s.type === "group") {
                // Check if the group's controlling setting (autoExportEnabled) is active
                const isGroupContentDisabled =
                  s.settings.find((sub) => sub.id === "autoExportEnabled") &&
                  !settings.autoExportEnabled;

                return (
                  <div
                    key={s.id}
                    data-item-id={`setting-group-${s.id}`}
                    className="p-4 my-3 border border-zinc-300 dark:border-zinc-600 rounded-lg shadow-sm bg-zinc-50 dark:bg-zinc-800/30"
                  >
                    <h4 className="text-md font-semibold mb-1 text-zinc-700 dark:text-zinc-200">
                      {s.label}
                    </h4>
                    {s.desc && (
                      <p className="text-sm text-zinc-500 dark:text-zinc-400 mb-4">
                        {s.desc}
                      </p>
                    )}
                    <div className="space-y-5">
                      {s.settings.map((subSetting) => {
                        const isControlDisabledByGroupLogic =
                          subSetting.id !== "autoExportEnabled" &&
                          isGroupContentDisabled;
                        const finalDisabledState =
                          (subSetting.control.props &&
                            subSetting.control.props.disabled) ||
                          isControlDisabledByGroupLogic;

                        return (
                          <div
                            key={subSetting.id}
                            data-item-id={`setting-row-${subSetting.id}`}
                            className="flex flex-col sm:flex-row sm:items-start sm:justify-between pb-4 border-b border-zinc-200 dark:border-zinc-600 last:border-b-0 last:pb-0"
                          >
                            <div
                              className={`mb-2 sm:mb-0 sm:mr-4 flex-1 ${
                                finalDisabledState ? "opacity-60" : ""
                              }`}
                            >
                              <label
                                htmlFor={subSetting.id}
                                className="font-medium block"
                              >
                                {subSetting.label}
                              </label>
                              {subSetting.desc && (
                                <p className="text-sm text-zinc-600 dark:text-zinc-400">
                                  {subSetting.desc}
                                </p>
                              )}
                              {/* No specific path display here anymore as the setting itself is removed */}
                            </div>
                            <div className="flex-shrink-0 flex items-center mt-1 sm:mt-0">
                              {React.cloneElement(subSetting.control, {
                                id: subSetting.id,
                                disabled: finalDisabledState,
                              })}
                            </div>
                          </div>
                        );
                      })}
                    </div>
                  </div>
                );
              } else {
                // Render individual, non-grouped settings
                return (
                  <div
                    key={s.id}
                    data-item-id={`setting-row-${s.id}`}
                    className="flex flex-col sm:flex-row sm:items-start sm:justify-between pb-4 border-b border-zinc-200 dark:border-zinc-700 last:border-b-0"
                  >
                    <div className="mb-2 sm:mb-0 sm:mr-4 flex-1">
                      <label
                        htmlFor={s.id}
                        className={`font-medium block ${
                          s.id === "resetData"
                            ? "text-red-600 dark:text-red-400"
                            : ""
                        }`}
                      >
                        {s.label}
                      </label>
                      <p className="text-sm text-zinc-600 dark:text-zinc-400">
                        {s.desc}
                      </p>
                    </div>
                    <div className="flex-shrink-0 flex items-center mt-1 sm:mt-0">
                      {React.cloneElement(s.control, { id: s.id })}
                    </div>
                  </div>
                );
              }
            })
          ) : (
            <p
              data-item-id="settings-no-results"
              className="text-zinc-500 dark:text-zinc-400 text-center py-6"
            >
              {" "}
              No settings found matching your search.{" "}
            </p>
          )}
        </div>
        <div className="mt-6 pt-4 border-t dark:border-zinc-600 flex justify-end flex-shrink-0">
          <button
            data-item-id="settings-close-button-footer"
            onClick={onClose}
            className="px-5 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500"
          >
            {" "}
            Close{" "}
          </button>
        </div>
      </div>
    </div>
  );
}


--- src\components\TaskItem.jsx ---
import React from "react";

const TaskItem = ({ task, onToggle }) => {
  if (!task) return null;
  return (
    <div className="p-4">
      <label className="flex items-center space-x-2">
        <input
          type="checkbox"
          checked={task.completed}
          onChange={e => onToggle(e.target.checked)}
          className="form-checkbox"
        />
        <span className={task.completed ? "line-through text-gray-500" : ""}>
          {task.label}
        </span>
      </label>
    </div>
  );
};

export default TaskItem;

--- src\components\Tree.jsx ---
// src/components/Tree.jsx
import React, { useRef, useState, useEffect, useCallback } from "react";
import { sortItems, isSelfOrDescendant } from "../utils/treeUtils";
// --- MODIFICATION: Import MoreVertical icon ---
import { MoreVertical } from "lucide-react";
// --- END MODIFICATION ---

const INDENT_SIZE = 16; // Pixels for indentation per level

const Tree = ({
  items,
  selectedItemId,
  onSelect,
  inlineRenameId,
  inlineRenameValue,
  setInlineRenameValue,
  onAttemptRename,
  cancelInlineRename,
  expandedFolders,
  onToggleExpand,
  onToggleTask,
  draggedId,
  onDragStart,
  onDrop,
  onNativeContextMenu, // Renamed prop for clarity
  onShowItemMenu, // --- MODIFICATION: New prop for button click ---
  onRename,
  onDragEnd,
  uiError,
  setUiError,
}) => {
  const navRef = useRef(null);
  const [dragOverId, setDragOverId] = useState(null);
  const [localRenameError, setLocalRenameError] = useState("");

  // --- Callbacks (refocusTree, getVisible, findParent, handleKeyDown, drag/drop handlers) remain the same ---
  const refocusTree = useCallback(() => {
    /* ... */ requestAnimationFrame(() => {
      navRef.current?.focus({ preventScroll: true });
    });
  }, []);
  useEffect(() => {
    if (inlineRenameId) {
      setLocalRenameError("");
    }
  }, [uiError, inlineRenameId]);
  const getVisible = useCallback((nodes, currentExpandedFolders) => {
    let out = [];
    const currentNodes = Array.isArray(nodes) ? nodes : [];
    sortItems(currentNodes).forEach((it) => {
      out.push(it);
      if (
        it.type === "folder" &&
        Array.isArray(it.children) &&
        currentExpandedFolders[it.id]
      ) {
        out = out.concat(getVisible(it.children, currentExpandedFolders));
      }
    });
    return out;
  }, []);
  const findParent = useCallback((nodes, childId, parent = null) => {
    const currentNodes = Array.isArray(nodes) ? nodes : [];
    for (const it of currentNodes) {
      if (it.id === childId) return parent;
      if (Array.isArray(it.children)) {
        const p = findParent(it.children, childId, it);
        if (p) return p;
      }
    }
    return null;
  }, []);
  const handleKeyDown = useCallback(
    (e) => {
      /* ... keyboard nav logic ... */
      const activeElement = document.activeElement;
      const isRenameInputFocused = activeElement?.closest(
        `li[data-item-id="${inlineRenameId}"] input`
      );
      if (isRenameInputFocused) {
        if (e.key === "Enter" || e.key === "Escape") {
          /* handled by input */
        }
        return;
      }
      const treeNav = navRef.current;
      const isTreeAreaFocused =
        treeNav &&
        (treeNav === activeElement ||
          treeNav.contains(activeElement) ||
          activeElement === document.body);
      if (
        !isTreeAreaFocused &&
        !(activeElement === document.body && selectedItemId)
      )
        return;
      const visibleItems = getVisible(items, expandedFolders);
      const currentIndex = visibleItems.findIndex(
        (it) => it.id === selectedItemId
      );
      const currentItem =
        currentIndex !== -1 ? visibleItems[currentIndex] : null;
      let nextItemId = null;
      switch (e.key) {
        case "ArrowDown":
          e.preventDefault();
          if (visibleItems.length === 0) break;
          nextItemId =
            currentIndex < visibleItems.length - 1
              ? visibleItems[currentIndex + 1].id
              : currentIndex === -1
              ? visibleItems[0].id
              : null;
          if (nextItemId) onSelect(nextItemId);
          break;
        case "ArrowUp":
          e.preventDefault();
          if (visibleItems.length === 0) break;
          nextItemId =
            currentIndex > 0
              ? visibleItems[currentIndex - 1].id
              : currentIndex === -1
              ? visibleItems[0].id
              : null;
          if (nextItemId) onSelect(nextItemId);
          break;
        case "ArrowRight":
          e.preventDefault();
          if (currentItem) {
            if (currentItem.type === "folder") {
              if (!expandedFolders[currentItem.id]) {
                onToggleExpand(currentItem.id, true);
              } else if (
                Array.isArray(currentItem.children) &&
                currentItem.children.length > 0
              ) {
                const sortedChildren = sortItems(currentItem.children);
                if (sortedChildren.length > 0) {
                  onSelect(sortedChildren[0].id);
                }
              }
            }
          }
          break;
        case "ArrowLeft":
          e.preventDefault();
          if (currentItem) {
            if (
              currentItem.type === "folder" &&
              expandedFolders[currentItem.id]
            ) {
              onToggleExpand(currentItem.id, false);
            } else {
              const parent = findParent(items, currentItem.id);
              if (parent) {
                onSelect(parent.id);
              }
            }
          }
          break;
        case " ":
          e.preventDefault();
          if (currentItem && currentItem.type === "task") {
            onToggleTask(currentItem.id, !currentItem.completed);
          }
          break;
        default:
          break;
      }
    },
    [
      items,
      expandedFolders,
      selectedItemId,
      onSelect,
      onToggleExpand,
      findParent,
      getVisible,
      onToggleTask,
      inlineRenameId,
    ]
  );
  const handleDragOver = useCallback(
    (e, item) => {
      e.preventDefault();
      e.stopPropagation();
      if (
        item?.type === "folder" &&
        item.id !== draggedId &&
        !isSelfOrDescendant(items, draggedId, item.id)
      ) {
        setDragOverId(item.id);
      } else {
        setDragOverId(null);
      }
    },
    [draggedId, items]
  );
  const handleDragLeave = useCallback((e) => {
    e.preventDefault();
    e.stopPropagation();
    setDragOverId(null);
  }, []);
  const handleItemDrop = useCallback(
    (e, targetItem) => {
      e.preventDefault();
      e.stopPropagation();
      const currentDragOverId = dragOverId;
      setDragOverId(null);
      if (
        targetItem?.id === currentDragOverId &&
        targetItem?.type === "folder" &&
        targetItem.id !== draggedId
      ) {
        onDrop(targetItem.id);
      }
    },
    [dragOverId, draggedId, onDrop]
  );

  const renderItems = useCallback(
    (nodes, depth = 0) => (
      <ul className="list-none p-0 m-0">
        {(Array.isArray(nodes) ? sortItems(nodes) : []).map((item) => {
          const isBeingDragged = item.id === draggedId;
          const isDragOverTarget = item.id === dragOverId;
          const isSelected = item.id === selectedItemId;
          const isRenaming = item.id === inlineRenameId;
          const hasError = isRenaming && (localRenameError || uiError);

          return (
            <li
              key={item.id}
              data-item-id={item.id}
              className={`group relative text-base md:text-sm ${
                isBeingDragged ? "opacity-40" : ""
              }`}
              draggable={!isRenaming}
              onDragStart={(e) => {
                if (isRenaming) {
                  e.preventDefault();
                  return;
                }
                e.stopPropagation();
                onDragStart(e, item.id);
              }}
              onDragOver={(e) => handleDragOver(e, item)}
              onDragLeave={handleDragLeave}
              onDrop={(e) => handleItemDrop(e, item)}
              onDragEnd={onDragEnd}
              // --- MODIFICATION: Use onNativeContextMenu for actual right-click/long-press ---
              onContextMenu={(e) => {
                if (draggedId || isRenaming) {
                  e.preventDefault();
                  return;
                }
                e.preventDefault();
                e.stopPropagation();
                onSelect(item.id); // Select item first
                onNativeContextMenu(e, item); // Call original handler
              }}
              // --- END MODIFICATION ---
            >
              {isDragOverTarget && (
                <div
                  data-item-id="drag-over-indicator"
                  className="absolute inset-y-0 left-0 right-0 bg-blue-200 dark:bg-blue-800 opacity-30 rounded pointer-events-none z-0"
                  aria-hidden="true"
                ></div>
              )}
              <div
                className={`relative z-10 flex items-center cursor-pointer rounded py-1.5 sm:py-1 pr-1 ${
                  // Reduced right padding to make space for button
                  isSelected && !isRenaming
                    ? "bg-blue-600 text-white"
                    : "hover:bg-zinc-100 dark:hover:bg-zinc-700"
                } ${
                  isDragOverTarget
                    ? "bg-blue-100 dark:bg-blue-900 text-zinc-900 dark:text-zinc-100"
                    : ""
                }`}
                style={{
                  paddingLeft: `${depth * INDENT_SIZE + (depth > 0 ? 4 : 0)}px`,
                }}
                onClick={(e) => {
                  if (isBeingDragged || isRenaming) return;
                  e.stopPropagation();
                  onSelect(item.id);
                }}
                // Removed onDoubleClick here, rely on context menu or F2
                // onDoubleClick={(e) => { if (isRenaming) return; e.stopPropagation(); onRename(item); }}
              >
                {/* Expand/Collapse Button & Icon Area */}
                <div className="w-6 h-6 flex-shrink-0 flex items-center justify-center mr-1">
                  {item.type === "folder" ? (
                    <button
                      onClick={(e) => {
                        e.stopPropagation();
                        onToggleExpand(item.id);
                      }}
                      className={`flex items-center justify-center h-full w-full focus:outline-none text-xs rounded-sm p-0.5 ${
                        isSelected && !isRenaming
                          ? "text-white"
                          : "text-zinc-500 dark:text-zinc-400"
                      } hover:bg-black/10 dark:hover:bg-white/10`}
                      aria-expanded={!!expandedFolders[item.id]}
                      aria-label={
                        expandedFolders[item.id]
                          ? `Collapse ${item.label}`
                          : `Expand ${item.label}`
                      }
                      title={expandedFolders[item.id] ? `Collapse` : `Expand`}
                    >
                      {" "}
                      {expandedFolders[item.id] ? "‚ñæ" : "‚ñ∏"}{" "}
                    </button>
                  ) : (
                    <span
                      className="inline-block w-full h-full"
                      aria-hidden="true"
                    >
                      &nbsp;
                    </span>
                  )}
                </div>
                {/* Item Icon */}
                <div className="w-6 h-6 flex-shrink-0 flex items-center justify-center mr-1.5 sm:mr-1">
                  {item.type === "folder" ? (
                    <span
                      className={`${
                        !item.children || item.children.length === 0
                          ? "opacity-50"
                          : ""
                      }`}
                      aria-hidden="true"
                    >
                      {" "}
                      {expandedFolders[item.id] ? "üìÇ" : "üìÅ"}{" "}
                    </span>
                  ) : item.type === "task" ? (
                    <button
                      onClick={(e) => {
                        e.stopPropagation();
                        onToggleTask(item.id, !item.completed);
                      }}
                      className="focus:outline-none flex items-center justify-center cursor-pointer w-full h-full"
                      aria-checked={!!item.completed}
                      role="checkbox"
                      aria-label={`Mark task ${item.label} as ${
                        item.completed ? "incomplete" : "complete"
                      }`}
                      title={`Mark as ${
                        item.completed ? "incomplete" : "complete"
                      }`}
                    >
                      {" "}
                      {item.completed ? "‚úÖ" : "‚¨úÔ∏è"}{" "}
                    </button>
                  ) : (
                    <span aria-hidden="true">üìù</span>
                  )}
                </div>
                {/* Label or Rename Input */}
                <div
                  className="flex-1 truncate relative"
                  style={{ minWidth: 0 }}
                >
                  {isRenaming ? (
                    <>
                      <input
                        type="text"
                        className={`w-full bg-white dark:bg-zinc-800 outline-none border px-1 py-0.5 text-base md:text-sm rounded ${
                          hasError
                            ? "border-red-500 text-red-700 dark:text-red-400"
                            : "border-blue-400 text-black dark:text-white"
                        }`}
                        value={inlineRenameValue}
                        onChange={(e) => {
                          setInlineRenameValue(e.target.value);
                          setLocalRenameError("");
                          if (setUiError) setUiError("");
                        }}
                        onClick={(e) => e.stopPropagation()}
                        onBlur={() => {
                          if (onAttemptRename) onAttemptRename();
                        }}
                        onKeyDown={(e) => {
                          if (e.key === "Enter") {
                            e.preventDefault();
                            if (onAttemptRename) onAttemptRename();
                          } else if (e.key === "Escape") {
                            e.preventDefault();
                            cancelInlineRename();
                            refocusTree();
                          }
                        }}
                        autoFocus
                        onFocus={(e) => e.target.select()}
                        aria-invalid={!!hasError}
                        aria-describedby={
                          hasError ? `${item.id}-rename-error` : undefined
                        }
                      />
                      {hasError && (
                        <span
                          id={`${item.id}-rename-error`}
                          className="absolute left-1 top-full mt-0.5 text-xs text-red-600 dark:text-red-400 whitespace-normal z-10"
                        >
                          {" "}
                          {localRenameError || uiError}{" "}
                        </span>
                      )}
                    </>
                  ) : (
                    <span
                      className={` ${
                        item.type === "task" && item.completed
                          ? "line-through text-zinc-500 dark:text-zinc-400"
                          : ""
                      }`}
                    >
                      {" "}
                      {item.label}{" "}
                    </span>
                  )}
                </div>
                {/* --- MODIFICATION: Add More Options Button --- */}
                <button
                  onClick={(e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    onSelect(item.id); // Ensure item is selected
                    onShowItemMenu(item, e.currentTarget); // Pass item and button element
                  }}
                  className={`ml-1 p-1 rounded hover:bg-black/10 dark:hover:bg-white/20 ${
                    isSelected && !isRenaming
                      ? "text-white"
                      : "text-zinc-500 dark:text-zinc-400"
                  } opacity-0 group-hover:opacity-100 focus:opacity-100`} // Show on hover/focus
                  aria-label={`More options for ${item.label}`}
                  title="More options"
                >
                  <MoreVertical className="w-4 h-4" />
                </button>
                {/* --- END MODIFICATION --- */}
              </div>
              {item.type === "folder" &&
                Array.isArray(item.children) &&
                expandedFolders[item.id] &&
                renderItems(item.children, depth + 1)}
            </li>
          );
        })}
      </ul>
    ),
    [
      items,
      selectedItemId,
      inlineRenameId,
      inlineRenameValue,
      expandedFolders,
      draggedId,
      dragOverId,
      onSelect,
      setInlineRenameValue,
      onAttemptRename,
      cancelInlineRename,
      onToggleExpand,
      onToggleTask,
      onDragStart,
      handleDragOver,
      handleDragLeave,
      handleItemDrop,
      onDrop,
      onNativeContextMenu,
      onShowItemMenu, // Use updated/new props
      onRename,
      onDragEnd,
      refocusTree,
      uiError,
      setUiError,
      localRenameError,
    ]
  );

  return (
    <nav
      ref={navRef}
      className="overflow-auto h-full p-1.5 sm:p-1 text-zinc-900 dark:text-zinc-100 focus:outline-none focus:ring-2 focus:ring-blue-400 rounded"
      tabIndex={0}
      onKeyDown={handleKeyDown}
      // --- MODIFICATION: Use onNativeContextMenu for empty area ---
      onContextMenu={(e) => {
        if (!draggedId && !inlineRenameId && e.target === navRef.current) {
          e.preventDefault();
          onSelect(null);
          onNativeContextMenu(e, null); // Show empty area menu via original handler
        } else if (draggedId || inlineRenameId) {
          e.preventDefault();
        }
      }}
      // --- END MODIFICATION ---
      aria-label="Notes and Tasks Tree"
    >
      {renderItems(items)}
    </nav>
  );
};

export default Tree;


--- src\contexts\SettingsContext.jsx ---
// src/contexts/SettingsContext.jsx
import React, {
  createContext,
  useContext,
  useState,
  useEffect,
  useCallback,
} from "react";

// Make sure these arrays are populated with your actual options
export const themeOptions = [
  { value: "system", label: "System Default" },
  { value: "light", label: "Light" },
  { value: "dark", label: "Dark" },
];
export const sortOrderOptions = [
  /* Placeholder if you use it elsewhere */
];
export const exportFormatOptions = [
  { value: "json", label: "JSON" },
  { value: "pdf", label: "PDF" },
];
export const editorFontFamilyOptions = [
  { value: "Arial", label: "Arial" },
  { value: "Verdana", label: "Verdana" },
  { value: "Times New Roman", label: "Times New Roman" },
  { value: "Courier New", label: "Courier New" },
  { value: "Georgia", label: "Georgia" },
];
export const editorFontSizeOptions = [
  { value: "1", label: "Smallest" },
  { value: "2", label: "Smaller" },
  { value: "3", label: "Normal" },
  { value: "4", label: "Larger" },
  { value: "5", label: "Largest" },
];

export const defaultSettings = {
  theme: "system",
  autoExpandNewFolders: true,
  editorFontFamily:
    editorFontFamilyOptions.length > 0
      ? editorFontFamilyOptions[0].value
      : "Arial",
  editorFontSize:
    editorFontSizeOptions.length > 2 ? editorFontSizeOptions[2].value : "3",
  defaultExportFormat: "json",
  autoExportEnabled: false,
  autoExportIntervalMinutes: 30,
  // autoExportDirectory: '', // Removed this line
};

const SettingsContext = createContext();

export const useSettings = () => {
  const context = useContext(SettingsContext);
  if (!context) {
    console.error(
      "useSettings must be used within a SettingsProvider. Falling back to default settings."
    );
    return {
      settings: defaultSettings,
      updateSetting: () =>
        console.warn("SettingsProvider not found, updateSetting is a no-op."),
      resetSettings: () =>
        console.warn("SettingsProvider not found, resetSettings is a no-op."),
      resetApplicationData: () =>
        console.warn(
          "SettingsProvider not found, resetApplicationData is a no-op."
        ),
      defaultSettings,
    };
  }
  return context;
};

export const SettingsProvider = ({ children }) => {
  const [settings, setSettings] = useState(() => {
    try {
      const storedSettings = localStorage.getItem("appSettings");
      const initialSettings = storedSettings ? JSON.parse(storedSettings) : {};
      // Ensure all default keys are present, even if not in storedSettings
      const mergedSettings = { ...defaultSettings, ...initialSettings };
      // Remove autoExportDirectory explicitly if it exists from older versions
      delete mergedSettings.autoExportDirectory;
      return mergedSettings;
    } catch (error) {
      console.error("Failed to load settings from localStorage:", error);
      const fallbackSettings = { ...defaultSettings };
      delete fallbackSettings.autoExportDirectory;
      return fallbackSettings;
    }
  });

  useEffect(() => {
    try {
      // Create a copy of settings to save, excluding autoExportDirectory if it somehow crept in
      const settingsToSave = { ...settings };
      delete settingsToSave.autoExportDirectory;

      localStorage.setItem("appSettings", JSON.stringify(settingsToSave));
      document.documentElement.className = "";
      if (
        settings.theme === "dark" ||
        (settings.theme === "system" &&
          window.matchMedia("(prefers-color-scheme: dark)").matches)
      ) {
        document.documentElement.classList.add("dark");
      }
    } catch (error) {
      console.error("Failed to save settings or apply theme:", error);
    }
  }, [settings]);

  const updateSetting = useCallback((key, value) => {
    setSettings((prevSettings) => {
      const newSettings = {
        ...prevSettings,
        [key]: value,
      };
      // Ensure autoExportDirectory is not part of the settings state if key is not it
      if (key !== "autoExportDirectory") {
        delete newSettings.autoExportDirectory;
      } else if (key === "autoExportDirectory" && value === undefined) {
        // If explicitly trying to remove it
        delete newSettings.autoExportDirectory;
      }
      return newSettings;
    });
  }, []);

  const resetSettings = useCallback(() => {
    const newDefaultSettings = { ...defaultSettings };
    delete newDefaultSettings.autoExportDirectory;
    setSettings(newDefaultSettings);
  }, []);

  const resetApplicationData = useCallback(() => {
    console.warn(
      "resetApplicationData called - ensure LOCAL_STORAGE_KEY for tree data is also cleared here."
    );
    resetSettings();
    alert(
      "Application settings have been reset. Full data reset requires additional implementation for tree data."
    );
  }, [resetSettings]);

  return (
    <SettingsContext.Provider
      value={{
        settings,
        updateSetting,
        resetSettings,
        resetApplicationData,
        defaultSettings,
      }}
    >
      {children}
    </SettingsContext.Provider>
  );
};


--- src\contexts\SettingsContext.jsx ---
// src/contexts/SettingsContext.jsx
import React, {
  createContext,
  useContext,
  useState,
  useEffect,
  useCallback,
} from "react";

// Make sure these arrays are populated with your actual options
export const themeOptions = [
  { value: "system", label: "System Default" },
  { value: "light", label: "Light" },
  { value: "dark", label: "Dark" },
];
export const sortOrderOptions = [
  /* Placeholder if you use it elsewhere */
];
export const exportFormatOptions = [
  { value: "json", label: "JSON" },
  { value: "pdf", label: "PDF" },
];
export const editorFontFamilyOptions = [
  { value: "Arial", label: "Arial" },
  { value: "Verdana", label: "Verdana" },
  { value: "Times New Roman", label: "Times New Roman" },
  { value: "Courier New", label: "Courier New" },
  { value: "Georgia", label: "Georgia" },
];
export const editorFontSizeOptions = [
  { value: "1", label: "Smallest" },
  { value: "2", label: "Smaller" },
  { value: "3", label: "Normal" },
  { value: "4", label: "Larger" },
  { value: "5", label: "Largest" },
];

export const defaultSettings = {
  theme: "system",
  autoExpandNewFolders: true,
  editorFontFamily:
    editorFontFamilyOptions.length > 0
      ? editorFontFamilyOptions[0].value
      : "Arial",
  editorFontSize:
    editorFontSizeOptions.length > 2 ? editorFontSizeOptions[2].value : "3",
  defaultExportFormat: "json",
  autoExportEnabled: false,
  autoExportIntervalMinutes: 30,
  // autoExportDirectory: '', // Removed this line
};

const SettingsContext = createContext();

export const useSettings = () => {
  const context = useContext(SettingsContext);
  if (!context) {
    console.error(
      "useSettings must be used within a SettingsProvider. Falling back to default settings."
    );
    return {
      settings: defaultSettings,
      updateSetting: () =>
        console.warn("SettingsProvider not found, updateSetting is a no-op."),
      resetSettings: () =>
        console.warn("SettingsProvider not found, resetSettings is a no-op."),
      resetApplicationData: () =>
        console.warn(
          "SettingsProvider not found, resetApplicationData is a no-op."
        ),
      defaultSettings,
    };
  }
  return context;
};

export const SettingsProvider = ({ children }) => {
  const [settings, setSettings] = useState(() => {
    try {
      const storedSettings = localStorage.getItem("appSettings");
      const initialSettings = storedSettings ? JSON.parse(storedSettings) : {};
      // Ensure all default keys are present, even if not in storedSettings
      const mergedSettings = { ...defaultSettings, ...initialSettings };
      // Remove autoExportDirectory explicitly if it exists from older versions
      delete mergedSettings.autoExportDirectory;
      return mergedSettings;
    } catch (error) {
      console.error("Failed to load settings from localStorage:", error);
      const fallbackSettings = { ...defaultSettings };
      delete fallbackSettings.autoExportDirectory;
      return fallbackSettings;
    }
  });

  useEffect(() => {
    try {
      // Create a copy of settings to save, excluding autoExportDirectory if it somehow crept in
      const settingsToSave = { ...settings };
      delete settingsToSave.autoExportDirectory;

      localStorage.setItem("appSettings", JSON.stringify(settingsToSave));
      document.documentElement.className = "";
      if (
        settings.theme === "dark" ||
        (settings.theme === "system" &&
          window.matchMedia("(prefers-color-scheme: dark)").matches)
      ) {
        document.documentElement.classList.add("dark");
      }
    } catch (error) {
      console.error("Failed to save settings or apply theme:", error);
    }
  }, [settings]);

  const updateSetting = useCallback((key, value) => {
    setSettings((prevSettings) => {
      const newSettings = {
        ...prevSettings,
        [key]: value,
      };
      // Ensure autoExportDirectory is not part of the settings state if key is not it
      if (key !== "autoExportDirectory") {
        delete newSettings.autoExportDirectory;
      } else if (key === "autoExportDirectory" && value === undefined) {
        // If explicitly trying to remove it
        delete newSettings.autoExportDirectory;
      }
      return newSettings;
    });
  }, []);

  const resetSettings = useCallback(() => {
    const newDefaultSettings = { ...defaultSettings };
    delete newDefaultSettings.autoExportDirectory;
    setSettings(newDefaultSettings);
  }, []);

  const resetApplicationData = useCallback(() => {
    console.warn(
      "resetApplicationData called - ensure LOCAL_STORAGE_KEY for tree data is also cleared here."
    );
    resetSettings();
    alert(
      "Application settings have been reset. Full data reset requires additional implementation for tree data."
    );
  }, [resetSettings]);

  return (
    <SettingsContext.Provider
      value={{
        settings,
        updateSetting,
        resetSettings,
        resetApplicationData,
        defaultSettings,
      }}
    >
      {children}
    </SettingsContext.Provider>
  );
};


--- src\fonts\NotoSansHebrewBase64.js ---
export const notoSansHebrewBase64 = `
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AYwBjQESAZEBLAAwAY8BrAHSAYQBtgGyAU0BTAGrAaoBQAF4ASsBqQFuAUYBVQGTARMAlwCiAKMAqACrALUAtgC7AL0AxQDGAMgAzQDOANMA3ADdAN4A4QDmAOoA8wD0APkA+gD/ARoBFgEbARABvgFTAQMBFQEfAS8BOQFLAU4BWgFeAWYBaAFqAXABdAF7AYoBkgGdAaMBrgG3AcEBwgHHAcgBzgEYARcBGQERAEIBSgEoAa0BqAEzAS4BhQFWAaABiQEyAYsBkAEmAYYBVwGUAJ0AmQCbAKEAnACgAJgApgCxAKwArgCvAMIAvgC/AMAAtADSANgA1QDWANsA1wFzANoA7gDrAOwA7QD7AOkBUgELAQQBBgEUAQkBDwEKASQBPwE6ATwBPQFjAV8BYAFhAUcBeQGCAXwBfQGIAX4BNQGHAbsBuAG5AboByQGxAcsAngEMAJoBBQCfAQ4ApAEgAKcBJQClASMAqQEwAKoBMQCyAUIAsAE+ALMBRQCtATsAtwFPALkBUQC4AVAAvAFbAMMBZADEAWUAwQFiAMcBaQDJAWsAywFtAMoBbADMAW8AzwF1ANEBdwDQAXYA2QGDANQBfwDfAZ4A4AGfAOIBpADkAaYA4wGlAOcBrwDwAb0A8gHAAO8BvADxAb8A9gHEAPwBygD9AQABzwECAdEBAQHQAOUBpwDoAbABKQEhARwBNwGhAYABswFcAVQBCAEqAbQBcQEdATgBNAGiAV0BIgEtAScBgQAUAFwAXQCQAI8AcgBYAJEASACJAHEAHgAfACEAUQBtAEoACQBBADoAQAA/ABIATgBuAIgARgAyABMAlAA8AF8AKAAkACYALQB1AFsASQBPAC4ALwBUAA8AZwA7AFUARwBkAGgAaQB7ADkARQBQAAMADAAiABAAKgB8AJIALABvAIoAFQA0ADcAFwA9ABgAQwBZAAoAGQBLABsAcwBSAFYAYABrAJYAfwCAAI0AHQAgAPgBxgD1AcMA9wHFAP4BzQFEAUMBlwGYAZYAjAAzAI4ACwCBAIIAgwCEAIUAHACGAIcACABlAGYAYgBjAAYABwAEAA0AIwARACsAfQCTAHAAiwAWADUAOABEAFoAGgBMAHQAUwBXAGEAbAB+AA4ANgBNAAUAAAAjAaoAAwABBAkAAACaBPYAAwABBAkAAQAgBNYAAwABBAkAAgAOBMgAAwABBAkAAwBCBIYAAwABBAkABAAwBFYAAwABBAkABQAaBDwAAwABBAkABgAsBBAAAwABBAkABwBEA8wAAwABBAkACAAUA7gAAwABBAkACQAUA6QAAwABBAkACgAsA3gAAwABBAkACwA+AzoAAwABBAkADAAqAxAAAwABBAkADQEiAe4AAwABBAkADgA2AbgAAwABBAkAGQAcAZwAAwABBAkBAAAMAZAAAwABBAkBAQAKAYYAAwABBAkBJgAaAWwAAwABBAkBJwB2APYAAwABBAkBKAAiANQAAwABBAkBKQAaALoAAwABBAkBKwAIALIAAwABBAkBLAAUAJ4AAwABBAkBLQAKAJQAAwABBAkBLgAOBMgAAwABBAkBLwAMAIgAAwABBAkBMAAQAHgAAwABBAkBMQAIAHAAAwABBAkBMgASAF4AAwABBAkBMwAKAFQAAwABBAkBNAAcADgAAwABBAkBNQASACYAAwABBAkBNgAaAAwAAwABBAkBNwAMAAAATgBvAHIAbQBhAGwAUwBlAG0AaQBDAG8AbgBkAGUAbgBzAGUAZABDAG8AbgBkAGUAbgBzAGUAZABFAHgAdAByAGEAQwBvAG4AZABlAG4AcwBlAGQAQgBsAGEAYwBrAEUAeAB0AHIAYQBCAG8AbABkAEIAbwBsAGQAUwBlAG0AaQBCAG8AbABkAE0AZQBkAGkAdQBtAEwAaQBnAGgAdABFAHgAdAByAGEATABpAGcAaAB0AFQAaABpAG4AaQBvAHQAYQAgAGEAZABzAGMAcgBpAHAAdABBAGMAYwBlAG4AdABlAGQAIABHAHIAZQBlAGsAIABTAEMAVABpAHQAbABpAG4AZwAgAEEAbAB0AGUAcgBuAGEAdABlAHMAIABJACAAYQBuAGQAIABKACAAZgBvAHIAIAB0AGkAdABsAGkAbgBnACAAYQBuAGQAIABhAGwAbAAgAGMAYQBwACAAcwBlAHQAdABpAG4AZwBzAGYAbABvAHIAaQBuACAAcwB5AG0AYgBvAGwAVwBpAGQAdABoAFcAZQBpAGcAaAB0AE4AbwB0AG8AUwBhAG4AcwBIAGUAYgByAGUAdwBoAHQAdABwAHMAOgAvAC8AbwBwAGUAbgBmAG8AbgB0AGwAaQBjAGUAbgBzAGUALgBvAHIAZwBUAGgAaQBzACAARgBvAG4AdAAgAFMAbwBmAHQAdwBhAHIAZQAgAGkAcwAgAGwAaQBjAGUAbgBzAGUAZAAgAHUAbgBkAGUAcgAgAHQAaABlACAAUwBJAEwAIABPAHAAZQBuACAARgBvAG4AdAAgAEwAaQBjAGUAbgBzAGUALAAgAFYAZQByAHMAaQBvAG4AIAAxAC4AMQAuACAAVABoAGkAcwAgAGwAaQBjAGUAbgBzAGUAIABpAHMAIABhAHYAYQBpAGwAYQBiAGwAZQAgAHcAaQB0AGgAIABhACAARgBBAFEAIABhAHQAOgAgAGgAdAB0AHAAcwA6AC8ALwBvAHAAZQBuAGYAbwBuAHQAbABpAGMAZQBuAHMAZQAuAG8AcgBnAGgAdAB0AHAAcwA6AC8ALwBoAGEAZgBvAG4AdABpAGEALgBjAG8AbQAvAGgAdAB0AHAAOgAvAC8AdwB3AHcALgBnAG8AbwBnAGwAZQAuAGMAbwBtAC8AZwBlAHQALwBuAG8AdABvAC8ARABlAHMAaQBnAG4AZQBkACAAYgB5ACAAQgBlAG4AIABOAGEAdABoAGEAbgBCAGUAbgAgAE4AYQB0AGgAYQBuAEcAbwBvAGcAbABlACAATABMAEMATgBvAHQAbwAgAGkAcwAgAGEAIAB0AHIAYQBkAGUAbQBhAHIAawAgAG8AZgAgAEcAbwBvAGcAbABlACAASQBuAGMALgBOAG8AdABvAFMAYQBuAHMASABlAGIAcgBlAHcALQBSAGUAZwB1AGwAYQByAFYAZQByAHMAaQBvAG4AIAAzAC4AMAAwADEATgBvAHQAbwAgAFMAYQBuAHMAIABIAGUAYgByAGUAdwAgAFIAZQBnAHUAbABhAHIAMwAuADAAMAAxADsARwBPAE8ARwA7AE4AbwB0AG8AUwBhAG4AcwBIAGUAYgByAGUAdwAtAFIAZQBnAHUAbABhAHIAUgBlAGcAdQBsAGEAcgBOAG8AdABvACAAUwBhAG4AcwAgAEgAZQBiAHIAZQB3AEMAbwBwAHkAcgBpAGcAaAB0ACAAMgAwADIANAAgAFQAaABlACAATgBvAHQAbwAgAFAAcgBvAGoAZQBjAHQAIABBAHUAdABoAG8AcgBzACAAKABoAHQAdABwAHMAOgAvAC8AZwBpAHQAaAB1AGIALgBjAG8AbQAvAG4AbwB0AG8AZgBvAG4AdABzAC8AaABlAGIAcgBlAHcAKQAAAfQAMgEEAAAAAAAAAngAJAJ4ACQCgwATAngAJAJ4ACQCOQAwAAAANwJRACYCRgAiAjwAKQI8ACkCNQApAAAANwIeACYCHgAmAAAANwAAADIAAAA3AiEAKwIhACsCrAAxAUkALAJsADACbAAwAhEAHAMaACEAugASAAAAMgAAADIBbQASAAAAMgF2ABcBdgAXAAAANAAAADQAAAA0AAAANgAAADcAAAA9AnMANQJzADUClgAsAAAANwAAADcAAAA3AUEAIQFBACEAAAA4AAAAMgIDAC0CAwAtAgMALQIKACICCgAiAAAANwAAADIBRAAiAAAAMgKUAC8ClAAvAAAAMgAAADIAAAAyAQoAAAF7ADABewAwAY0ATwAAADICDQDlAAAAMgAAADQAAAA3AlkANQJZADUCWQA1AAAAMgAAADQAAAA0AAAAMgJzAEACcwBAAAAANwAAADQCCwAoAgsAKAAAADUCgwAsAoMALAAAADcAAAA1AAAAMgMYAFQAAAA2AtoAQALaAEAC2gBAAtoAQAAAADcC2gBAAtoAQAAAADQAAAA3APYARQEOAAACrQAjAq0AIwAAADIAAAAyAnoAOQJ6ADkAAAAzAAAAMgIsACsCLAArAAAANgAA/+4AAP+VAAD/7gAA/y4CUgAwAAAANwEtACYBLQALAS0AJgJNACYCWgAmAvkAJgKiACEDHwAvAqcAHQKEAAgCpgAnA0wAJgAAADcAAAAyAScAJgEnABABMgAmAlcAJgJkACYAAAAyAAAANQAAADIBSgAqAUr/9gAAADIAAAAAAnkAJgJ5AAADQP/+AnkAAAJ5AAACeQAAAnkAAAJ5AAACeQAAAnkAAAJ5AAACeQAAAnwAXQJzADsCcwA7AnMAOwJzADsCcwA7AsQAXQLEAF0CxAAQAiYAXQImAF0CJgBdAiYAXQImAF0CJgBdAiYAXQImAF0CJgBdAsQAEAH+AF0C2AA7AtgAOwLYADsC2AA7AsUAWwLZAF0C3wAAAVYAMwFWADMBVgAKAVYAFwFWADMBVgAzAVYAGgFWADMBFP+lAl4AXQJeAF0CFwBdAhcASAIXAF0CFwBdAiEAAQN2AF0C7QBdAu0AXQLtAF0C7QBdAu0AXQMCADsDmQA7AwIAOwMCADsDAgA7AwIAOwMCADsDAgA7AwIAOwJTAF0DAgA7AmcAXQJnAF0CZwBdAiwANAIsADQCLAA0AiwANAIsADQCGQALAhkACwIZAAsCUQBdAtkAVwLZAFcC2QBXAtkAVwLZAFcC2QBXAtkAVwLZAFcC2QBXAmQAAAOlABoDpQAaA6UAGgOlABoDpQAaAk3//wI1AAACNQAAAjUAAAI1AAACNQAAAk4AIgJOACICTgAiAk4AIgIpACwCKQAsAikALAIpACwBOAAoAAD+6wIpACwDcgAsAikALAIpACwC4gA1AikALAIpACwCKQAaAkAANAIiAC8DdQAwAikALAJeAFABbwAJAg0A5QF1ABwBdQAjAT0ATAE9ABgBfQAoAAD/aQF+AGIB8QA1AfEANQGUACgAAP9cAfEANQHxADUB8QA1AOUADwAA/5QCQABNAZQAKAAA/1MA9gBFAOYAIgAA/8QDPQAwAl4ANQJeADUCZAA1AaoAOAJJAJMAAP9rAkAAMwI9ADIAvQAoAAD/ygI5ADUCOQA1AjkANQI5ADUCOQA1AjkANQI5ADUCQAA0AukARQI5ADUD6AAnAfQAJwI5ADUCQAAzAksANAJAACYA+ABFAPgARgFGAA8CQABAAkAAFgJeADUCXgA1Al4ANQJeADUCdABQATgAKAAA/hgCQAA0AfMAHgHzAB4BIAAeASAAHgJhAFECZQAKAcoAKAAA/4IA+wBIAPsAPgD7/90A+//qAPsAUQD7AAoA+//sAPsAEgD7/84A+//OAhMAUQITAFEA+wBSAPsAPQD7AFIA+wBBAkAANAEeAAEDjABRAAD/bQFBACECQABGAmEAUQJhAFECYQBRAmEAUQJAAC4CYQBRAowAGAJWADUCVgA1AlYANQJWADUDzAA1APUAKAAA/60CVgA1AlYANQJAAE8BXgAjAW8AIAJhADUCVgA1AfT//QJeAFICiwBOASYAKAEmACEDUwAsAPYARQD2AEUCQAAzAl4AMwHAABgBwAAhAY0ARAGsACEBYQASAWEAEQCtABIArQARAPIAIQDZAEQBmgBSAZoAUgGaADIDPQAwATAAKAAA/4wB4AApAeAAKQHgACkB4AApAeAAKQH/AD4A+QAiAkAAMwJAADcBbwAKAkAALQF0ABABdAAQAXQAEAJeAFICQAAqAbUAKAAA/gQC0AAGAkAAMAJhAEwCYQBMAmEATAJhAEwCYQBMAmEATAJhAEwBsP/+AmEATAJhAEwB8gAAAwEADwMBAA8DAQAPAwEADwMBAA8CGAASAfAAAAHwAAAB8AAAAfAAAAJAABEB8AAAAdsAIwHbACMB2wAjAdsAIwJAADQB6QC4AekAtwF1ACgAAgAAAAAAAP+cADIAAAAAAAAAAAAAAAAAAAAAAAAAAAHWAAABAgEDAQQBBQEGAQcBCAEJAQoBCwEMAQ0BDgEPARABEQESARMBFAEVARYBFwEYARkBGgEbARwBHQEeAR8BIAEhASIBIwEkASUBJgEnASgBKQEqASsBLAEtAS4BLwEwABABMQEyATMBNAE1ATYBNwE4ATkBOgE7ATwBPQE+AT8BQAFBAUIBQwFEAUUBRgFHAUgBSQFKAUsBTAFNAU4BTwFQAVEBUgFTAVQBVQFWAVcBWAFZAVoBWwFcAV0BXgFfAWABYQFiAWMBZAFlAWYBZwFoAWkAAwFqAWsBbAFtAW4BbwFwAXEBcgFzAXQBdQF2AXcBeAF5AXoBewF8AX0BfgF/AYABgQGCAYMBhAGFAYYBhwGIAYkBigGLAYwBjQGOAY8BkAGRAZIBkwGUAZUAJACQAMkBlgDHAGIArQGXAZgAYwCuACUAJgD9AP8AZAGZACcBmgGbACgAZQGcAMgAygGdAMsBngGfAOkAKQAqAPgBoAGhAaIAKwGjACwAzADNAM4A+gDPAaQBpQAtAC4BpgAvAacBqAGpAOIAMAAxAaoBqwGsAGYAMgCwANAA0QBnANMBrQCRAK8AMwA0ADUBrgGvADYBsADkAPsBsQA3AbIBswDtADgA1ADVAGgA1gG0AbUBtgG3ADkAOgG4AbkBugG7ADsAPADrAbwAuwG9AD0BvgDmAb8ARABpAcAAawCNAcEAbACgAGoBwgAJAcMAbgBBAGEADQAjAG0ARQA/AF8AXgBgAD4AQADbAcQAhwBGAP4A4QHFAQAAbwHGAN4BxwCEANgByAAdAA8ByQCLAEcBygEBAIMAjgHLALgABwDcAcwASABwAc0AcgBzAc4AcQAbAKsBzwCzALIB0AAgAOoB0QAEAKMASQAYABcASgD5AdIB0wCJAEMB1AAhAKkAqgC+AL8ASwHVAN8B1gBMAHQAdgB3ANcAdQHXAdgATQHZAE4B2gBPAdsB3AHdAB8A4wBQAd4A7wDwAFEB3wHgAeEAHAB4AAYAUgB5AHsAfACxAOAB4gB6AeMAFACdAJ4AoQB9AeQAUwCIAAsADAAIABEAwwAOAFQAIgCiAAUAxQC0ALUAtgC3AMQACgBVAeUB5gCKAN0B5wBWAegA5QD8AekAhgAeABoAGQASAIUAVwHqAesA7gAWANkB7ACMABUAWAB+AIAAgQB/Ae0B7gBCAe8B8ABZAFoB8QHyAfMB9ABbAFwA7AH1ALoAlgH2AF0B9wDnAfgAEwH5AfoB+wJDUgROVUxMB3VuaTA1RDAHdW5pRkIzMAd1bmlGQjRGB3VuaUZCMkUHdW5pRkIyRgd1bmlGQjI5B3VuaTA1QTIHdW5pMDVFMgd1bmlGQjIwB3VuaTA1RDEHdW5pRkIzMQd1bmlGQjRDB3VuaTA1QkMHdW5pMDVEMwd1bmlGQjMzB3VuaTA1QTcHdW5pMDVBRAd1bmkwNTkxB3VuaTA1REEHdW5pRkIzQQd1bmkwNUREB3VuaTA1REYHdW5pMDVFMwd1bmlGQjQzB3VuaTA1RTUHdW5pRkIyNgd1bmkwNUYzB3VuaTA1OUMHdW5pMDU5RAd1bmkwNUY0B3VuaTA1OUUHdW5pMDVEMgd1bmlGQjMyB3VuaTA1QjIPdW5pMDVCMjIwMEQwNUJEB3VuaTA1QjMPdW5pMDVCMzIwMEQwNUJEB3VuaTA1QjEPdW5pMDVCMTIwMEQwNUJEB3VuaTA1RDQHdW5pRkIzNAd1bmkwNUQ3B3VuaTA1QjQHdW5pMDVCOQd1bmkwNUJBB3VuaTIwMTAHdW5pMDVBQwd1bmlGQjFFB3VuaTA1REIHdW5pRkIzQgd1bmlGQjREB3VuaTA1REMHdW5pRkIzQwd1bmkwNUM1B3VuaTA1QTQHdW5pMDVCRQd1bmkwNUFGB3VuaTA1REUHdW5pRkIzRQd1bmkwNUE2B3VuaTA1QTUHdW5pMDVBMwd1bmkwMEEwB3VuaTA1RTAHdW5pRkI0MAd1bmkwNUM2B3VuaTA1QUIHdW5pMDVDMAd1bmkwNTk5B3VuaTA1QjcHdW5pMDVBMQd1bmkwNUU0B3VuaUZCNDQHdW5pRkI0RQd1bmkwNUE4B3VuaTA1QjgHdW5pMDVDNwd1bmkwNTlGB3VuaTA1RTcHdW5pRkI0Nwd1bmkwNUJCB3VuaTA1QkYHdW5pMDVFOAd1bmlGQjQ4B3VuaTA1OTcHdW5pMDVFMQd1bmlGQjQxB3VuaTA1QjYHdW5pMDU5Mgd1bmkwNTkzB3VuaTIwQUEHdW5pMDVCMAd1bmkwNUU5B3VuaUZCNDkHdW5pRkIyQwd1bmlGQjJEB3VuaTA1QzEHdW5pRkIyQQd1bmlGQjJCB3VuaTA1QkQHdW5pMDVDMgd1bmkwNUMzB3VuaTA1RUEHdW5pRkI0QQd1bmkwNUEwB3VuaTA1QTkHdW5pMDVEOAd1bmlGQjM4B3VuaTA1OUIHdW5pMDU5Ngd1bmkwNUU2B3VuaUZCNDYHdW5pMDVCNQd1bmkyMDBDB3VuaTIwMEQHdW5pMjAwRQd1bmkyMDBGB3VuaTI1Q0MHdW5pMDVDNAd1bmkwNUQ1B3VuaUZCMzUHdW5pRkI0Qgd1bmkwNUYwB3VuaTA1RjEHdW5pRkIyMQd1bmlGQjIyB3VuaUZCMjMHdW5pRkIyNAd1bmlGQjI1B3VuaUZCMjcHdW5pRkIyOAd1bmkwNUFBB3VuaTA1OUEHdW5pMDVEOQd1bmlGQjM5B3VuaUZCMUQHdW5pMDVGMgd1bmlGQjFGB3VuaTA1OTUHdW5pMDU5NAd1bmkwNTk4B3VuaTA1RDYHdW5pRkIzNgd1bmkwNUFFB3VuaTAzNEYLeW9keW9keW9kaGIGQWJyZXZlB0FtYWNyb24HQW9nb25lawpDZG90YWNjZW50BkRjYXJvbgZEY3JvYXQGRWNhcm9uCkVkb3RhY2NlbnQHRW1hY3JvbgdFb2dvbmVrB3VuaTAxMjIKR2RvdGFjY2VudAd1bmkxRTlFBEhiYXIHSW1hY3JvbgdJb2dvbmVrB3VuaTAxMzYGTGFjdXRlBkxjYXJvbgd1bmkwMTNCBk5hY3V0ZQZOY2Fyb24HdW5pMDE0NQ1PaHVuZ2FydW1sYXV0BlJhY3V0ZQZSY2Fyb24GU2FjdXRlB3VuaTAyMTgGVGNhcm9uB3VuaTAyMUENVWh1bmdhcnVtbGF1dAdVbWFjcm9uB1VvZ29uZWsFVXJpbmcGV2FjdXRlC1djaXJjdW1mbGV4CVdkaWVyZXNpcwZXZ3JhdmULWWNpcmN1bWZsZXgGWWdyYXZlBlphY3V0ZQpaZG90YWNjZW50BmFicmV2ZQlhY3V0ZWNvbWIHYW1hY3Jvbgdhb2dvbmVrB3VuaTAzMDYHdW5pMDMwQwpjZG90YWNjZW50B3VuaTAzMjcHdW5pMDMwMgd1bmkwMzI2BmRjYXJvbgd1bmkwMzA4B3VuaTAzMDcGZWNhcm9uCmVkb3RhY2NlbnQHZW1hY3Jvbgdlb2dvbmVrBEV1cm8HdW5pMDEyMwpnZG90YWNjZW50CWdyYXZlY29tYgRoYmFyB3VuaTAzMEIHaW1hY3Jvbgdpb2dvbmVrB3VuaTAyMzcHdW5pMDEzNwZsYWN1dGUGbGNhcm9uB3VuaTAxM0MHdW5pMDMwNAZuYWN1dGUGbmNhcm9uB3VuaTAxNDYHdW5pMDMyOA1vaHVuZ2FydW1sYXV0CW92ZXJzY29yZQZyYWN1dGUGcmNhcm9uB3VuaTAzMEEGc2FjdXRlB3VuaTAyMTkGdGNhcm9uB3VuaTAyMUIJdGlsZGVjb21iDXVodW5nYXJ1bWxhdXQHdW1hY3Jvbgd1b2dvbmVrBXVyaW5nBndhY3V0ZQt3Y2lyY3VtZmxleAl3ZGllcmVzaXMGd2dyYXZlC3ljaXJjdW1mbGV4BnlncmF2ZQZ6YWN1dGUKemRvdGFjY2VudBBjYXJvbmNvbW1hYWNjZW50EWNvbW1hYWNjZW50cm90YXRlCW1hY3Jvbm1vZAAAAQAAAAoAWgCoAAVERkxUAEBjeXJsADBncmVrADBoZWJyACBsYXRuAEAABAAAAAD//wADAAIAAwAEAAQAAAAA//8AAwAAAAMABAAEAAAAAP//AAMAAQADAAQABWtlcm4ASGtlcm4AQGtlcm4AOG1hcmsAKG1rbWsAIAAAAAIACgALAAAABgAEAAUABgAHAAgACQAAAAIAAAACAAAAAgAAAAMAAAABAAAADC0iLRAo0h3yFz4VHA8aBigEtADYAJ4AGgAGABAAAQAKAAMAAQ68AGAAAQ3KAAwACwBOAEgAQgA8ADYASAAwACoAJAAeABgAAf62AuAAAf/9AzoAAf/+Ap4AAQBAAv4AAf6MAv4AAf//AtgAAf/1AvwAAf/+AvwAAQAAAuYAAf8sAv4AAQALAQgBHQEiASoBNAE4AVQBXQFxAaIBtAAGABAAAQAKAAIAAR0iACYAARx+AAwAAwAUAA4ACAABAAD/HgABAAH/IwAB//f/EAABAAMBJwEtAYEABAAAAAEACAABA84CwgABA8gADADHArACsAKwArACsAKwAqoCpAKkAqQCpAKkAqQCpAKkAqQCpAKeApgCmAKYApgCmAKSApICjAKMAowCjAKMAowCjAKMAowChgKAAoACgAKAAnoCdAJ0AnQCdAJ0AnQCdAJ0Am4CaAJoAmICYgJiAmICXAJWAlYCVgJWAlYCUAJQAlACUAJQAlACUAJKAlACRAJEAkQCPgI+Aj4CPgI+AjgCOAI4AnoCegJ6AnoCegJ6AnoCegJ6AjICLAIsAiwCLAIsAiYCIAIgAiACIAIgAhoCGgIaAhoCFAIUAhQCFAIUAhQCFAIUAhQCFAIOAggCCAIIAggCCAICAgIB/AH8AfwB/AH8AfwB/AH8AfwB9gHwAfAB8AHwAeoB5AHkAeQB3gHeAdgB2AHYAdgB0gHMAcwBzAHMAcwB8AHwAfAB8AHwAfAB8AHGAcABugG6AboBtAG0AbQBtAG0Aa4BrgGuAcwBzAHMAcwBzAHMAcwBzAHMAagBogGiAaIBogGiAZwBlgGWAZYBlgGWAZABkAGQAZAAAQHDAhkAAQHcAhkAAQIEAhkAAQLtAhkAAQHeAhkAAQEhA1UAAQHMAhkAAQGGAhkAAQJDAhkAAQJKAhkAAQJIAhkAAQNyAhkAAQDdAvgAAQGfA1UAAQDnAuYAAQI8AvgAAQJCAhkAAQFtAv0AAQIlAhkAAQJCAvgAAQHbAhkAAQIoAvgAAQIQAhkAAQI6AsoAAQIhAsoAAQI5AsoAAQORAsoAAQJQAsoAAQIFAsoAAQIYAsoAAQJTAsoAAQI/AsoAAQLuAsoAAQLZAsoAAQNiAsoAAQGfAsoAAQJKAsoAAQEAAsoAAQFCAsoAAQLFAsoAAQLEAsoAAQHqAsoAAQISAsoAAQKwAsoAAQJfAsoAAQJoAsoAAQJLAsoAAQIiAsoAAQJuAhkAAgArAGAAYwAAAGUAZgAEAHoAegAGAJcAlwAHAJkAqQAIAKsAswAZALUAuQAiALsAuwAnAL0AywAoAM0A0wA3ANUA2QA+ANsA6ABDAOoBBgBRAQkBCQBuAQsBDABvAQ4BDwBxARQBFQBzAR8BIAB1ASMBJQB3AS8BMAB6ATkBPwB8AUIBQgCDAUUBRQCEAUsBSwCFAU4BUQCGAVoBWgCKAV4BXgCLAWUBZgCMAWgBbQCOAXABcACUAXQBdwCVAXkBeQCZAXsBfgCaAYIBgwCeAYgBiACgAYoBigChAZIBkgCiAZ0BnwCjAaMBpwCmAa4BsACrAbcBvQCuAb8BywC1Ac0B0QDCAAEAAAnwAAEAAQBkAAQAAAABAAgAAQFWEYAAAQESAAwAQAEAAQABAAEAAPoA9ADuAO4A7gmsCawA6ADoAOIA3ADWANYA6ADQANAAygDKAMQAvgC+AL4AuAC4ALIAsgD0APQA3ADcANwA9AD0AKwArACmAKYAoACgAKAAoACgAKAAmgCaAPQA9ADWANYAlAdOB04HTgCOASwBLAEsAIgAggCCAAEAIwIZAAEAmAIZAAEAagIZAAEAMALKAAEATQIZAAEAbwIZAAEACwIZAAH/7wIZAAEATwIZAAH/0AIZAAEAAwIZAAEATgIZAAEAKQIZAAEAOAIZAAEADwIZAAEANAIZAAEAWQIZAAEABAIZAAEAIQIZAAEANQIZAAEAJgIZAAEAQQIZAAkAAAA+AAAIygAACMoAAAA4AAAAMgAAACwAAAAyAAAIygAAACYAAQCDAhkAAQCSAhkAAQChAhkAAQC0AhkAAQBGAhkAAQAJAB4ALgAvAEgATgBYAFwAaABuAAQAAAABAAgAAQiwBoIAAQe+AAwBGwZwBnAGcAZwBmoGZAZeBl4GXgZYBlgGUgZSBkwGRgZABkAGOgY0BjQGLgYuBigGIgYiBiIGHAYcBhYGFgYQBhAGCgYKBgoGBAYEBf4F/gX4BfgF8gXyBfIF8gXyBfIF7AXsBeYF5gYKBgoF4AXaBdoF2gXUBdoF2gXaBc4FyAXIBcIFvAW2BbAFqgWkBbYFngWYBZIFjAWGBYAFegV0BYAFbgVoBWIFaAVcBVYFUAVQBUoFRAVWBT4FXAVoBTgFMgUsBTIFJgUgBRoFFAUOBQgFAgT8BPYFCATwBQ4E6gTkBOQE3gTYBN4E3gTeBNIEzATGBMAEzAS6BLQErgSoBKIEnASoBKgElgSQBIoEtASEBH4EeARyBGwEZgRyBHIEYARaBGAF4ARUBE4ESARCBE4ETgQ8BFQENgQwBCoEJAQeBBgEJAU4BBIEDAQGBAAEDAVcBVYFUAVEA/oD9APuA+gD4gPcA/QD1gP6A9ADygPEA74DuAOyA74DrAOmA6YDxAOgA5oDlAOUA44DiAOaA4IDoAN8A3YDcANqA2QDXgNYA1IDTANGA0ADOgM0Ay4DQAMoA0YDRgMuA1IDUgNSAyIDUgNSAxwDFgMQAwoDBAMQAv4DcAL4A2QC8gLsAvgC+ALmAuADEALaAtQCzgLIAsICvAK2ArACqgK2ArYCpAKeAqQCmAMQAwoDBAKSAwoDCgKMAxAChgKAAnoCdAJuAmgCdAJiAoACXAJWAlACXAJKAkQCPgI4AAEA7gLmAAEA7gL8AAEA7gL+AAEA7gIZAAEA+ALbAAEA+AL8AAEA+AL+AAEBDAIZAAEBgQLbAAEBgQL8AAEBgQL+AAEBgQIZAAEA+AIZAAEBMQM6AAEBMQKdAAEBMQLbAAEBLwL4AAEAlgL4AAEAlgKVAAEA7QL8AAEA7QL+AAEA7QIZAAEA1AL8AAEA1AL+AAEA1AIZAAEBLwIZAAEBMgIZAAEBLALhAAEAvALVAAEArQLVAAEB5gIZAAEBLALbAAEBLAL+AAEBMQLhAAEBMQL8AAEBMQL+AAEBMQIZAAEBzQIZAAEAjwL4AAEAfgPdAAEAfgKdAAEAfgIZAAEAfgLbAAEAfgL8AAEAfgL+AAEAfgLmAAEA8QL4AAEAfgL4AAEBOgL9AAEBLALmAAEBLAL8AAEBLALoAAEBLAIZAAEA7wL9AAEBJgL6AAEBHQKdAAEBHQLmAAEBHQLbAAEBHQL8AAEBHQL+AAEBHQIZAAEBDgL4AAEBLQLmAAEBLQL8AAEBLQL+AAEBLQIZAAEBMgL4AAEBFQLhAAEBFQM6AAEBFQKdAAEBvgIZAAEBFQLbAAEBFQL8AAEBFQLoAAEBFQL+AAEBFQIZAAEBGwOLAAEBGwOtAAEBGwOvAAEBGwLKAAEB0wOLAAEB0wOtAAEB0wOvAAEB0wLKAAEBMgLKAAEBbQPrAAEBbQNOAAEBbQOLAAEBbQOtAAEBbQOvAAEBbQLKAAEBDQOtAAEBDQLKAAEBFgOtAAEBFgOvAAEBFgLKAAEBNAOtAAEBNAOvAAEBNALKAAEBLQLKAAEBgQOSAAEBggLKAAEBgQOLAAEBgQOtAAEBgQOvAAEBzQLKAAEBgQLKAAEBdwOSAAEBdwOtAAEBdwOvAAEBdwLKAAEBvQLKAAEAiAOvAAEAiALKAAEBNwLKAAEAjALKAAEAqwNOAAEAqwOWAAEAqwOLAAEAqwOtAAEAqwOvAAEAqwLKAAEBbwLKAAEBbALKAAEBYwLKAAEBlwOWAAEBlwOZAAEBlwLKAAEBJQLKAAEBKwNOAAEBKwOWAAEBKwOLAAEBKwOtAAEBKwOvAAEBKwLKAAEBYgOtAAEBYgLKAAEBewOWAAEBewOtAAEBewOvAAEBewLKAAEBPwLKAAEBPQOSAAEBPQN7AAEBPQLMAAEBPQNOAAEBPQOLAAEBPQOtAAEBPQOZAAEBPQOvAAEBtQLKAAEBPQLKAAEAqAIZAAEBMwIZAAEAgQIZAAEArwIZAAEBKQLKAAEBDQIZAAEBXwITAAEBbQIZAAEBTQIZAAEAyQIZAAEBNgIZAAEBEgIZAAEApwIZAAEBbwIZAAEBGwIZAAEArAIZAAEBUQIZAAEBKAIZAAEAsQIZAAEA9wIZAAEBBQIZAAEApAIZAAEBXQIZAAEAzQIZAAEBAAIZAAEA4gIZAAEBOwIZAAEBMAIZAAEBQAIZAAIANAADAAQAAAAGAAcAAgAKAA4ABAAQABEACQAVABsACwAiACMAEgAqACwAFAA0ADgAFwA9AD4AHABDAEQAHgBLAE0AIABSAFMAIwBWAFcAJQBZAFoAJwBgAGMAKQBlAGYALQBrAGwALwBvAHAAMQBzAHQAMwB6AHoANQB8AH8ANgCKAI0AOgCSAJMAPgCXAQYAQAEJAQwAsAEOAQ8AtAEUARUAtgEfASAAuAEjASUAugEvATEAvQE5AT8AwAFCAUIAxwFFAUUAyAFHAUcAyQFLAUsAygFOAVIAywFaAVsA0AFeAW0A0gFvAXAA4gF0AXcA5AF5AXkA6AF7AX8A6QGCAYMA7gGFAYgA8AGKAYoA9AGSAZIA9QGdAZ8A9gGjAacA+QGuAbEA/gG3Ab0BAgG/AcsBCQHNAdEBFgAbAAAA7AAAAOYAAADgAAAA2gAAANQAAADOAAAAyAAAAMIAAAC8AAAAtgAAALAAAACqAAAApAAAAKoAAADaAAAA2gAAAJ4AAACYAAAAkgAAAIwAAACGAAAAmAAAAIAAAAB6AAAAdAAAAJIAAABuAAH+tgIZAAH//gIZAAEAQAIZAAH+jAIZAAH//wIZAAH/9QIZAAH//QIZAAEAAAIZAAH/LAIZAAEAdgIZAAEAUwIZAAEAiAIZAAEAawIZAAEAlgIZAAEA6wIZAAEAegIZAAEAcQIZAAEAfAIZAAEAoAIZAAEAgAIZAAEAiQIZAAEAhgIZAAEAGwAfACEAMgAzADwARgBKAFEAVQBdAG0AewCPAJAAkQCUAQgBHQEiASoBNAE4AVQBXQFxAaIBtAAEAAAAAQAIAAEF9ASmAAEF6AAMARoElASUBJQElASOBIgEiASIBIIEggR8BHwEdgRwBGoEagRkBF4EXgRYBFgEUgRMBEwETARGBEYEQARABDoEOgQ0BDQENAQuBC4EKAQoBCIEIgQcBBwEHAQcBBwEHAQWBBYEEAQQBAoECgQEA/4D/gP+A/gD8gPyA/ID7APmA+YD4APaA+AD4APgA+AD4APgA+AD4APgA9QDzgPOA84DzgPOA8gDyAPCA7wDvAO8A7wDvAO8A7wDvAO8A8IDvAO2A7YDtgO2A7ADqgOkA54DngOeA54DngOeA54DngOYA5IDkgOMA4wDjAOMA4YDgAN6A3oDegN6A3oDdANuA3QDdAN0A3QDdANoA3QDYgNcA1YDVgNWA1ADUANQA1ADUANKA0oDSgNEAz4DPgM+Az4DPgM+Az4DPgM+AzgDMgMyAzIDMgMyAywDJgMmAyYDJgMmAyADIAMgAyADGgMaAxoDGgMaAxQDGgMaAxoDGgMaAw4DCAMIAwgDCAMIAwIDAgL8AvYC9gL2AvYC9gL2AvYC9gL2AvAC6gLkAuQC5ALkAt4C2ALSAswCxgLGAsYCxgLGAsYCzALAAroCtAK0Aq4CrgKuAq4CqAKiApwCnAKcApwCnAKWApYClgKWApAClgKWAooChAJ+ApYCeAJyAmwCbAJsAmYCZgJmAmYCZgJgAmACYAJaAlQCVAJUAlQCVAJUAlQCVAJUAk4CSAJIAkgCSAJIAkICPAI8AjwCPAI8AjYCNgI2AjYAAQDtAQ0AAQD3AJMAAQEKAQ0AAQGAAQwAAQD5AQ0AAQEtAQgAAQE9AQcAAQC6AQ0AAQDuAQ0AAQDvAREAAQEfAJwAAQE9AJwAAQEsAQoAAQC4AigAAQCoAigAAQHlAQ0AAQEsAQ0AAQEzARIAAQHJARIAAQCTAXwAAQB+AQ0AAQEzAXwAAQA7AJUAAQBBAPsAAQB9AQ0AAQB+AXMAAQERAXwAAQExAQ0AAQFMAXkAAQEgAJoAAQDEAX4AAQEjAXcAAQEcAQ0AAQFGAXcAAQEvAQ0AAQEFAQ0AAQE8AXcAAQGzAQ0AAQEEAQwAAQEnAWUAAQEaAWUAAQEmAWUAAQHTAWUAAQEyAWUAAQFsAWAAAQFAAWUAAQENAWUAAQEYAWUAAQFcAWUAAQGEARUAAQE/AWUAAQGAAWMAAQHNAWUAAQGBAWUAAQF2AWUAAQG6AWUAAQEDAWUAAQELAWUAAQFeAWUAAQAvAQUAAQCrAWUAAQFvAWUAAQFsAWUAAQF+AWUAAQFjAWYAAQElAWUAAQFMAWUAAQFiAWUAAQFHAWUAAQFSAWUAAQGRAWUAAQE8AWYAAQARASwAAQE5AY4AAQAsAY4AAf//ASwAAQAmASwAAQEpASMAAQCOAMwAAQE8ATgAAQF3ASUAAQG9AOUAAQFKASwAAQC0ASwAAQEaATMAAQFUASIAAQBpASwAAQFjASwAAQCIAUQAAQC3ASwAAQFSASwAAQEoASwAAQBsATgAAQEAAcYAAQFUARIAAQBgASwAAQFdASkAAQDFASwAAQCiASwAAQDQASwAAQFGAWIAAQEaAHIAAgA1AAMABAAAAAYABwACAAoACgAEAAwADgAFABAAEQAIABUAGwAKACIAIwARACoALAATADQAOAAWAD0APgAbAEMARAAdAEsATQAfAFIAUwAiAFYAVwAkAFkAWgAmAGAAYwAoAGUAZgAsAGsAbAAuAG8AcAAwAHMAdAAyAHoAegA0AHwAfwA1AIoAjQA5AJIAkwA9AJcBBgA/AQkBDACvAQ4BDwCzARQBFQC1AR8BIAC3ASMBJQC5AS8BMQC8ATkBPwC/AUIBQgDGAUUBRQDHAUcBRwDIAUsBSwDJAU4BUgDKAVoBWwDPAV4BbQDRAW8BcADhAXQBdwDjAXkBeQDnAXsBfwDoAYIBgwDtAYUBiADvAYoBigDzAZIBkgD0AZ0BnwD1AaMBpwD4Aa4BsQD9AbcBvQEBAb8BywEIAc0B0QEVAAEAAAAGAAEAUgEsAAEAAQAPAAQAAAABAAgAAQH8ARgAAQGcAAwAQBfaF9oX2hfaAQYBAAD6APoA+gD0APQA7gDuAOgA4gDcANwA1gDQANAAygDKAMQBBgEGAQYB2AHYAL4AvgC4ALgAsgCyALIArACsAdIB0gCmAKYAoACgAKAAoACgAKAAmgCaAJQAlACsAKwAjgCIAIgAiADuAI4AjgCOAI4AggCCAAEACgAAAAEAUAAAAAEAMAAAAAEABgAAAAEAKQAAAAEAhAAAAAEANwAAAAEABAAAAAEANAAAAAH//QAAAAEAZAAAAAEATgAAAAEAKwAAAAEADgAAAAEADAAAAAEAFAAAAAEAOAAAAAEAWQAAAAEACAAAAAEAbAAAAAEAIQAAAAEAEAAAAAEAAwAAAAEAQAADAAQABgAHAAoACwAMAA0ADgAQABEAFQAWABcAGAAZABoAGwAiACMAKgArACwANAA1ADYANwA4AD0APgBDAEQASwBMAE0AUgBTAFYAVwBZAFoAYABhAGIAYwBlAGYAawBsAG8AcABzAHQAegB8AH0AfgB/AIoAiwCMAI0AkgCTAA0AAANiAAAAWgAAAFQAAANcAAAATgAAAEgAAABCAAAAPAAAADYAAATKAAAAVAAAA2IAAABOAAEASAAAAAEAxAAAAAEAtAAAAAEA4AAAAAEAcQAAAAEARgAAAAEAsAAAAAEADQAJABIAEwAUADoAPwBAAEEAZwBxAHIAiACJAAQAAAABAAgAAQaEBJ4AAQXgAAwBGQSMBIwEjASMBIYEgAR6BHoEegR0BHQEbgRuBGgEYgRiBFwEXARWBFYEUARKBEoESgREBEQEPgQ+BDgEOAQyBDIEMgQsBCwEJgQmBCAEIAR0BHQEdAR0BHQEdAQaBBoEFAQUBA4EDgQIBAIEAgQCBAgD/AP8A/wD9gPwA/AD6gPkA+oD6gPqA+oD6gPqA94D6gPqA9gD0gPSA9IDzAPSA8YDxgPAA7oDugO6A7oDugO6A7oDugO0A8ADrgOoA6gDogOoBD4DnAR0A5YDlgOWA5YDlgOWA5YDkAOKA4QDfgN4A3gDeANyA3gDbAQaBBoEGgNmBBoDYANaA2ADYANgA2ADYANgA2AEVgNUA04DTgNOBDIEMgQyA0gDQgM8AzwDNgQIA5wDnAOcA5wDnAOcA5wDMAOcAyoDJAMkAyQDJAMkA7oEhgSGBIYEhgSGAx4DHgMeAx4DGAMYAxgDGAMYAxIDGAMYAwwDGAMYBIwDBgMGAwYDAAMGAvoC+gL0Au4C7gLuAu4C7gLuAu4C7gLoAu4C4gLcAtwC3ALcAtYEjASMAtACygLKAsoCygLKAsoCxAK+Ar4CuAKyAsoCygLKAqwCpgKgAyoDKgMqApoDKgMeAx4DHgMeApQDHgMeAo4CiAMqAx4CggJ8AtAC0ALQAnYCdgJ2AnACagJkAmQCXgJYAwYDBgMGAwYDBgMGAwYCUgMGAkwCRgJGAkYCRgJGAkACOgI6AjoCOgI6AjQCNAI0AjQAAQDuAAAAAQBT/w4AAQEMAAAAAQGAAAAAAQD6AAAAAQEv/x4AAQEv/xUAAQDa/yMAAQDaAAAAAQDt/yMAAQDt/xAAAQDtAAAAAQHf/xUAAQB+/xUAAQC3AX4AAQCnAYAAAQHmAAAAAQEx/yMAAQHKAAAAAQCPAAAAAQB+/yMAAQEK/yMAAQEKAAAAAQAa/xAAAQB//x4AAQB+AAAAAQB/AAAAAQE6AAAAAQEk/xAAAQCWAAAAAQEm/x4AAQEmAAAAAQEyAAAAAQEsAAAAAQEv/xAAAQEvAAAAAQEV/x4AAQG5AAAAAQEVAAAAAQErAAAAAQHTAAAAAQExAAAAAQFs/x4AAQEN/yMAAQENAAAAAQEW/yMAAQEW/xAAAQE+AAAAAQGB/1YAAQHNAAAAAQGBAAAAAQF3/yMAAQG6AAAAAQEl/yMAAQElAAAAAQE1/yMAAQE1AAAAAf/8/00AAQCr/x4AAQCrAAAAAQFsAAAAAQGJ/yMAAQGJAAAAAQD/AAAAAQEn/x4AAQEnAAAAAQFiAAAAAQFfAAAAAQF0/xAAAQF0AAAAAQE/AAAAAQE9/x4AAQGgAAAAAQE9AAAAAQCsAAAAAQE5AAAAAQCpAAAAAQCuAAAAAQEpAAAAAQDzAAAAAQE7//0AAQF3AAAAAQFKAAAAAQGSAAAAAQF1AAAAAQEWAAAAAQCoAAAAAQFjAAAAAQD0AAAAAQC2AAAAAQFSAAAAAQEqAAAAAQDMAAAAAQFRAN4AAQFdAAAAAQDFAOIAAQFvAAAAAQESAAAAAQEjAAAAAQEbAAAAAQEzAAAAAgA1AAMABAAAAAYABwACAAoADgAEABAAEQAJABUAFwALABkAGgAOACIAIwAQACoALAASADQAOAAVAD0APgAaAEMARAAcAEsATQAeAFIAUwAhAFYAVwAjAFkAWgAlAGAAYwAnAGUAZgArAGsAbAAtAG8AcAAvAHMAdAAxAHoAegAzAHwAfwA0AIoAjQA4AJIAkwA8AJcBBgA+AQkBDACuAQ4BDwCyARQBFQC0AR8BIAC2ASMBJQC4AS8BMQC7ATkBPwC+AUIBQgDFAUUBRQDGAUcBRwDHAUsBSwDIAU4BUgDJAVoBWwDOAV4BbQDQAW8BcADgAXQBdwDiAXkBeQDmAXsBfwDnAYIBgwDsAYUBiADuAYoBigDyAZIBkgDzAZ0BnwD0AaMBpwD3Aa4BsQD8AbcBvQEAAb8BywEHAc0B0QEUABIAAACeAAAAmAAAAJ4AAACSAAAAjAAAAIYAAACAAAAAgAAAAHoAAAB6AAAAdAAAAG4AAABoAAAAYgAAAFwAAABWAAAAUAAAAEoAAf//AAAAAQAAAAAAAf/3AAAAAQCGAAAAAQBSAAAAAQCJAAAAAQCfAAAAAQBzAAAAAQCMAAAAAQBTAAAAAQDkAAAAAQC7AAAAAQDlAAAAAQDjAAAAAQC9AAAAAQASACQAJQAmACcAKAApAC0AOQBJAE8AUABUAFsAXwB1AScBLQGBAAIACAADCrgIGAAMAAIEjgAEAAAG1gVeABkAFwAAAAAAAAAA/+wAAAAAAAAAAAAAAAAAAAAAAAD/9gAA//YAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//YAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/sAAAAAAAA//b/9v/Y//YAAAAAAAAAAP/iAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/2AAAAAAAKAAAAAAAAAAAAAAAAAAAAAAAAAAA/+wAAAAAAAAAAAAAAAD/2P/EAAAAAAAA/7oAAAAA/7oAAAAAAAAAAAAAAAAAAAAAAAAAAP/2AAAAAAAAAAAAAP/sAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/+z/9v/2AAD/2P/sAAAAAAAAAAD/zgAA//YAAP/2AAAAAAAAAAD/4v/2AAAAAP/EAAD/4gAA/7r/2AAAAAAAFAAKAAAAAP/iAAD/4gAAABQAAAAAAAAAAP+wAAAAAP/sAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/sAAAAAAAAAAD/7AAAAAAAAAAA//YAAP/s/+IAAAAAAAD/sAAAAAD/7AAAAAAAAAAAAAAAAP/O/+z/4gAA/8T/zgAAAAAAAAAA/8QAAP/OAAD/2P/sAAAAAAAA/7D/4gAAAAAAAP/2AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/sAAAAAAAAAAD/zgAAAAAAAAAA/+wAAP/E/8QAAAAAAAAAAAAAAAD/ugAAAAAAAAAAAAAAAAAA/+wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/+wAAAAAAAD/uv/s/87/7P+6/7AAAAAAAAAAAP/EAAD/ugAA/8T/2AAUAAD/2P/E/+IAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/2AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMgAAAAAAAAAAAAD/7AAAAAAAAAAA/+wAAAAAAAAAAP9gAAD/9gAoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/84AAAAAAAAAAAAA/37/9gAAAAAAAAAAAAAAAAAA/+wAAP/iAAAAAAAAAAAAAAAAAAAAAAAeAAAAAAAAAAAAAAAoAAAAAAAAAEYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/2/+IAAAAAAAAAAAAAAAD/4gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/4v+wAAAAAAAAAAAAAAAA/8QAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/sAAAAAAA8AAAAAAAAACgAAAAAAAAAAAAA/+wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAiADAAMAAAAJcAlwABAJkAoQACAKMAqgALALQAtAATAMYAzAAUANMA0wAbANUA3QAcAOYBBgAlAQkBDABGAQ4BDwBKARQBFQBMASwBLABOATABMABPATkBPwBQAUIBRQBXAUcBRwBbAUsBSwBcAVYBWgBdAWABYQBiAWQBZABkAWwBbABlAXABcABmAXQBdQBnAXcBdwBpAXsBfwBqAYIBgwBvAYcBiABxAYoBigBzAY8BjwB0AZUBnwB1Aa4BsQCAAcEBywCEAc0BzQCPAAIAPgAwADAAEwCXAJcABQCYAJgAFgCZAKEABQCjAKcAAgC2ALkAAgDTANsAAgDdAN0AAgDmAOgAEQDqAPIABwDzAPgACQD6AP4ACgD/AQIADAEDAQYABgEJAQoABgELAQsAAQEMAQwABgEOAQ8ABgEUARQABgEVARUACAEZARkAEgEbARsAEgEfASAAAQEjASUAAQEsASwACwEvATEAAQE5AT8AAQFBAUEACwFCAUIAAQFDAUQAEwFFAUUAAQFOAVEADQFWAVYAFAFXAVcAFQFYAVgAFAFZAVkAFQFaAVoACAFoAW0ACAFwAXAAAwF0AXUAAwF3AXcAAwF7AX8AAQGCAYMAAQGHAYgAAQGKAYoAAwGNAY0AEgGPAY8ACwGSAZIAAQGVAZUADgGWAZYACwGYAZgADgGaAZoADgGbAZsACwGcAZwADgGdAZ4AAwGjAaQADwGmAacADwGxAbEACAG3Ab0AAwG/AcAAAwHBAcsABAHOAdEAEAACADMAMAAwAA8AlwCXAAQAmQChAAQAowCnAAgAqACqAAIAtAC0AAIAxgDHAA0AyADMAAkA0wDTAAIA1QDbAAIA3ADcABMA3QDdAAIA5gDoAA4A6QDpABMA6gDyAAUA8wD4AAYA+QD5AA0A+gD+AAoA/wECAAsBAwEGAAEBCQEJAAEBCwEMAAEBDgEPAAEBFAEUAAEBLAEsAAwBMAEwABQBQwFEAA8BSwFLABcBVgFWABUBVwFXABYBWAFYABUBWQFZABYBWgFaAAEBYAFhABABZAFkABABbAFsABQBcAFwAAEBdAF1AAEBdwF3AAEBjwGPAAwBlQGVAAcBlgGWAAwBlwGaAAcBmwGbAAwBnAGcAAcBnQGfABEBrgGwABIBwQHGAAMBxwHHABgByAHLAAMBzQHNAAMAAQCiAAQAAABMApoClAKaApoCmgKaApoCmgKOApoCmgKIAogCiAKUApQClAKUApQClAKUApQClAKIAjoCmgKIApQCiAKIAogCiAKIAogCiAIwAogCJgIcAhwCHAIwAhYCFgIWAhYCFgIWAgwCDAIMAgwCDAHSAcgByAG2AawBbgKIAogBrAHIATABKgIWAhYCFgIWAhYCFgIWAhYCFgIWAhYAAgAWAJcAoQAAAKgAtQALAMQAxAAZANMA3gAaAOYA6QAmAPMA+AAqAPoA/gAwAQ0BDQA1ARgBGAA2ARoBGgA3AR8BHwA4ATABMAA5AUoBSgA6AVcBVwA7AVkBWQA8AWwBbAA9AYwBjAA+AZQBlAA/Ab4BvgBAAcEBxgBBAcgBywBHAc0BzQBLAAEAxQBfAA8AxQBkAOb/2ADn/9gA6P/YAPP/4gD0/+IA9f/iAPb/4gD3/+IA+P/iAPr/2AD7/9gA/P/YAP3/2AD+/9gADwDFADIA5v/sAOf/7ADo/+wA8//2APT/9gD1//YA9v/2APf/9gD4//YA+v/iAPv/4gD8/+IA/f/iAP7/4gACAVsARgGTAFAABAGVABQBmAAUAZoAFAGcABQAAgDFAFoBZgAoAA4A5v/EAOf/xADo/8QA8//sAPT/7AD1/+wA9v/sAPf/7AD4/+wA+v/iAPv/4gD8/+IA/f/iAP7/4gACAQ3/4gGTABQAAQGTABQAAgEN/+wBkwAUAAIBVv/2AVj/9gACAPn/7AEN//YAEwCX/+wAmf/sAJr/7ACb/+wAnP/sAJ3/7ACe/+wAn//sAKD/7ACh/+wBGQAUARsAFAEs/8QBQf/EAY0AFAGP/8QBkwAUAZb/xAGb/8QAAQD5/+wAAQDFAG4AAQDFADwAAQDFADIAAQAMAAQAAAABABIAAQABAKIABQEs//YBQf/2AY//9gGW//YBm//2AAIACAADBBwDtgAMAAEAMAAFAAAAEwOQA4IDYgMkAvgCzAKUAmgCTgIcAeoBxAGAAUIBEADMAKYAYgBaAAEAEwADAAoADAAQACIANAA3AD0AQwBLAFYAWQBgAGsAbwBzAHwAigCSAAEADP/t/+0ACwAM/8D/wAAX/+L/4gAq/+z/7AAs//n/+QA0//n/+QA9//n/+QBL/+n/6QBW/+z/7ABZ//n/+QBr/+z/7ABv//n/+QAGAAz/+v/6ABf/9v/2AEv/7P/sAFb/9f/1AFn/+f/5AG//8P/wAAsAA//0//QADP/n/+cAEP/t/+0AF//n/+cAGQAAAAAAKgAAAAAAPQAAAAAAS//m/+YAWf/g/+AAbwAAAAAAiv/s/+wACAAQ//T/9AAV/+3/7QAZ//X/9QAb/+3/7QA0//r/+gBL/+r/6gBS/+3/7QBW//T/9AAKAAr/2P/YABD/1P/UADT/7f/tADf//P/8AD3/3v/eAEv/5//nAFn/2P/YAGD/7P/sAIr/8v/yAJL/zv/OAAsADP/o/+gAFQAAAAAAF//5//kAGQAAAAAANP/o/+gAS//5//kAUgAAAAAAVv/5//kAWf/1//UAb//8//wAkgAAAAAABgAZ/+H/4QA3//z//ABL//T/9ABW//X/9QBZ//z//ABv//z//AAIAAz/2P/YABX/8f/xABn/4v/iADT/7f/tAD3/+f/5AEv/9f/1AFn/9f/1AGv/6v/qAAgAEAAAAAAAFf/5//kAGAAAAAAAGf/l/+UAN//5//kAS//8//wAWf/5//kAYP/5//kABAA0/+f/5wBZAAAAAABv//D/8ACK//L/8gAHABf/9P/0ADT/7P/sAD3/7P/sAEv/5P/kAFn/6v/qAGAAAAAAAG8AAAAAAAkADP/Y/9gAGf/b/9sAIv/8//wANP/m/+YAS//w//AAWf/t/+0AYAATABMAa//6//oAb//t/+0ABwAVAAAAAAAZ/+b/5gA0//T/9AA9//D/8ABL/+b/5gBZ//D/8ABv/+3/7QAHAAwABAAEADT/9P/0ADf/8P/wAD3/6v/qAEv/5//nAG//7f/tAIr/4P/gAAoAFf/O/84AF//n/+cAGf/O/84AKv/s/+wANP/c/9wAPf/0//QAS//c/9wAVv/c/9wAWf/g/+AAb//t/+0ABQAQ//T/9AAV/+3/7QBL/+D/4ABW/+f/5wBZ/+D/4AACAFn/5//nAG//+f/5AAQANP/6//oAN//6//oAS//s/+wAYP/s/+wAAQAYAAUAAAAHAFgAUABIAEAAMgBIACoAAQAHAAMAEAA3AEsAVgBZAG8AAQBv/+z/7AACAFb/7P/sAG//7P/sAAEANP/s/+wAAQAV/+L/4gABAAz/2P/YAAIAUv/2//YAiv/s/+wAAQAOAAQAAAACABwAFgABAAIAAwA9AAEAIgAAAAEAkgAAAAEAEAABAAoAAQABADAABAAyAAgAEAABAAoAAQADAAEALgABAB4AAQAUAAEAAAABAAEAAwEZARsBjQABAAYBHQEiASoBNAFxAbQAAQABAWIAAgAy/twBwgQsAAMABwAAUxEhESUhESEyAZD+ogEs/tT+3AVQ+rAyBOwAAwAkAAACVAJRABIAHgAqAABhLgInLgMnMx4CFx4CFyE3PgI3Fw4CBwclJz4CNzczBw4CAessXFssGTApIw1vEyoyHitiZC390BgII0Q5HiQqFgcYARUeJjAZBAlcCQUoS0uMfTYfOzQqDxY2PyY7iJJLpjphSRc8ETlLLaP2PBI4Si1eYTpgSAD//wAkAAACVAJRBiYAAwAAAAcADwDI/0YAAQATAAACVgL4ACEAAGEuAicmJicjNTcVMx4CFxYWFz4CNzczBw4CBxYWFwHtLFxcKyMvE2ZcPBMqMh0SJxQiKRgECVwJBSRAMixXJ0uMfTYrOhboC6cWNj8mFzQdFDdFK15hN1tGGjyAQgD//wAk/4oCVAJRBiYAAwAAAAcASQCoAAD//wAk/yoCVAJRBiYAAwAAAAcATwCnAAAAAQAwAVECCQJcAAcAAEEzFSE1MzUzATzN/ifMQAGRQEDLAAEAN/8pAMb/swAUAABXNSYmNTUzFRQWMzI2NTUzFRQGBxVsGhsjERQUECMbG9crBCQjFBQXFBQXFBQjIwUrAAACACb/3AIhAlcAEAAYAABXNTc+Azc3MwcOBAcnAzcTFgYGBybKLEczIAUKXAkEGSxDXT4tg1lnBQQPDCRNLQslSoBmm5tTf15CLA4gAiEM/lYULS0VAAIAIv//Ah4CVwAQABcAAFcnMzI+Ajc3MwcOBCMnAzcTFgYHIwHLLUczHwUKXAoEFytDXUAtg1lnBw4TAU0mU4tmm5tTiWpKJicCJAz+Vh9JHgACACkAAAIXAlEADgASAABhETQmIyM3MzIWFREGBgchNSEHAXE3OLsKuGFjBBUN/oIB7gsBkjo5TF9d/q0SIBBMTP//ACkAAAIXAlEGJgAMAAAABwAPAH4AAP//ACkAAAIXAsgEJgAMAAAABgBVSQAAAQA3ARAAbwFHAAsAAFMiJjU0NjMyFhUUBlMMEBAMCxERARAQDAsQEAsMEAACACYAAAH/AlEAAwAOAABTNSEHAxE0NjY3MwYGFREmAdkKswYNDEgHBAIFTEz9+wG8DB0aBgceEv4yAP//ACYAAAH/AlEGJgAQAAAABgAPTwAAAQA3/xkAu//AAAcAAFc1Nyc3FQcXP0pSeUZR5xsMaRcdDWgAAQAy/zcAtP+zAAcAAFciJjUzFBYztEFBJyswyUE7KS0AAAEAN/8pAMb/swAUAABXNTQ2NzUzFRYWFRUjNTQmIyIGFRU3GhskHBojEBQUEdcUIiMFLCwFIyIUExcUFBcTAAABACv/QQHgAlEACwAARRE0JiMjNzMyFhURAYQ8NucK4GNovwI3RElMcWj9zgD//wAr/0EB4AJRBiYAFQAAAAcADwBzAAAAAgAxAAACYgJRAAwAFgAAQTIWFREhETQ2NjcjNwERNCYjIwYGFREBnmFj/g0GDQxdCgHLNzjFBAMCUV9d/msBvAwdGgZM/fsBRjo5Ch4P/n4AAAIALP9BAOMCUQADAAcAAFcRMxEDNzMVh1y3C4y/AxD89QK/TEwAAQAw/0ECJAJbABwAAEURNCYjIgYVFBYXFhYzBwYmJyYmNTQ2NjMyFhURAchaVkZIKSwJDgUHCRkTRkk2aEp/jb8B7Wp3SDgsPgcCA0QBAgMLY0o7XDOgjf4YAP//ADD/QQIkAlsGJgAZAAAABwAPAQL/5gACABz/QAHiAlEAEAAeAABFJyYmJyYmJzMeAhcWFhcXAyc+Azc3MwcOAwErLRlAJBk0GGYLHyIPJEMZLYIUKTIdDQQKWwoEGDBLwLNmvFk/di4TSFQoXMNorQGEPg84R0ogUVsnW1dCAAIAIQAAAuwCUQAMABYAAEEyFhURIRE0NjY3IzcBETQmIyEGBhURAihhY/10BQ0MXQsCZDc3/qEEAwJRX13+awG8DB0aBkz9+wFGOjkKHg/+fgABABIBTQCeAlEACwAAUz4DNzMXDgIHEgoSEAsDUAIHFxwQAU0dREVCHAknWVckAAABADIChQC0AwEABwAAUzQ2MxUiBhUyQUEwKwKFO0EnLCkAAQAyAoUAtAMBAAcAAFM0NjMVIgYVMkFBMCsChTtBJywpAAIAEgFNAVMCUQALABYAAFM+AzczFw4CBzM+AjczFw4CBxIKEhALA1ACBxccEHMOFhIDUQIHFxwRAU0dREVCHAknWVckKFxbJQknWVckAAIAMgKFATcDAQAHAA8AAFM0NjMVIgYVIzQ2MxUiBhW0QkEvLKpBQS8sAoU7QScsKTpCJywpAAEAF//7AV8CUQAcAABFJyMOAyMjNTMyPgI3NTQmIyM3MzIWFhURFwENJgcSJy00IA8NHzkxIwkkKT4KSzFAISoFhR8vIRFOFyYpE/UnIkwgPi7+3JT//wAX//sBXwJRBiYAIgAAAAYADxoNAAMANP8jAUL/ugADAA8AGwAAVzUzFRciJjU0NjMyFhUUBgciJjU0NjMyFhUUBjSuRQwREQwLEBALDBERDAsQEHYnJwgRDAsQEAsMEV8QDAsREQsMEAAABAA0/yABjv+7AAMABwATAB8AAFc1MxUXNTMVNyImNTQ2MzIWFRQGByImNTQ2MzIWFRQGNK4lJ0QMEBAMDBAQDAwQEAwMEBB2Jydqm5tiEQwLEBALDBFfEAwLERELDBAAAwA0/yMBQ/+6AAcAEwAfAABXNSM1MxUjFTciJjU0NjMyFhUUBgciJjU0NjMyFhUUBnhEsEWIDBAQDAsREQsMEBAMCxER1F8nJ19WEQwLEBALDBFfEAwLERELDBAAAAQANv8gAZD/uwAHAAsAFwAjAABXNSM1MxUjFRc1MxU3IiY1NDYzMhYVFAYHIiY1NDYzMhYVFAZ6RLBGaidEDBAQDAsQEAsMEBAMCxAQ1F8nJ18Mm5tiEQwLEBALDBFfEAwLERELDBAABQA3/yMBP/+6AAsAFwAjAC8AOwAAVyImNTQ2MzIWFRQGJyImNTQ2MzIWFRQGMyImNTQ2MzIWFRQGMyImNTQ2MzIWFRQGByImNTQ2MzIWFRQGiAwQEAwMEBBBDBAQDAsREWEMEBAMDBAQWAwQEAwLERELDBAQDAsREd0QDAsREQsMEF8RDAsQEAsMEREMCxAQCwwREQwLEBALDBFfEAwLERELDBAAAAYAPf8gAZD/uwADAA8AGwAnADMAPwAARTUzFSciJjU0NjMyFhUUBjMiJjU0NjMyFhUUBgciJjU0NjMyFhUUBjciJjU0NjMyFhUUBgciJjU0NjMyFhUUBgEJJ9YMEREMCxAQYQwQEAwLERFCDBAQDAsREdoMEBAMDBAQDAwQEAwMEBDgm5tiEQwLEBALDBERDAsQEAsMEV8QDAsREQsMEF8RDAsQEAsMEV8QDAsREQsMEAACADUAAAIrAlEACwAPAABhETQmIyE3ITIWFREhETcRAc83OP7VCwEnYWP+GlwBkjo5TF9d/msBUQf+qP//ADUAAAIrAlEGJgAqAAAABwAPANYAAAACACwAAAJMAlEAFQAZAABBMhYVESMRNCYjIwYGFREjETQ2Nyc1BzczFQGIYWNcNzeyBg5cEhEUQwrcAlFfXf5rAZI6OQkyNf5rAX4sRxMESUxMTAABADf/ggBv/7oACwAAVyImNTQ2MzIWFRQGUwwQEAwLERF+EQwLEBALDBEAAAEANwKYAG8C0AALAABTIiY1NDYzMhYVFAZTDBAQDAsREQKYEQwLEBALDBEAAQA3ApgAbwLQAAsAAFMiJjU0NjMyFhUUBlMMEBAMCxERApgRDAsQEAsMEQABACEA6gEgATMAAwAAdzUzFSH/6klJAAABACEA6gEgATMAAwAAdzUzFSH/6klJAAABADgChQDIAw8ABQAAUzUzNTMVOGslAoUkZooAAQAyAokBDQL6AA0AAEEUBiMiJjUzFBYzMjY1AQ05NDQ6IigkJCgC+jI/PzIlKS0hAAABAC0AAAHWAlEAEQAAczUzMjY1NCYjIzczMhYVFAYjLaRTU1NTpAuZgIWFgExwam1yTJqRj5cA//8ALQAAAdYCUQYmADQAAAAGAA9lAP//AC0AAAHWAsgGJgA0AAAABgBVFgAAAQAiAAAB5wL4AAgAAFMhBwMjEyE1N34BaQqzX6/+qFwCUTr96QIF6Av//wAiAAAB5wL4BiYANwAAAAYADzUYAAEAN/+CAG//ugALAABXIiY1NDYzMhYVFAZTDBAQDAsREX4QDAsREQsMEAAAAQAy/xIAsf+zAAUAAFcnNzMHF4NRTy5PUe5ST1BRAAABACICBQEhAlEAAwAAUzUzFSL/AgVMTAACADICgwDFAxYACwAXAABTIiY1NDYzMhYVFAYnMjY1NCYjIgYVFBZ8HysrHx4rKx8SFxgREBgYAoMrHx4rKx4fKyEYEREXFxERGAAAAQAvAAACbQJbACQAAHMTJzMXMz4DMzIWFhUVFAYGIyM3MzI2NTU0JiYjIg4CBwM8RVJcMQMLHjBGL0NkOTtxUmQKVlBWJ0IrKjokFQVAAWPuniE8Lxw/fWAOXIlMTH5nDkhbLB4zPSD+oAD//wAvAAACbQJbBiYAPQAAAAcADwERAAAAAgAy/yEBN/+dAAcADwAAVzUyNjUzFAYjNTI2NTMUBrQwLCdBxDArJ0DfJy0oOkInLSg6QgAAAQAy/zcAtP+zAAcAAFc1MjY1MxQGMi8sJ0HJJi0pO0EAAAEAMv8lAMT/swAFAABXNTM1MxUybSXbJWmOAAACADAAAAExAlEADAAQAABzETQmJiMjNzMyFhURITUzFdUPHhZEClFCRv7/0QG9GSEOTEdE/jpMTAD//wAwAAABMQJRBiYAQwAAAAYADxcAAAEATwAAAW0CUQANAABzETQ2MzMVIyIGFREzFU9VUFdAMDPFAalSVkwuN/6sTAABADICggCxAyIABQAAUyc3MwcXg1FPLk9RAoJSTk9RAAEA5f8RASYC+gADAABTMxEj5UFBAvr8FwAAAQAyAooAtAMGAAcAAFM0JiM1MhYVjSswQUECiiktJkE7AAEANP+KAOT/sQADAABXNTMVNLB2JycAAAEANwJyAL0C+AASAABTNTMVFjMyNjU1MxUUBgciJicVNyMCGhQQIyIjCQ8GAnKGKhsUFxoaJSUBAwMnAAEANQAAAigCWwAkAABzNTMyNjY1NCYjIgYVFBYXFhYzBwYmJyYmNTQ2NjMyFhUUBgYjRbhAXDFWVkZKKiwIDgUGCRoTRkg2aEt/i0mJYUw5ZkNqd0g4LD4HAgNEAQIDC2NKO1wzoI1biEsA//8ANQAAAigCWwYmAEsAAAAHAA8BAf/2//8ANQAAAigCyAYmAEsAAAAGAFV8AAABADIChQC0AwEABwAAUzQmIzUyFhWNKzBBQQKFKSwnQTsAAQA0/yoA5P+xAAcAAFc1IzUzFSMVeUWwRdZgJydgAAABADT/TQCx/7EABwAAVzUjNTMVIxVfK30rsz0nJz0AAAQAMgKCAaQDLQAPAB8AKwA3AABBJzcmNTQ2MzIWFRQGIyInBycGIyImNTQ2MzIWFRQHFycyNjU0JiMiBhUUFjMyNjU0JiMiBhUUFgEWHR8KLB8fLCsgFBB1HhEUICssHx8sCh9fEBcXEBAZGOsRGBkQDxgXAoIdHxAVHysrHx8sCB4eCCwfHysrHxUQHxwXEREXGBAQGBgQEBgXEREXAAACAED/QQJRAlEABgAKAABhEyE3IQcDBRE3EQFIoP5YCwIGCKX+ulwCBks6/em/AjQH/cr//wBA/0ECUQJRBiYAUgAAAAcADwDIAAgAAwA3/yMBB/+6AAsAFwAjAABXIiY1NDYzMhYVFAYXIiY1NDYzMhYVFAYXIiY1NDYzMhYVFAZTDBAQDAsREUEMEBAMDBAQQQwREQwLEBB+EQwLEBALDBEwEAwMEBAMDBAvEAwLERELDBAAAAEANAKhAPkCyAADAABTNTMVNMUCoScnAAEAKAAAAcACUQALAABhETQmIyM3MzIWFREBZDc3zgvJYWMBkjo5TF9d/mv//wAoAAABwAJRBiYAVgAAAAYAD2EAAAEANQKKAJ4C/wADAABTJzcXajU1NAKKOjs7AAABACz/9gJRAlEAHgAARSImNTU0Njc1NwcGBhUUFjMyNjU0JiMhNyEyFhUUBgFKgH0rIFcLHR5NVFlSPkv+wAsBOHVtggqUkAtFciQMBhAhcEN3eIeAXWJMiYGjrgD//wAs//YCUQJRBiYAWQAAAAcADwD3AAAAAwA3/yMA2/+6AAsAFwAjAABXIiY1NDYzMhYVFAYzIiY1NDYzMhYVFAYHIiY1NDYzMhYVFAZTDBAQDAsREWEMEBAMDBAQQwwQEAwMEBB+EQwLEBALDBERDAsQEAsMEV8QDAsREQsMEAADADUClQDdAzAACwAXACMAAFMiJjU0NjMyFhUUBgciJjU0NjMyFhUUBjMiJjU0NjMyFhUUBokNERENDBERQgwSEgwMEhJhDRERDQwREQL1EQ0MEREMDRFgEg0MEREMDRISDQwREQwNEgAAAQAyAo0AoQMsAAsAAFM3JzcnNzMHFwcXBzI7ODg4ODQ5OTk5QAKNICAgHyAgHyAgIAACAFQAAALJAlEADwAeAABhETMRMzI2NjURMxEUBgYjIREzMhYWFRUjNTQmIyMRARo+jy89HlguXEb+W/4/TiU+NzKwAaL+qxpAOAFy/oxOYi0CUSZOPfDkPTT9+wAAAgA2/yMAbv+6AAsAFwAAVyImNTQ2MzIWFRQGByImNTQ2MzIWFRQGUgwQEAwMEBAMDBAQDAwQEH4RDAsQEAsMEV8QDAsREQsMEAACAED//QKZAlEAFwAkAABFIiYmNTUzFRQWFjMzMjY2NTUzFRQGBiMnJxY2NjU1MxUUDgIBZ16DRlwvWkEKQ1wvW0WEXu4HQ1YpXCJFaQNQm3H4+Ft7PT16W/n4cZtQ6UADK1pAaWM/Y0UiAP//AED//QKZAlEGJgBgAAAABwAPAWv/uf//AED//QKZAtAGJgBgAAAAJwAPAWv/uQAHAGQCGwAA//8AQP/9ApkC0AYmAGAAAAAnAA8Ba/+5AAYAaBwAAAEANwKYAG8C0AALAABTIiY1NDYzMhYVFAZTDBAQDAsREQKYEAwLERELDBD//wBA//0CmQLQBiYAYAAAAAcAZAIbAAD//wBA//0CmQLQBiYAYAAAAAYAaBwAAAEANP8gAFr/uwADAABXNTMVNCbgm5sAAAEANwKYAG8C0AALAABTIiY1NDYzMhYVFAZTDBAQDAsREQKYEQwLEBALDBEAAgBF//cAsgIfAAsAFwAAdzQ2MzIWFRQGIyImETQ2MzIWFRQGIyImRR0aGhwcGhodHRoaHBwaGh0tGxsbGxsbGwHWGxwcGxsbGwADACMAAAJjAlEACwAYABwAAGERNCYjITUhMhYVESE3MzI2NjURMxEUBiMDNzMVAgc3OP79AQphY/3ACyQXHQ9cSkYqC38Bkjo5TF9d/mtMEyYeAZr+YU1RAgVMTAD//wAjAAACYwJRBiYAawAAAAcADwEk//oAAgAyAoIA3QMtABAAHAAAUyc3JjU0NjMyFhUUBiMiJic3MjY1NCYjIgYVFBZPHR8KLB8fLCsgCRQHIxEYGRAPGBcCgh0fEBUfKysfHywEBBsYEBAYFxERFwAAAgAyAoIA3QMtABAAHAAAUycGBiMiJjU0NjMyFhUUBxcnMjY1NCYjIgYVFBbAHggSCyArLB8fLAofXxAXFxAQGRgCgh4EBCwfHysrHxUQHxwXEREXGBAQGAAAAQA5//YCRwJXABsAAEUiJjURMxEUFjMyNjU0JgciBgc1NjYzNhYVFAYBPHyHXFhNU140QBYnFRkvGWdajAqppQEN/vOAhYWAYGkBBgVKBQYBj4Slqf//ADn/9gJHAlcGJgBvAAAABwAPAOoADQACADP/NwC7/8IABwATAABXNTI2NTMUBiciJjU0NjMyFhUUBjkvLCdBKwsREQsNERHJJi0pO0FQEQ0MEREMDREAAQAy/zcAtP+zAAcAAFciJjUzFBYztEFBJyswyUE7KS0AAAMAKwAAAf0CUQAEAAkAFwAAZQEzExcFNSEXBycnPgM3NzMHDgMBof6LbLeX/kUBmyALmRsgKRgLAwtcCwMVKEEFAkz+1Os6TBI66j8LMT49F1pkH0xMPf//ACsAAAH9AlEGJgBzAAAABwAPADz/oQACADb/ggDW/7oACwAXAABXIiY1NDYzMhYVFAYzIiY1NDYzMhYVFAZSDBAQDAwQEFwMEBAMCxERfhEMCxAQCwwREQwLEBALDBEAAAH/7v/TABICpwADAABTESMREiQCp/0sAtQAAf+V/9MAawKnAA4AAFcjEQcnNyc3FzcXBxcHJxIkQRhUVBhTUxhUVBhBLQJCQhhSUhhTUxhSUhhCAAH/7v/TANICpwAKAABTByc3IxEjETMnN9JqGEOCI6VDGAI+aBg//aYCfT8YAAAB/y7/0wARAqcACgAAVyMRIxcHJzcXBzMRI4FCF2pqF0KkLQJaPxhoaRg/ABAAMAAqAiICHAAHAA8AFwAfACcALwA3AD8ARwBPAFcAXwBnAG8AdwB/AABBFCMiNTQzMicUIyI1NDMyFxQjIjU0MzIXFCMiNTQzMicUIyI1NDMyBxQjIjU0MzIBFCMiNTQzMiUUIyI1NDMyARQjIjU0MzIHFCMiNTQzMgEUIyI1NDMyBxQjIjU0MzIXFCMiNTQzMicUIyI1NDMyFxQjIjU0MzInFCMiNTQzMgHgGRsbGUgZHBwZeRsaGxoRGRsbGd8aGhoaVBsaGhsBIhsaGhv+lhsaGhsBORkbGxlIGRwcGf7eGRwbGhEaGxsa3hoaGhrNGhsbGnkbGhobSBsaGhsBwBoaGxUaGhuTGxsabxoaGsUbGxosGhob/sMaGhvXGhkc/qoaGhtLGRkbAQgbGxpvGhoa+BsbGm8aGhuSGxkbFRoaGwAAAQA3ApgAbwLQAAsAAFMiJjU0NjMyFhUUBlMMEBAMCxERApgRDAsQEAsMEQACACYAAADdAlEAAwAHAABzETMRAzczFYFctwuMAlH9rwIFTEwA//8ACwAAAN0CUQYmAHwAAAAGAA/UAP//ACYAAADdAtAGJgB8AAAABgAuXAD//wAmAAACAwJRBCcAfAEnAAAABgB8AAD//wAmAAACCAJRBCcAfAEsAAAABgCKAAAAAwAmAAAC0AJRABMAIAAsAABhLgInLgMnMx4DFx4CFyE3PgM3Fw4CBwclJz4CNzczBw4CAmI6dnM2Hzo0KxB0ESYrMBs3fIA7/VYeBxgqQS8eKzEYCB4BaR4rNR4FD1wPBi1RS4t+Nh87NCoPECcsMhw7iJJLvitNQTUUPBU8Sy272zwVO0stcnU6YUsAAAIAIQAAAoYCUQAKAA4AAGERNDY2NzMGBhURATUhBwHIBg4LSAcE/f0CZQsBvAwdGgYHHhL+MgIFTEwAAAIALwAAAtICUQALAA8AAGERNCYjITchMhYVESERNxECdjg1/iYLAdVeZf1wXAGSPjVMXV/+awFRB/6oAAEAHQAAAoQCUQARAABzNSEyNjU0JiMhNyEyFhUUBiMdAWJTVFRT/p4LAVeAhYWATHBqbXJMmpGPlwABAAgAAAJkAvgACAAAYRMhNTcVIRUDAUe9/gRYAgTCAgXoC6c6/ekAAQAnAAACegJRAAsAAGERNCYjITchMhYVEQIeODX+dgsBhl5kAZI+NUxdX/5rAAMAJgAAAy4CUQALABcAGwAAYRE0JiMhNSEyFhURITczMjY1ETMRFAYjAzczFQLSNzj+NQHSYWP8+AskIiFcSkYjC38Bkjo5TF9d/mtMKywBmv5hTVECBUxMAAEAN/8pAMb/swAUAABXNSYmNTUzFRQWMzI2NTUzFRQGBxVsGhsjERQUECMbG9crBCQjFBQXFBQXFBQjIwUrAAABADL/EgCw/7MABQAAVyc3MwcXg1FPLU5Q7lJPT1IAAAIAJgEGAN0CUQADAAcAAFMRMxEnNzMVgVy3C4QBBgFL/rX/TEz//wAQAQYA3QJRBiYAigAAAAcAD//aAGL//wAmAGgA3QJRBiYAigAAAAcALQBZAOb//wAmAQYCCAJRBCcAigEsAAAABgCKAAD//wAmAG0CDwJRBCcAigEyAAAAJgCKAAAABwBJAK8A4wADADICkwC7AzQAAwAPABsAAFM1MxU3IiY1NDYzMhYVFAYHIiY1NDYzMhYVFAYyJUUMEhIMDBISCw0REQ0MEhICk6GhYhENDBERDA0RXxENDBERDA0RAAIANQKWAHEDMAALABcAAFMiJjU0NjMyFhUUBgciJjU0NjMyFhUUBlMNERENDBERCw0SEg0MEREC9RENDBERDA0RXxENDBERDA0RAAABADICigEOAvwAIQAAUyY1NDYzMhYXFhYzMjY1NCc3FhUUBiMiJicmJiMiBhUUF1ooHhgSHRMPFQsLDhYKKB0YEh4TERENCg4WAooNLRgfFRoVEg4OFgobECsYHhQaFxEPDhYKAAACACoAAQErAlEAEwAXAAB3LgM1NDY2NxcOAhceAxcDNSEHeQcOCgUSMCteMzEOAQEJDA4FrgEBCwErYF1OGiBGPRMCDzhDIBpVY2ImAgRMTAD////2AAEBKwJRBiYAkgAAAAYAD78AAAEAMgKFAQ4C9gAhAABTJjU0NjMyFhcWFjMyNjU0JzcWFRQGIyImJyYmIyIGFRQXWigeGBIdEw8VCwsOFgooHRgSHhMREQ0KDhYChQ0tGB4UGxQSDg4WCRsPKxgeExsXEA4OFgoA//8AJgEGAi8C9AQnAIoBUwAAACYAigAAAAcAigCGAKIAAgAAAAACeQLMAAcAEgAAYSchByMBMwEBLgInDgIHBzMCGE7+51BhAQhwAQH+7AUNDQcEDg0GVO/c3ALM/TQCDQ4rMRQSLywS5QAC//4AAAMmAsoADwATAABhITUjByMBIRUhFSEVIREhJTMRIwMm/nDaWmQBMwH1/skBJP7cATf9s70v29sCykrlSv763AFWAP//AAAAAAJ5A68GJgCXAAAABwEHANQAsf//AAAAAAJ5A5kGJgCXAAAABwEcAH4Asf//AAAAAAJ5A60GJgCXAAAABwEpAHMAsf//AAAAAAJ5A4sGJgCXAAAABwEzABYAsf//AAAAAAJ5A68GJgCXAAAABwFTAKEAsf//AAAAAAJ5A04GJgCXAAAABwHVAIMAsf//AAD/HgJ5AswGJgCXAAAABwGAAaUAAP//AAAAAAJ5A3sGJgCXAAAABwGhAKYAQf//AAAAAAJ5A5IGJgCXAAAABwGzAGMAsQADAF0AAAJHAsoAEgAbACUAAEEyFhUUBgYHFR4CFRQGBiMjERMyNjU0JiMjFRURMzI2NTQmJiMBMox5ITonL0IhQnVN5ttVT1JbeYtTWClQOgLKWFYrRCwHAwkqRTJGWywCyv7OPzo8N+xF/vVFRi44GgABADv/9gJUAtQAHwAAQSIOAhUUFhYzMjY3FQYGIyImJjU0PgIzMhYXByYmAZE7XkEhNmxSNVonJl46bpJHLVmAUTJiLhwqUgKJK01rQFqERxQPTBASXaVuT4ZiNxQWSBUS//8AO//2AlQDrwYmAKMAAAAHAQcBEgCx//8AO//2AlQDrQYmAKMAAAAHASEAsQCx//8AO/8QAlQC1AYmAKMAAAAHASYA+AAA//8AO//2AlQDlgYmAKMAAAAHATcBHQCxAAIAXQAAAokCygAJABMAAEEUBgYjIxEzMhYHNCYmIyMRMzI2AolWpnm3zK+xXDh2XG1ijIkBb3mkUgLKsqxaez/9y4///wBdAAACiQOtBiYAqAAAAAcBIQCYALH//wAQAAACiQLKBgYAtAAAAAEAXQAAAe0CygALAABhIREhFSEVIRUhESEB7f5wAZD+yQEk/twBNwLKSuVK/voA//8AXQAAAe0DrwYmAKsAAAAHAQcAwgCx//8AXQAAAe0DrQYmAKsAAAAHASEAYQCx//8AXQAAAe0DrQYmAKsAAAAHASkAYQCx//8AXQAAAe0DiwYmAKsAAAAHATMABACx//8AXQAAAe0DlgYmAKsAAAAHATcAzQCx//8AXQAAAe0DrwYmAKsAAAAHAVMAjwCx//8AXQAAAe0DTgYmAKsAAAAHAdUAcQCx//8AXf8eAe0CygYmAKsAAAAHAYABHAAAAAIAEAAAAokCygANABsAAEEyFhUUBgYjIxEjNTMRFyMVMxUjFTMyNjU0JiYBKa+xVqZ5t01Nxm2np2KMiTh2AsqyqXmkUgE+SgFCSvhK84+SWns/AAEAXQAAAe0CygAJAABzIxEhFSERIRUhtVgBkP7IASX+2wLKSv78SgABADv/9gKLAtUAIQAAQSERBgYjIiYmNTQ2NjMyFhcHJiYjIgYGFRQWFjMyNjc1IwFuAR0yfkJunVNWpHQ9bS4fLlwvWXs/QXdSK08dyQF4/qsWF1OkeGymXhYWSBYTToVUZIA+DgvW//8AO//2AosDmQYmALYAAAAHARwA2ACx//8AO/8jAosC1QYmALYAAAAHAS0BiAAA//8AO//2AosDlgYmALYAAAAHATcBOQCxAAEAW//4AqIC0wArAABBMhYWFwceAhUUBgYjIiYnNRYWMzI2NTQmIyM1Ny4CIyIGBhURIxE0NjYBYkhkPwyCPFwzOW1PNU0aHEsrUVZbWhuACSY+LTVOKlhFdgLTLUwxjwUuVD5CYzgTC04QFFFERERBkRcoGihVRP45AdNXcTgAAQBdAAACewLKAAsAAGEjESERIxEzESERMwJ7Wf6UWVkBbFkBUP6wAsr+0QEvAAIAAAAAAt8CygATABcAAHMRIzUzNTMVITUzFTMVIxEjESERESE1IWBgYFkBbFlhYVn+lAFs/pQCGzp1dXV1Ov3lAVD+sAGbgAAAAQAzAAABJALKAAsAAGEjNTcRJzUzFQcRFwEk8UxM8UxMNg4CQQ82Ng/9vw4A//8AMwAAAVMDrwYmAL0AAAAHAQcAQwCx//8ACgAAAU0DrQYmAL0AAAAHASn/4gCx//8AFwAAAUADiwYmAL0AAAAHATP/hACx//8AMwAAASQDlgYmAL0AAAAHATcATQCx//8AMwAAASQDrwYmAL0AAAAHAVMADwCx//8AGgAAAT4DTgYmAL0AAAAHAdX/8gCx//8AM/8eASQCygYmAL0AAAAGAYBTAAAB/6X/PwC6AsoAEAAARyImJzUWFjMyNjURMxEUBgYEHioPDycWQS9ZK1TBCARJBQdNQgKz/VJHYzMAAQBdAAACXgLKAA4AAGEjAwcRIxEzETY2NwEzAQJeZ+pXWVkMHA4BCWf+8gFfTv7vAsr+mBEiEAEl/s7//wBd/yMCXgLKBiYAxgAAAAcBLQE1AAAAAQBdAAAB/ALKAAUAAHMRMxEhFV1ZAUYCyv2ASgD//wBIAAAB/AOvBiYAyAAAAAcBBwAgALH//wBdAAAB/gLKBiYAyAAAAAcB0wDM/9L//wBd/yMB/ALKBiYAyAAAAAcBLQElAAAAAQABAAACBgLKAA0AAHMRByc3ETMRNxcHFSEVZ0MjZlmSJLYBRgEJKjtAAXD+x106dPZKAAEAXQAAAxgCygAXAABhAyMeAhURIxEzEzMTMxEjETQ2NjcjAwGR5QMCAQJRe+ID4nlTAQIBA+QCaRErLRf+FwLK/aICXv02Ae4TKysR/ZgAAQBdAAACjwLKABMAAGEjASMeAhURIxEzATMuAjURMwKPa/6IAgECAVFrAXcDAQIBUQJWGzc2G/5NAsr9rhg4NxgBs///AF0AAAKPA68GJgDOAAAABwEHAQ4Asf//AF0AAAKPA60GJgDOAAAABwEhAK0Asf//AF3/IwKPAsoGJgDOAAAABwEtAXYAAP//AF0AAAKPA5IGJgDOAAAABwGzAJwAsQACADv/9gLHAtUAEQAgAABBFA4CIyIuAjU0NjYzMhYWBRQWFjMyNjY1NCYjIgYGAscoUHtUUnpSJ0qTbGyPSP3RMWhQUWcxdHJQajIBZlKGYzU1Y4dSbaVcWKVxV4RKSYRXippKgwACADv/+gNgAtAAGAAoAABBMhYXIRUhFSEVIREhFSEGBiMiJiY1NDY2FyIOAhUUFhYzMjY3ESYmAXsaMhgBgf7JAST+3AE3/ncRNBlqjUdJj2g5VjgcMGVMGy4ODC0C0AMDSuVK/vpLAgRcpG1tolpLKUxpQFeCSAYFAikEB///ADv/9gLHA68GJgDTAAAABwEHARkAsf//ADv/9gLHA60GJgDTAAAABwEpALgAsf//ADv/9gLHA4sGJgDTAAAABwEzAFoAsf//ADv/9gLHA68GJgDTAAAABwFTAOUAsf//ADv/9gLHA68GJgDTAAAABwFcAJwAsQADADv/3ALHAuoAGgAkAC8AAEEUDgIjIiYnByc3JiY1NDY2MzIWFzcXBxYWBzQnARYWMzI2NiUUFhcBJiYjIgYGAscoUHtUOFwkOS85Ly9Kk2w4XCQzMDUuL102/sAbRixRZzH+LhocAUEbRipQajIBZlKGYzUcGlAgUTGQWW2lXBoZSB5LL5Bcg0f+QBYYSYRYPmgnAcQVF0qDAP//ADv/9gLHA5IGJgDTAAAABwGzAKcAsQACAF0AAAIiAsoADAAWAABBMhYVFA4CIyMRIxEXIxEzMjY2NTQmASJ+giJCY0FkWcFoXDVTLlMCymVqN1Q7Hf7oAspK/uIbQjpFQgAAAgA7/1YCxwLVABUAJAAAQRQGBgcXIyciBiMiJiY1NDY2MzIWFgUUFhYzMjY2NTQmIyIGBgLHL11ImnGCBg0HbpBHSpNsbI9I/dExaFBRZzF0clBqMgFmV5BiFLOhAV6mbW2lXFilcVeESkmEV4qaSoMAAgBdAAACWwLKAA4AGAAAQTIWFhUUBgcTIwMjESMRFyMRMzI2NTQmJgEYWXc8TUXJZ7COWbdec0daJ1ECyidWSEphGf6/ASr+1gLKRv7sSUgwOhn//wBdAAACWwOvBiYA3gAAAAcBBwDLALH//wBdAAACWwOtBiYA3gAAAAcBIQBqALEAAQA0//YB/gLUAC4AAGUUBgYjIiYmJzUWFjMyNjY1NCYmJy4CNTQ2NjMyFhcHJiYjIgYGFRQWFhceAgH+P3JOL0Y7Gy5oOC9IKydNODhWMEBuRThhLB0uVicrRCgpTDQ7VzDCPlwyCRAKUxQXGzYqJy8lExYvSjxAVCsWFEYUExkyJigyIxMVMUj//wA0//YB/gOvBiYA4QAAAAcBBwCuALH//wA0//YB/gOtBiYA4QAAAAcBIQBNALH//wA0/xAB/gLUBiYA4QAAAAcBJgClAAD//wA0/yMB/gLUBiYA4QAAAAcBLQEWAAAAAQALAAACDwLKAAcAAGEjESM1IRUjATlZ1QIE1gJ/S0sA//8ACwAAAg8DrQYmAOYAAAAHASEARACx//8AC/8jAg8CygYmAOYAAAAHAS0BDQAAAAIAXQAAAiMCygAOABgAAEEUDgIjIxUjETMVMzIWATI2NjU0JiMjEQIjIUJkQmRZWXN9ff7tNlQvT1dtAX40UzsengLKeWj/ABxCN0dB/uMAAQBX//YCgwLKABMAAEEUBgYjIiY1ETMRFBYzMjY2NREzAoNEfVeFj1liWztVLVkBCFl6P4yGAcL+RWhlK1hDAcL//wBX//YCgwOvBiYA6gAAAAcBBwEEALH//wBX//YCgwOtBiYA6gAAAAcBKQCjALH//wBX//YCgwOLBiYA6gAAAAcBMwBGALH//wBX//YCgwOvBiYA6gAAAAcBUwDRALH//wBX//YCgwOvBiYA6gAAAAcBXACHALH//wBX//YCgwNOBiYA6gAAAAcB1QCzALEAAgBX/x4CgwLKABQAKAAARRQWMzI2NxUGBiMiJjU0Njc3DgITFAYGIyImNREzERQWMzI2NjURMwHQGhkNHggLIBQqOzY2MRcsHLNEfVeFj1liWztVLVltIRsFBDgDBzI1LlcrAxgzOQFUWXo/jIYBwv5FaGUrWEMBwv//AFf/9gKDA+sGJgDqAAAABwGhANQAsQABAAAAAAJkAsoADgAAQQEjATMTHgIXPgI3EwJk/wBk/wBjqwcODAMECw4HrALK/TYCyv4TEy8uEREsLhYB7QAAAQAaAAADjALKACkAAEEDIwMuAycOAwcDIwMzEx4DFz4DNxMzEx4DFz4CNxMDjL1lfgMHCAcCAgYGBgKAZL1XegQJCQkCBAkKCwV1U3YGCwoKAwMLCwZ+Asr9NgHgDR4hIQ8PHx4ZCf4SAsr+JhAmJyQQFC4vLRQBuf5GFC4vLhQWMTMXAdwA//8AGgAAA4wDrwYmAPQAAAAHAQcBagCx//8AGgAAA4wDrQYmAPQAAAAHASkBCQCx//8AGgAAA4wDiwYmAPQAAAAHATMArACx//8AGgAAA4wDrwYmAPQAAAAHAVMBNwCxAAH//wAAAk4CygALAABhIwMDIxMDMxMTMwMCTmfBwmXw22OwsGXeAS7+0gFwAVr+4wEd/qEAAAEAAAAAAjUCygAIAABBEzMDESMRAzMBG7lh7VnvYgFlAWX+S/7rARABugD//wAAAAACNQOvBiYA+gAAAAcBBwCyALH//wAAAAACNQOtBiYA+gAAAAcBKQBRALH//wAAAAACNQOLBiYA+gAAAAcBM//0ALH//wAAAAACNQOvBiYA+gAAAAcBUwB/ALEAAQAiAAACLALKAAkAAGEhNQEhNSEVASECLP32AY/+hQHs/nEBmTgCSEo4/bgA//8AIgAAAiwDrwYmAP8AAAAHAQcAwgCx//8AIgAAAiwDrQYmAP8AAAAHASEAYQCx//8AIgAAAiwDlgYmAP8AAAAHATcAzQCxAAIALP/2Ad0CIwAdACgAAEEyFhURIycjDgIjIiYmNTQ2Nzc1NCYjIgYHJzY2EwYGFRQWMzI2NzUBI1tfPxADEjFGMzRIJ4F1Yzg3JU0rGithS1NdNjFMTAECI19h/p1cHi4aJUQxU1EHBR1HPRQVQBQX/uIENjcrMVhGM///ACz/9gHdAv4GJgEDAAAABwEHAKwAAP//ACz/9gHdAugGJgEDAAAABgEcVwD//wAs//YB3QL8BiYBAwAAAAYBKUsAAAEAKAJeARAC/gAMAABBDgMHIzU+AjczARAOKy8vFD0VMzEOYQL2ECgpJxAJFDY4FQD///7rAl7/0wL+BAcBB/7DAAD//wAs//YB3QLbBiYBAwAAAAYBM+4AAAMALP/2Az4CIwAxAD0ARQAAQTIWFgcVIRQWMzI2NxUGBiMiJiYnDgIjIiYmNTQ2Njc3NTQmIyIGByc2NjMyFhc2NgMGBhUUFjMyNjY1NTciBgchNiYmAm5DXTAC/plZUClNLiZSNTNROhEUNlA5M0spPG5MXTgzI00qGiteMT1PERtZ9lNcNzIvQCHrOlIIARUBHjkCIz5wSy9bZw8WRBISITsoKjsfJUUxOUcmBAUeRzwUFD8VFjY7Mz7+4gQ3OCsvKEguM9pVVzNNLAD//wAs//YB3QL+BiYBAwAAAAcBUwB5AAD//wAs//YB3QKdBiYBAwAAAAYB1VsAAAMANf/2As4C1AAjAC4AOgAAQTIWFRQGBxc2NjczBgYHFyMnDgIjIiYmNTQ2NjcuAjU0NhMOAhUUFjMyNjcDIgYVFBYXNjY1NCYBOlBjVUa8GSgKXA85I4RyUB1BVDxHaTkmSTUeKBVlKCg4HFNDPlIhnTA6LCU6QjcC1FJHQ1clvSBVL0FxLIVUGyoZMVg7M0o6Gh42NyFHVv6EFCo0Jz1DKiICCzMuJTwmG0MvLC///wAs/x4B6wIjBiYBAwAAAAcBgAEeAAD//wAs//YB3QM6BiYBAwAAAAYBoX0AAAEAGgEKAhECzgAGAABTEzMTIwMDGuQt5ki0tQEKAcT+PAFo/pgAAQA0ASICDAGgABkAAEEmJiMiBgc1NjYzMhYXFhYzMjY3FQYGIyImARcfMh4dOxwYPiMmNiQfMxscOhwVPSYhNwFCDw8dHEcXGxAQDw8bHUYWHBAAAQAvAUgB7wL3AA4AAEEHNxcHFwcnByc3JzcXJwE0C7sLs3Q+Y19AdLUOuQsC98E9RyeZJJ6dI5koRj3BAAACADD/pQNGAsgAQABNAABBFA4CIyImJyMGBiMiJjU0NjYzMhYXBxQGFRQWMzI2NjU0JiYjIgYGFRQWFjMyNjcVBgYjIiYmNTQ+AjMyFhYFFBYzMjY3NyYmIyIGA0YVKj4qKjsJAxZNLVBVN2ZFKUseCQIcICMtFkSHY2ygWEiLYjVzNS9uPXapWzxwm15ypFv99zUyOz4EBxEkF0pVAWYyWUYnLSosK2FYQGY7DQqoDSoWKi0yWDdahkpYpXJjkU4WFTwTFl2rdGKcbzpWn6w/Q1BXegYFXv//ACz/9gHdAuEGJgEDAAAABgGzOwAAAgBQ//YCKQL4ABYAIwAAUxQGBzM2NjMyFhUUBgYjIiYnIwcjETMTIgYVFRQWMzI2NTQmqAICBBNaRWJtMWFJQk8TBg5GWJhOSkVJS05HAiUaQBgxQI6HU39HOCdVAvj+5GlfEGFkbGRmZwAAAQAJ//wBZQLOAAMAAFMBIwFaAQtQ/vQCzv0uAtIAAQDl/xEBJgL6AAMAAFMzESPlQUEC+vwXAAABABz/XgFSAs4AJQAARSImJjU1NCYmIzUyNjY1NTQ2NjMVIgYGFRUUBgcVFhYVFRQWFjMBUkhXJhsyJCQzGiZWSSY1HiwxMSweNiWiIUIxmCUvFUYULyaZMUEhQxEoI5s3PQgECD41niEoEQABACP/XgFZAs4AJQAAVzI2NjU1NDY3NSYmNTU0JiYjNTIWFhUVFBYWMxUiBgYVFRQGBiMjJTYdLDEwLR02JUlVJhsyJSQzGyZVSV8RKCGeNT4IBAg9N5sjKBFDIUExmSYvFEYVLyWYMUIhAAABAEz/XgElAtIABwAARSMRMxUjETMBJdnZj4+iA3Q//QkAAQAY/14A8QLSAAcAAFczESM1MxEjGI+P2dlkAvc//IwAAAEAKAJeAVUC6AAOAABBDgIjIiYnMxYWMzI2NwFVAyZBLUZLBTYHLSwqLwcC6Cs+IUhCKSYnKAD///9pAl4AlwLoBAcBHP9BAAAAAQBiAQIBHQHYAA8AAFM0NjYzMhYWFRQGBiMiJiZiFyocHCsXFyscHCoXAW0lLxcYMCMiMBkZMAABADX/9gHVAiMAHQAARSImJjU0NjYzMhYXByYmIyIGBhUUFhYzMjY3FQYGATRUcjlEeVIqRyAYIDseOFEtJkw6JksgHEwKQ3xVWH5DDw9FDw00XkA8XDMSEEgPFAD//wA1//YB1QL+BiYBHwAAAAcBBwDFAAAAAQAoAl4BbAL8ABIAAFMuAic1MxYWFzY2NzMVDgIHnw4pLRM8HDIXFzUbPBIuKg4CXhY2NhMJFzgaGjgXCRM1Nxb///9cAl4AnwL8BAcBIf80AAD//wA1//YB1QL8BiYBHwAAAAcBIQBkAAD//wA1/xAB1QIjBiYBHwAAAAcBJgCuAAD//wA1//YB1QLmBiYBHwAAAAcBNwDPAAAAAQAP/xAA1AAAABYAAFcUBiMiJic1FhYzMjY1NCYnNzMHHgLURDUZJg0OHBIeKCwvJjQYGSoZiS45BgQyBAMcGhoaAk80AhQkAP///5T/EABZAAAEBgEmhgAAAQBN//YB7QLUACMAAEEWFhcHJiYjIgYGFRQWFjMyNjcVBgYHFSM1LgI1NDY2NzUzAWEpRB8YHzsfN1ItJkw6JkwgGUIoNkpjMTZkRDYCggEPDkUPDTReQDxcMxIQSA4SAmBhBkZ3T053SAlVAAABACgCXgFsAvwAEgAAUx4CFxUjJiYnBgYHIzU+Ajf2DSotEjwbNBcXMxw8Ey0rDQL8FTc1FAkXORoaOBgJFDU3Ff///1MCXgCXAvwEBwEp/ysAAAACAEX/9wCyAh8ACwAXAAB3NDYzMhYVFAYjIiYRNDYzMhYVFAYjIiZFHRoaHBwaGh0dGhocHBoaHS0bGxsbGxsbAdYbHBwbGxsbAAEAIv97AKwAfwAKAAB3DgIHIz4CNzOsCBcbD0ENFBAEUHQlWVckMFlVJgAAAf/E/yMAPf/DAAoAAFcGBgcjNT4CNzM9DCAYNQcQDQJTRSdMJQkRODoUAAADADD/9wMNAtMAGgAuAEIAAGUiJjU0NjYzMhYXByYmIyIGFRQWMzI2NxUGBgciLgI1ND4CMzIeAhUUDgInMj4CNTQuAiMiDgIVFB4CAaticDNfQC1AHRgXNSJBUE9AIjgeHDowUIZjNjlkhU1QhmI2OGSGTER0VS8vVXRERXNWMC5UdYlyakNjNhAPMwwMVk1STwsOOgwNkjhkhU1PhWM3OmWFSk2FZDguMlh0QkN0WDExVnVEQ3RYMQACADX/9gINAvgAFwAkAABFIiY1NDYzMhYWFzMmJjU1MxEjJyMOAicyNjU1NCYjIgYVFBYBCmdudWgsQC0MAwMCWEQQBAwtQhNQREVKS1NNCoyEi5IcMR4dQyG//QhhHTAeSGhgB2NqaWxlYv//ADX/9gKvAvgGJgEvAAAABwHTAX0AAAACADX/9gJYAvgAHwAsAABFIiY1NDYzMhYWFzMmJjU1IzUzNTMVMxUjESMnIw4CJzI2NTU0JiMiBhUUFgEHZmx2aCxBLQwDAgXCwlhLS0gRBA0sQQtOQUZFSVFJCoeAiIwcMR4ZRCQ5O11dO/2gYR0wHkhkXAZfZWNpW2MAAgA4AZ0BcgLUAA8AGwAAUyImJjU0NjYzMhYWFRQGBicyNjU0JiMiBhUUFtUtRykpRy0tRykpRy4rNjYrKzU1AZ0nRi4vRicoRi4uRyY7NiosNTUsKjYAAAIAkwJ7AbwC2wALABcAAFM0NjMyFhUUBiMiJjc0NjMyFhUUBiMiJpMYFhcYGBcWGMwYFRgYGBgVGAKrFhoaFhcZGRcWGhoWFxkZAP///2sCewCUAtsEBwEz/tgAAAADADMAeAIMAkoAAwAPABsAAFM1IRUHIiY1NDYzMhYVFAYDIiY1NDYzMhYVFAYzAdntFRcXFRcXFxcVFxcVFxcXAUFAQMkaGBkaGhkYGgFtGhkZGRkZGRoAAwAy/8YB9QL3ACQALAA1AAB3JiYnNRYWFzUuAjU0NjY3NTMVFhYXByYmJxUeAhUUBgcVIzc2NjU0JiYnAw4CFRQWFhf5P10jJ2Q0N1s1M1o6MTBZKBcoTyM+WzJsXzExOEUdNykxIzcgITciDwETDUwQFgL1Ey5IOThLKgM8OwIVEkAREQLuFS5EN1RgCEmPBDY2HykfDgE9AhgtISEsHQ0AAQAoAoAAlQLmAAsAAFMyFhUUBiMiJjU0Nl4aHR0aGhwcAuYZGxoYGBobGf///8oCgAA3AuYEBgE3ogAAAgA1//YCAwIjABcAHwAAQTIWFhUVIRQWMzI2NxUGBiMiJiY1NDY2FyIGByE0JiYBKkhhMP6LWlcxSy4mVDlTczs5bVFBVAcBIh08AiM+b0wvXGYQFUQSEkJ7VVV/R0BWVjNNLAD//wA1//YCAwL+BiYBOQAAAAcBBwC0AAD//wA1//YCAwL8BiYBOQAAAAYBIVMA//8ANf/2AgMC/AYmATkAAAAGASlTAP//ADX/9gIDAtsGJgE5AAAABgEz9gD//wA1//YCAwLmBiYBOQAAAAcBNwC/AAD//wA1//YCAwL+BiYBOQAAAAcBUwCBAAAAAwA0//YCCgLUAB4ALQA6AABBMhYVFAYGBx4CFRQGBiMiJiY1NDY2Ny4CNTQ2NgMUFjMyNjU0JiYnJw4CEyIGFRQWFz4CNTQmASBgcyVDLTJOLDprSUloNypLMSdBJzZhWlFDRlUiOycWKkMolzZKSDkoOR5FAtRWUSxBMRMUNUgzO1cwMFY4NUo0ExIvQy41Syj94zpDQT4kNigPCQ8pOgGvNzQwPBcSJC8gNDX//wBF//cCpQBjBCYBjwAAACcBjwD5AAAABwGPAfMAAP//ADX/9gIDAp0GJgE5AAAABgHVYwAAAQAnAO4DwQEwAAMAAHc1IRUnA5ruQkIAAQAnAO4BzgEwAAMAAHc1IRUnAafuQkIAAwA1/x4CAwIjABQALAA0AABFFBYzMjY3FQYGIyImNTQ2NzcOAgMyFhYVFSEUFjMyNjcVBgYjIiYmNTQ2NhciBgchNCYmAYIcGA4cCQsgFCs7Ljs2ICsWWEhhMP6LWlcxSy4mVDlTczs5bVFBVAcBIh08dBkcBQQ4AwcxLSNLLQEdMCkCgT5vTC9cZhAVRBISQntVVX9HQFZWM00sAAACADMA1wINAeoAAwAHAABTNSEVBTUhFTMB2v4mAdoBqkBA00FBAAIANP/2AhQC+QAkADQAAFMWFhc3FwceAhUUBgYjIiYmNTQ2NjMyFhYXMyYmJwcnNyYmJxMiBgYVFBYWMzI2NTQuAtcmPBhrHVwzQyE4a09Jazo7Z0AqOykNAw45K3IeaBMyGmsuRCYkQi9JTg4hOQL5ECMTQy44M3WGTlKCSjpsS05tOhAbEjhrKUcvPw4eDf7OKU86N04pcG0ULigZAAABACb/9gIpAtUANgAAQTIWFwcmJiMiDgIHMxUjBgYVFBYXMxUjHgIzMjY3FQYGIyImJicjNTMmNDU0NjUjNTM+AgGRLkogGx07JSZBMiAG4+cBAQEB29YIMFI5JkEdG0QqSnJLDlZQAQFQVQ1GdQLVEQ9HDg4aNEoxNQgYDg4XCTU7UywQDUwNDzd0WjUJGAsNHAc1VHxEAAIARf/3ALICygADAA8AAHcjAzMDNDYzMhYVFAYjIiajTAtiaR0ZGxwcGxkdywH//WMbGxsbGxsbAAACAEb/TwCzAiIAAwAPAABTMxMjExQGIyImNTQ2MzIWVksLYWgdGRscHBsZHQFN/gICnRscHBsbGxsAAQAPAAABeAL9ABcAAEEjESMRIzU3NTQ2MzIWFwcmJiMiBhUVMwE5d1hbXUtVIDIaEhAnEzEpdwHU/iwB1DEUMllZCQg/BgYyOTUAAAEAQP/2AgYCygAhAABBMhYWFRQGBiMiJic1FhYzMjY2NTQmIyIGBycTIRUhBzY2ASVDZTk/d1Q7XiMjYDM4US1WViZCHicdAWn+4xMVOgG6M2BGSmk4FxJOExslSDNFTgsJFgFWTNQFCwACABYAAAI0As0ACgAWAABlIxUjNSE1ATMRMyc0NjQ2NSMGBgcDIQI0cVj+qwFZVHHJAQEDDhUTyQEAra2tQQHf/ibdGSkiHQwZIRv+6wACADX/EAIMAiMAIgAzAABBMhYXMzczERQGBiMiJic1FhYzMjY1NTQ2NyMGBiMiJjU0NhciBgYVFBYzMj4CNTU0JiYBEERMFQMITDNtWD9eKCldO1hMAgIEElhDYXFyhDVGIk1JLTsgDho9AiM0KFL910VkNxMQTxMXUEUeFygZMzqLh4aVRzJfRWRlHzVEJSY4VS///wA1/xACDALoBiYBTgAAAAcBHABuAAD//wA1/xACDAL8BiYBTgAAAAYB1EAA//8ANf8QAgwC5gYmAU4AAAAHATcAzgAAAAEAUP/2AkkC/QA6AABBFA4DFRQWFx4CFRQGBiMiJic1HgIzMjY1NCYmJy4CNTQ+AzU0JiMiBhURIxE0NjYzMhYWAggcJykbMy4eLhspVD42RRwULS4XNTsTKSEhMBobKSkbOzlKR1g5aUdAXDMCZyMxIh4hFyAoHhQqOiwtRigQDEcKDwkxKR0nIxMVJS0fIiwfHSceJzBOR/3eAilFXjEjQwAAAQAoAl4BEAL+AAwAAFMeAhcVIy4DJzWKDzA0EzwULzAqDwL+FTg2FAkQJykoEAj///4YAl7/AAL+BAcBU/3wAAAAAQA0AHcCCwJdAAYAAHclJTUFFQU0AXr+hgHX/im9qrBG4yvYAAACAB4ARQHUAesABgANAABTNxcHFwcnNzcXBxcHJx6mPYeHPabTpj2Hhz2mAR7NI7CxIswNzSOwsSLMAAACAB4ARQHVAesABgANAABBByc3JzcXBwcnNyc3FwHVpj6IiD6m06Y+iIg+pgESzSOwsSLMDc0jsLEizAABAB4ARQEBAesABgAAUzcXBxcHJx6mPYeHPaYBHs0jsLEizAABAB4ARQECAesABgAAUxcVByc3J1ympj6IiAHrzA3NI7CxAAABAFEAAAIVAvgAGgAAUxQGBzM+AjMyFhYVESMRNCYjIgYGFREjETOpAwEEDi9GLzhULlg/OjFFJVhYAislNRYeMBopVkX+oQFJTEcsVkL+6AL4AAABAAoAAAIZAvgAIgAAUxUzFSMVFAYHMz4CMzIWFhURIxE0JiMiBgYVESMRIzUzNa3CwwICBg0vRi84VC5ZPjswRSVYS0sC+F07XBYvFx8vGylXRP6zATdLRytXQv77AmA7XQAAAgAoAl4BogL+AAwAGQAAQQ4DByM1PgI3MwcOAwcjNT4CNzMBogoiKSgSMhApJQxXuQoiKSkRMhEoJQxXAvYQKComEAkUNTgWCBAoKiYQCRQ1OBb///+CAl4A/AL+BAcBXP9aAAAAAgBIAAAAtQLmAAMADwAAUxEjETcyFhUUBiMiJjU0NqlYLRodHRoaHBwCGf3nAhnNGRsaGBgaGxkA//8APgAAASYC/gYmAWIAAAAGAQcWAP///90AAAEgAvwGJgFiAAAABgEptQD////qAAABEwLbBiYBYgAAAAcBM/9XAAAAAQBRAAAAqQIZAAMAAHMjETOpWFgCGQD//wAKAAAA8wL+BiYBYgAAAAYBU+IA////7AAAARECnQYmAWIAAAAGAdXEAP//ABL/HgC3AuYGJgFeAAAABgGA6gAAAv/O/xAAtALmABAAHAAAVyImJzUWFjMyNjURMxEUBgYDNDYzMhYVFAYjIiYaFCkPDx4PIiVYIT8BHBkbHBwbGRzwBgVIBgQtMAJj/YssQyUDohsZGRsaGBgAAf/O/xAAqQIZABAAAFciJic1FhYzMjY1ETMRFAYGGhQpDw8eDyIlWCE/8AYFSAYELTACY/2LLEMlAAEAUQAAAhYC+AASAABTFAYHMTY2NzczBxMjJwcVIxEzqQICDx0PwGXI2WWyVlhYAZ4rVSoSJRHd5v7N+1ekAvgA//8AUf8jAhYC+AYmAWgAAAAHAS0BCQAAAAEAUgAAAKoC+AADAABzIxEzqlhYAvgA//8APQAAASYD3QYmAWoAAAAHAQcAFQDf//8AUgAAAUYC+AYmAWoAAAAGAdMTAP//AEH/IwC6AvgGJgFqAAAABgEtfgAAAQA0AHcCCwJdAAYAAGUlNSUVBQUCC/4pAdf+hgF6d9gr40awqgABAAEAAAEnAvgACwAAcxEHJzcRMxE3FwcRZkMiZVdIImoBHis7PwGL/qkvOkL+rAABAFEAAANAAiMAJwAAQTIWFREjETQmIyIGFREjETQmJiMiBgYVESMRMxczPgIzMhYXMzY2ApZOXFg7L0BKVxwuICk+I1hDDQMNKkMvOU4SAxZXAiNZYf6XAVJKQFVb/tQBUjE8HSdRPv7aAhlVGCscMi8tNAD///9tAmMAkQKdBAcB1f9FAAD//wAhAOoBIAEzBgYAMAAAAAEARgCIAfkCOgALAABBFwcXBycHJzcnNxcBzC2trS2trSurrCytAjosra0srKwtrKwtqwABAFEAAAIVAiMAFQAAQTIWFREjETQmIyIGFREjETMXMz4CAVxWY1g/OkpRWEMMBA8vSAIjXmb+oQFJTEdiYv7oAhlgHTAdAP//AFEAAAIVAv4GJgF0AAAABwEHAMgAAP//AFEAAAIVAvwGJgF0AAAABgEhZwD//wBR/yMCFQIjBiYBdAAAAAcBLQExAAAAAgAu//UCCALUACAALwAAQRQOAiMiJic1FhYzMjY2NyMOAiMiJjU0NjYzMh4CJyIGFRQWMzI2NjU0LgICCCxVeU0bOhQTNR1QbToDBA0wSTRfbDZnSD1cPR/zRkpGRi9FJw4hOwGZbJ9nMgUFSwYHQodpGzAfd2hJbDsvVXSvV1BGUik7HBpBPCj//wBRAAACFQLhBiYBdAAAAAYBs1cAAAIAGAAAAnQCygAbAB8AAEEHMxUjByM3IwcjNyM1MzcjNTM3MwczNzMHMxUFMzcjAeMfjJgpQCmbKUAohJAfipUpQSmbKEEphv50mx+bAbajPdbW1tY9oz7W1tbWPqOjAAIANf/2AiECIwARACAAAEEUDgIjIi4CNTQ2NjMyFhYFFBYWMzI2NjU0JiYjIgYCIR8/XD06Wz8hO3BPUGs3/m0iRTU3RSEeRDdOUgENPmdJKShKZz5XfUJGfVM/XzQ0YD49XzZu//8ANf/2AiEC/gYmAXsAAAAHAQcAwwAA//8ANf/2AiEC/AYmAXsAAAAGASliAP//ADX/9gIhAtsGJgF7AAAABgEzBQAAAwA1//YDlgIjACQAMwA7AABBMhYWFRUhFBYzMjY3FQYGIyImJwYGIyImJjU0NjYzMhYXPgIFIgYVFBYWMzI2NjU0JiYlIgYHITYmJgLERV0w/otcVyxOLiZTOVBoGRlmUE5tOjtwT05iFxI3UP6fTlEhRTU3RSEeRAFbQlQHASIBHjsCIz5wSy9bZw8WRBISSD49SUZ+U1d9Qko8Jz0iRG5kP180NGA+PV82BFVXM00sAAEAKP8eAM0AEAATAABXFBYzMjY3FQYGIyImNTQ2NxcGBmcaGA4dCQsgFCs7MDkoIjB2GRoFBDgDBzEtI0gpEB05////rf8eAFIAEAQGAYCFAP//ADX/9gIhAv4GJgF7AAAABwFTAJAAAP//ADX/9gIhAv4GJgF7AAAABgFcRgAAAQBPAAABdQLKAA0AAGEjETQ0NjcGBgcHJzczAXVaAQENFhBrMNZQAeQWLy8RDBQMUjukAAIAIwF+AS4C0gAcACcAAFMyFhUVIycGBiMiJiY1NDY2Nzc1NCYjIgYHJzY2FwYGFRQWMzI2NTW6Nz0sCw8zKB8wGyNINSwhIBkuGhQcPTE0LR8dKSgC0js43DUbHxYsISQsFwICFCEfDQ0tDhGxAx0eGRsyKBoAAAIAIAF8AVEC1AAMABgAAEEUBiMiJjU0NjMyFhYHFBYzMjY1NCYjIgYBUU9KR1FTRzFDI/ItLC4rKS4sLwIoTGBhS1FbLE0zNkFCNTREPwAAAwA1/9oCKwI7ABgAIgAtAABBFAYGIyImJwcnNyYmNTQ2MzIWFzcXBxYWBRQWFxMmJiMiBgU0JicDFhYzMjY2Ais5cFMsRhs4KzkgI4d4KkQaMSsyIiP+Xw4P7hIwIFRVAUwPEe0TMyE7SSIBDVJ/RhkVSh1MJWc+gpQVFEEdQSVqQSdDGgE4DxJvZihGGv7JExQ2YAD//wA1//YCIQLhBiYBewAAAAYBs1IAAAH//QL4AfcDNQADAABBITUhAff+BgH6Avg9AAACAFL/FQIqAiMAGAAoAABBMhYVFAYGIyImJicjFhYVFSMRMxczPgIXIgYGFRUUFhYzMjY2NTQmAVtkazVgQi9EKwsEAgJYSAsFDC5HFTJDISFBLjBDI0kCI4yHWn9BHS4cHTkf0wMEaR80IEcvWUAIRVstLl1HaWIAAAEATv+BAhwC+AASAABFIxEjESMRBgYjIiYmNTQ2NjMhAhwzcDQPHhY5USotWD4BC38DPfzDAcMEBTVkR0xiLwABACj/YgEGAtIAEAAAUzQ2NjczBgYVFBYWFyMuAigfQC9QSUUeQDBQL0AfARZWoYw5W+V7UZuNPDmKnAABACH/YgD/AtIAEQAAUxQGBgcjPgI1NCYmJzMeAv8gPjBQMT8eHkAwUDA+IAEbVaCMODyOnVJRm449OoucAAUALP/3AycC1AALABcAGwAnADMAAFMyFhUUBiMiJjU0NhciBhUUFjMyNjU0JiUBIwETMhYVFAYjIiY1NDYXIgYVFBYzMjY1NCbGS1BRS0hRUUooKykpKygnAaH+dEgBjEFLUFFLSFFRSigrKigrKCYC1HNsbnN0bW1yPFNRUFRVT09VMv02Asr+7XNsb3J0bW1yPFNRUFVWT09VAAEARf/3ALIAYwALAAB3NDYzMhYVFAYjIiZFHRoaHBwaGh0tGxsbGxsbGwD//wBFARIAsgF/BgcBjwAAARwAAQAzAHcCDAJMAAsAAEEzFSMVIzUjNTM1MwFAzMxAzc1AAYFAyspAywAAAgAz/xUCCwIjABYAJAAARTQ2NyMGBiMiJjU0NjYzMhYXMzczESMDMjY2NTU0JiMiBhUUFgGzAgIEEVtFYm0wYkhCUxMDCEtYlDdDIEVMTU9KAhY7GDFBj4dTfkc6Klr8/AEoL1pAD2BnbWVoZQACABj/9wGgAtQAHwArAAB3NDY2Nz4CNTQmIyIGByc2NjMyFhUUBgYHDgIVFSMHNDYzMhYVFAYjIiaQDiYjIi4VRTclSyggMFg1Xm0dOCkbIA9IDx0aGhwcGhod4yo6LhgYKjAiNjUUFUMXF1lULUU3GxMjLiMRnhsbGxsbGxsAAAIAIf9HAaoCJQAfACsAAEEUBgYHDgIVFBYzMjY3FwYGIyImNTQ2Njc+AjU1MzcUBiMiJjU0NjMyFgExDiUjIy0WRjclSikgMFg1Xm4dOSgcIA9HDx0ZGxwcGxkdATkqOy0YGCswIjY1FBVCFxhaUy5EOBsSIy8iEZ4bGxsbGxwcAAACAEQByAFJAsoAAwAHAABTAyMDIQMjA5cKPwoBBQo/CgLK/v4BAv7+AQIA//8AIf97AV8AfwQHAZgAEP21AAIAEgHGAVACygAKABUAAEEOAgcjJz4CNyMOAgcjJz4CNwFQDRcRBEsHBxkdEHYMGBEESwYHGB4QAsonXVslCShYWCMnXVslCShYWCMAAAIAEQHGAU8CygAKABYAAEEOAgcjPgI3MwcOAgcjPgM3MwFPBxgeED4OFxEES60HGR0RPQoSDwsDSwLAJ1lXIydcWyYKJ1lXIx1DRkIcAAEAEgHGAJwCygAKAABTPgI3Mw4CByMSBxgeED0MGBEESwHPKFhYIyddWyUAAQARAcYAnALKAAsAAFMOAgcjPgM3M5wHGR0RPQoSDwsDSwLAJ1lXIx1DRkIc//8AIf97AKwAfwQHAZoAEP21AAEARAHIAJcCygADAABTAyMDlwo/CgLK/v4BAgABAFIAAAGMAiIAFQAAQTIWFwcmJiMiDgIVESMRMxczPgIBRBUlDgoQHxghNScUWEQMBQwsPwIiBQRSAwUVLEEt/uACGWAeLxwA//8AUgAAAYwC/gYmAZ0AAAAGAQdrAP//ADIAAAGMAvwGJgGdAAAABgEhCgAABAAw//cDDQLTAA0AFgAqAD4AAGURMzIWFRQGBxcjJyMVNzI2NTQmIyMVEyIuAjU0PgIzMh4CFRQOAicyPgI1NC4CIyIOAhUUHgIBGX1OUjAka0dfTTkrNzUrPEZQhmM2OWSFTVCGYjY4ZIZMRHRVLy9VdERFc1YwLlR1kwGqPT8yOQ22q6vZJywpI5/+izhkhU1PhWM3OmWFSk2FZDguMlh0QkN0WDExVnVEQ3RYMQACACgCYAEIAzoACwAXAABTIiY1NDYzMhYVFAYnMjY1NCYjIgYVFBaYL0FAMC5CQi4bIyUZGyUjAmA8MTE8Pi8xPC4lGhskJBsaJQD///+MAmAAbAM6BAcBof9kAAAAAQAp//YBtAIjACoAAGUUBgYjIiYnNRYWMzI2NTQmJicuAjU0NjMyFhcHJiYjIgYVFBYWFx4CAbQtXkk4WyQsYChFPSJBLS5HJ2xbMlcnGiFSIzU9ID0qLksslC9IJxIPTBUULSgdJBoPECM5L0ZJExE+EBIlJR4hFg8QJTr//wAp//YBtAL+BiYBowAAAAcBBwCFAAD//wAp//YBtAL8BiYBowAAAAYBISQA//8AKf8QAbQCIwYmAaMAAAAHASYAfAAA//8AKf8jAbQCIwYmAaMAAAAHAS0A7QAAAAIAPv/7AbYC+wA2AEQAAFM0NjcmJjU0NjMyFhcHJiYjIgYVFBYWFx4CFRQGBxYWFRQGIyImJzUeAjMyNjU0JiYnLgI3FBYWFxc2NjU0JicGBkc4KSgxYVYvVCEYHUwjNTweNyUwSywxIyErY2M0Vx8bOjobRTsfOCguSipFHzcjKxwlSUgiMgGKLTwREzQrPUgTDzcPEycnGSAXDREmNisxQBQRNis/UBUPPw0UCzAnGyMaDREkODUfJRoODg0zIiwxFgsqAAIAIv97ALMCHwALABcAAHcOAgcjPgM3MwM0NjMyFhUUBiMiJqwIFxsPQQoQDQsDUGEdGRscHBsZHXQlWVckJERBPxwBaRscHBsbGxsAAAEAMwAAAg4CygAGAABzASE1IRUBmQEV/oUB2/7oAn5MNf1rAAIAN//2AhEC1QAhADAAAFM0PgMzMhYXFSYmIyIGBgczPgIzMhYVFAYGIyIuAhcyNjU0JiMiBgYVFB4CNxkzTmpDGzUUEzIgTGw6AwQNL0kyYW02Z0c9XT0f9EVKREcwRiYOIjsBL1CFZkckBgVJBgZAhmoaMB52Z0ltPDBVcq5YUEZQJzscGkE9KAAAAQAK//wBZgLOAAMAAEEBIwEBZv71UQELAs79LgLSAAABAC0AAAIZAtQAIwAAQTIWFwcmJiMiBhUVMxUjFRQGBgchFSE1PgI1NSM1MzU0NjYBWzJSIxojPyM4PLu7FiQVAXn+FCQvGGFhL1cC1BMORQ4OQ0pyQ20pOSMLS0gKIzorbkN3R10uAAEAEP/2AVcClQAYAABlMjY3FQYGIyImJjURIzU3NzMVMxUjERQWAQMZKBMWMSUxPx9MUhY8n58jPgkHRAgMI0o5ATgrGX18Rf7PMTQA//8AEP/2AdIC+AYmAa4AAAAHAdMAnwAA//8AEP8jAVcClQYmAa4AAAAHAS0A2gAAAAIAUv8VAioC+AAbACkAAEEUBgYjIiYmJyMWFhUVIxEzFRQGBzM+AjMyFgc0JiMiBgcVFBYzMjY2Aio1YEMtQywMBAICWFgDAgULL0cwYm1aR0hMSgFMRTFCIgEQWn9BHC8bGjka2gPj0h5AFR4zH4yGZmVpXwhoZTBdAAABACr/9gIAAtQALgAAQRQGBgcVFhYVFAYGIyImJzUWFjMyNjU0JiYjIzUzMjY2NTQmIyIGBgcnNjYzMhYB6ilFLFRcO3VZP2UpKmcyXlguWEFERTVTLko+I0E4GSYsbkxhcwIqMEovCgILVk47XzYXEk0UGUtALzsaRh07LTo3EBsSPiApWQAAAQAoAmUBjQLhABkAAFM+AzMyHgIzMjY3MwYGIyIuAiMiBgcoAhAaJBYXJiQkFBEgBDEEOCoXKCQjFBAfBQJlIS8dDxQZFBkoQDwTGRQYKP///gQCZf9pAuEEBwGz/dwAAAACAAYBagKJAsoAFAAcAABBETMTEzMRIzU0NjcjAyMDIxYWFRUjESM1MxUjEQEqTWJnSTQBAQNmLWIDAQH0ZP1lAWoBYP7lARv+oL0aLhr+4QEhGS0awQEwMDD+0AAAAQAwAAACAALUAB0AAGEhNTc+AjU0JiMiBgcnPgIzMhYWFRQGBgcHFSECAP4wzTNAHkU7J1IqMSBETC0/XTQoTjiVAVw+1jVPSSw7QCMiOxsmFTBVODxgWzebAwABAEz/9gIPAhkAFwAAQREjJyMOAiMiJiY1ETMRFBYzMjY2NRECD0MLBg0ySC86UyxYPTwxRSQCGf3nXx0wHCtYQQFf/rlLSSxWQgEXAP//AEz/9gIPAv4GJgG3AAAABwEHAMgAAP//AEz/9gIPAvwGJgG3AAAABgEpZwD//wBM//YCDwLbBiYBtwAAAAYBMwoA//8ATP/2Ag8C/gYmAbcAAAAHAVMAlQAA//8ATP/2Ag8C/gYmAbcAAAAGAVxMAP//AEz/9gIPAp0GJgG3AAAABgHVdwAAAf/+/3IBsv+vAAMAAEUhNSEBsv5MAbSOPf//AEz/HgIVAhkGJgG3AAAABwGAAUgAAP//AEz/9gIPAzoGJgG3AAAABwGhAJkAAAABAAAAAAHyAhkADQAAcwMzExYWFzM2NjcTMwPPz1yBCA0FAgYMCYJczwIZ/pIVKhYWKBcBbv3nAAEAD///AvMCGQAoAABBLgInIw4CBwMjAzMTHgIXMz4DNxMzEx4CFzM+AjcTMwMjAaMFCwkEAgQKCgZmWZhYUwcKCQICAgcICgVhXFwHCwsDAgIICgZRVZFaAU0VKygRESorFf60Ahr+yBwwLBQPIiMjEQE8/sQXMC0UFC4xGQE4/eYA//8AD///AvMC/gYmAcIAAAAHAQcBGAAA//8AD///AvMC/AYmAcIAAAAHASkAtwAA//8AD///AvMC2wYmAcIAAAAGATNaAP//AA///wLzAv4GJgHCAAAABwFTAOUAAAABABIAAAIDAhkACwAAUwMzFzczAxMjJwcjzrNmiYpls71llJNlARQBBc7O/vv+7N3dAAEAAP8OAfICGQAdAABRMxMeAhczNjY3EzMDDgIjIiYnNRYWMzI2Njc3XHkIDQoDAwYRDHta7hQwQjASHw4NGxAcJx0OGgIZ/qsXJiENFTMgAVj9kjRGIwUESQQFGC8jRgD//wAA/w4B8gL+BiYByAAAAAcBBwCQAAD//wAA/w4B8gL8BiYByAAAAAYBKS8A//8AAP8OAfIC2wYmAcgAAAAGATPRAAABABEAAAIvAsoAFgAAQRMzAzMVIxUzFSMVIzUjNTM1IzUzAzMBIbFd2I2amppTm5ubi9ZdAYIBSP6JNls2jIw2WzYBdwD//wAA/w4B8gL+BiYByAAAAAYBU1wAAAEAIwAAAbYCGQAJAABhITUBITUhFQEhAbb+bQEo/u0BfP7bASc0AZ9GNf5iAP//ACMAAAG2Av4GJgHOAAAABwEHAIUAAP//ACMAAAG2AvwGJgHOAAAABgEhJAD//wAjAAABtgLmBiYBzgAAAAcBNwCQAAAAAgA0//YCDALVABAAIAAAQRQOAiMiJiY1NDY2MzIWFgUUFhYzMjY2NTQmJiMiBgYCDBw5WT5NajUtaVdWZy7+gR9BMzVBHRk/OjlBGgFnWoleMFOkemylXVulbmSDQUGDZFqDR0mDAAABALgCWAEzAvgADAAAQQ4CByM1PgM3MwEzCRUYEDUFDAsKAlMC8BkyMxoJDSYrKRAAAAEAtwJcATAC/AAKAABBDgIHIzU2NjczATAGEA0DUw4gFjUC8xE3ORYIJkwmAAABACgCYwFNAp0AAwAAQRUhNQFN/tsCnTo6`;

--- src\hooks\useTree.jsx ---
// src/hooks/useTree.jsx
import React, { useState, useEffect, useCallback, useMemo } from "react";
import { LOCAL_STORAGE_KEY } from "../utils/constants";
import {
  sortItems,
  handleDrop as treeHandleDropUtil,
  deleteItemRecursive,
  renameItemRecursive,
  insertItemRecursive,
  isSelfOrDescendant,
  findItemById,
  findParentAndSiblings,
  hasSiblingWithName,
  getItemPath,
} from "../utils/treeUtils";
import { jsPDF } from "jspdf";
import * as bidiNS from "unicode-bidirectional";
import { notoSansHebrewBase64 } from "../fonts/NotoSansHebrewBase64";
import { useSettings } from "../contexts/SettingsContext";
import { itemMatches } from "../utils/searchUtils";
import { useUndoRedo } from "./useUndoRedo";

const API_BASE_URL =
  import.meta.env.VITE_API_BASE_URL || "http://localhost:5001/api";

const getAuthToken = () => {
  return localStorage.getItem("userToken");
};

const embeddingLevels = bidiNS.embeddingLevels || bidiNS.getEmbeddingLevels;
const reorder = bidiNS.reorder || bidiNS.getReorderedString;

function htmlToPlainTextWithNewlines(html) {
  if (!html) return "";
  let text = html;
  text = text.replace(
    /<(div|p|h[1-6]|li|blockquote|pre|tr|hr)[^>]*>/gi,
    "\n$&"
  );
  text = text.replace(/<br\s*\/?>/gi, "\n");
  text = text.replace(/<[^>]+>/g, "");
  try {
    const tempDiv = document.createElement("div");
    tempDiv.innerHTML = text;
    text = tempDiv.textContent || tempDiv.innerText || "";
  } catch (e) {
    console.error("Error decoding HTML entities for PDF export:", e);
  }
  return text.trim().replace(/(\r\n|\r|\n){2,}/g, "\n");
}

export const assignNewIds = (item, isDuplication = false) => {
  // Ensure this line is correct
  const newItem = { ...item };
  if (
    isDuplication ||
    !item.id ||
    item.id.startsWith("temp-") ||
    item.id.startsWith("client-")
  ) {
    newItem.id = `client-${Date.now().toString(36)}-${Math.random()
      .toString(36)
      .substring(2, 9)}`;
  }
  if (item.type === "folder") {
    newItem.children = Array.isArray(item.children)
      ? item.children.map((child) => assignNewIds(child, isDuplication))
      : [];
  }
  return newItem;
};

export const useTree = () => {
  const EXPANDED_KEY = `${LOCAL_STORAGE_KEY}_expanded`;
  const { settings } = useSettings();

  const initialTreeState = (() => {
    try {
      const stored = localStorage.getItem(LOCAL_STORAGE_KEY);
      const parsed = stored ? JSON.parse(stored) : [];
      return Array.isArray(parsed) ? parsed : [];
    } catch (error) {
      console.error("Failed to load tree from localStorage:", error);
      return [];
    }
  })();

  const {
    state: tree,
    setState: setTreeWithUndo,
    resetState: resetTreeHistory,
    undo: undoTreeChange,
    redo: redoTreeChange,
    canUndo: canUndoTree,
    canRedo: canRedoTree,
  } = useUndoRedo(initialTreeState);

  const [selectedItemId, setSelectedItemId] = useState(null);
  const [contextMenu, setContextMenu] = useState({
    visible: false,
    x: 0,
    y: 0,
    item: null,
    isEmptyArea: false,
  });
  const [expandedFolders, setExpandedFolders] = useState(() => {
    try {
      const stored = localStorage.getItem(EXPANDED_KEY);
      return stored ? JSON.parse(stored) : {};
    } catch {
      return {};
    }
  });
  const [draggedId, setDraggedId] = useState(null);
  const [clipboardItem, setClipboardItem] = useState(null);
  const [clipboardMode, setClipboardMode] = useState(null);
  const [cutItemId, setCutItemId] = useState(null);
  const [isFetchingTree, setIsFetchingTree] = useState(false); // For loading state

  const selectedItem = useMemo(
    () => findItemById(tree, selectedItemId),
    [tree, selectedItemId]
  );

  const fetchUserTreeInternal = useCallback(
    async (token) => {
      if (!token) {
        console.log(
          "fetchUserTreeInternal: No token provided, clearing/resetting tree."
        );
        resetTreeHistory([]); // Or load from localStorage if preferred for logged-out
        setIsFetchingTree(false);
        return;
      }
      setIsFetchingTree(true);
      console.log(
        "fetchUserTreeInternal: Token found, fetching tree from server."
      );
      try {
        const response = await fetch(`${API_BASE_URL}/items/tree`, {
          headers: { Authorization: `Bearer ${token}` },
        });
        console.log(
          "fetchUserTreeInternal: fetchTreeFromServer response status:",
          response.status
        );
        if (!response.ok) {
          const errorData = await response
            .json()
            .catch(() => ({ error: "Failed to parse error response" }));
          if (response.status === 401) {
            console.error(
              "fetchUserTreeInternal: Unauthorized (401). Token might be invalid."
            );
            localStorage.removeItem("userToken"); // Critical: remove invalid token
            // Consider calling a global logout handler if App.jsx passes one down
          } else {
            console.error(
              "fetchUserTreeInternal: Server error fetching tree:",
              response.status,
              errorData
            );
          }
          resetTreeHistory([]); // Clear tree on error
          setIsFetchingTree(false);
          return; // Explicitly return on error
        }
        const data = await response.json();
        if (data && Array.isArray(data.notesTree)) {
          console.log(
            "fetchUserTreeInternal: Successfully fetched tree, resetting local state."
          );
          resetTreeHistory(data.notesTree);
        } else {
          console.warn(
            "fetchUserTreeInternal: Fetched tree data is not in expected format, using empty tree."
          );
          resetTreeHistory([]);
        }
      } catch (error) {
        console.error(
          "fetchUserTreeInternal: Network or other error fetching tree:",
          error
        );
        resetTreeHistory([]); // Clear tree on error
      } finally {
        setIsFetchingTree(false);
      }
    },
    [resetTreeHistory]
  ); // API_BASE_URL is stable

  // Effect for initial load and when token changes (e.g., after login)
  // This will be triggered by App.jsx calling fetchUserTree after login.
  // For initial load, App.jsx will also call this if a token is found.
  // The useEffect that was here before is effectively replaced by App.jsx controlling the fetch.

  useEffect(() => {
    // Persist tree to localStorage
    try {
      if (Array.isArray(tree))
        localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(tree));
    } catch (error) {
      console.error("Failed to save tree to localStorage:", error);
    }
  }, [tree]);

  useEffect(() => {
    // Persist expanded folders
    try {
      localStorage.setItem(EXPANDED_KEY, JSON.stringify(expandedFolders));
    } catch (error) {
      console.error("Failed to save expanded folders:", error);
    }
  }, [expandedFolders]);

  const selectItemById = useCallback((id) => setSelectedItemId(id), []);
  const replaceTree = useCallback(
    (newTreeData) => {
      if (Array.isArray(newTreeData)) {
        resetTreeHistory(newTreeData);
        setSelectedItemId(null);
        setExpandedFolders({});
        return { success: true };
      }
      console.error("replaceTree failed: Data is not an array.", newTreeData);
      return { success: false, error: "Import failed: Invalid data format." };
    },
    [resetTreeHistory]
  );

  const expandFolderPath = useCallback(
    /* ... (Your existing robust expandFolderPath) ... */
    (itemIdToExpand) => {
      if (!itemIdToExpand) return;
      const pathIds = [];
      const findPathRecursive = (nodes, targetId, currentPathSegmentsIds) => {
        for (const node of nodes) {
          if (!node || !node.id) continue;
          if (node.id === targetId) {
            pathIds.push(...currentPathSegmentsIds, node.id);
            return true;
          }
          if (node.type === "folder" && Array.isArray(node.children)) {
            if (
              findPathRecursive(node.children, targetId, [
                ...currentPathSegmentsIds,
                node.id,
              ])
            ) {
              return true;
            }
          }
        }
        return false;
      };
      findPathRecursive(tree, itemIdToExpand, []);
      setExpandedFolders((prev) => {
        const next = { ...prev };
        let changed = false;
        pathIds.forEach((id) => {
          const item = findItemById(tree, id);
          if (item && item.type === "folder" && !next[id]) {
            next[id] = true;
            changed = true;
          }
        });
        const targetItem = findItemById(tree, itemIdToExpand);
        if (
          targetItem &&
          targetItem.type === "folder" &&
          !next[itemIdToExpand]
        ) {
          next[itemIdToExpand] = true;
          changed = true;
        }
        return changed ? next : prev;
      });
    },
    [tree]
  );

  const toggleFolderExpand = useCallback((id, forceState) => {
    if (!id) return;
    setExpandedFolders((prev) => ({
      ...prev,
      [id]: forceState !== undefined ? Boolean(forceState) : !prev[id],
    }));
  }, []);

  const addItem = useCallback(
    /* ... (Your existing addItem with API calls) ... */
    async (newItemData, parentId) => {
      const trimmedLabel = newItemData?.label?.trim();
      if (!trimmedLabel) return { success: false, error: "Label is required." };
      if (!["folder", "note", "task"].includes(newItemData.type))
        return { success: false, error: "Invalid item type." };
      const token = getAuthToken();
      if (!token) return { success: false, error: "Authentication required." };
      const payload = { label: trimmedLabel, type: newItemData.type };
      if (newItemData.type === "note" || newItemData.type === "task")
        payload.content = newItemData.content || "";
      if (newItemData.type === "task")
        payload.completed = !!newItemData.completed;
      try {
        const endpoint = parentId
          ? `${API_BASE_URL}/items/${parentId}`
          : `${API_BASE_URL}/items`;
        const response = await fetch(endpoint, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            Authorization: `Bearer ${token}`,
          },
          body: JSON.stringify(payload),
        });
        const responseData = await response.json();
        if (!response.ok)
          return {
            success: false,
            error:
              responseData.error || `Failed to add item: ${response.status}`,
          };
        const createdItemFromServer = responseData;
        const newTreeState = insertItemRecursive(
          tree,
          parentId,
          createdItemFromServer
        );
        setTreeWithUndo(newTreeState);
        if (parentId && settings.autoExpandNewFolders) {
          setTimeout(() => expandFolderPath(parentId), 0);
        } else if (
          !parentId &&
          createdItemFromServer.type === "folder" &&
          settings.autoExpandNewFolders
        ) {
          setTimeout(() => expandFolderPath(createdItemFromServer.id), 0);
        } // Expand new root folder
        return { success: true, item: createdItemFromServer };
      } catch (error) {
        console.error("addItem API error:", error);
        return { success: false, error: "Network error adding item." };
      }
    },
    [tree, setTreeWithUndo, expandFolderPath, settings.autoExpandNewFolders]
  );

  const updateNoteContent = useCallback(
    /* ... (Your existing updateNoteContent with API calls) ... */
    async (itemId, content) => {
      const token = getAuthToken();
      if (!token) return { success: false, error: "Authentication required." };
      try {
        const response = await fetch(`${API_BASE_URL}/items/${itemId}`, {
          method: "PATCH",
          headers: {
            "Content-Type": "application/json",
            Authorization: `Bearer ${token}`,
          },
          body: JSON.stringify({ content }),
        });
        const updatedItemFromServer = await response.json();
        if (!response.ok)
          return {
            success: false,
            error: updatedItemFromServer.error || "Failed to update note.",
          };
        const mapRecursive = (items, id, serverUpdates) =>
          items.map((i) =>
            i.id === id
              ? { ...i, ...serverUpdates }
              : Array.isArray(i.children)
              ? { ...i, children: mapRecursive(i.children, id, serverUpdates) }
              : i
          );
        const newTreeState = mapRecursive(tree, itemId, updatedItemFromServer);
        setTreeWithUndo(newTreeState);
        return { success: true, item: updatedItemFromServer };
      } catch (error) {
        console.error("updateNoteContent API error:", error);
        return { success: false, error: "Network error updating note." };
      }
    },
    [tree, setTreeWithUndo]
  );

  const updateTask = useCallback(
    /* ... (Your existing updateTask with API calls) ... */
    async (taskId, clientUpdates) => {
      const token = getAuthToken();
      if (!token) return { success: false, error: "Authentication required." };
      try {
        const response = await fetch(`${API_BASE_URL}/items/${taskId}`, {
          method: "PATCH",
          headers: {
            "Content-Type": "application/json",
            Authorization: `Bearer ${token}`,
          },
          body: JSON.stringify(clientUpdates),
        });
        const updatedItemFromServer = await response.json();
        if (!response.ok)
          return {
            success: false,
            error: updatedItemFromServer.error || "Failed to update task.",
          };
        const mapRecursiveTask = (items, id, serverUpdates) =>
          items.map((i) =>
            i.id === id && i.type === "task"
              ? { ...i, ...serverUpdates }
              : Array.isArray(i.children)
              ? {
                  ...i,
                  children: mapRecursiveTask(i.children, id, serverUpdates),
                }
              : i
          );
        const newTreeState = mapRecursiveTask(
          tree,
          taskId,
          updatedItemFromServer
        );
        setTreeWithUndo(newTreeState);
        return { success: true, item: updatedItemFromServer };
      } catch (error) {
        console.error("updateTask API error:", error);
        return { success: false, error: "Network error updating task." };
      }
    },
    [tree, setTreeWithUndo]
  );

  const renameItem = useCallback(
    /* ... (Your existing renameItem with API calls) ... */
    async (itemId, newLabel) => {
      const trimmedLabel = newLabel?.trim();
      if (!trimmedLabel || !itemId)
        return { success: false, error: "Invalid ID or name." };
      const token = getAuthToken();
      if (!token) return { success: false, error: "Authentication required." };
      const { parentArray } = findParentAndSiblings(tree, itemId);
      if (hasSiblingWithName(parentArray || [], trimmedLabel, itemId)) {
        return {
          success: false,
          error: `Item "${trimmedLabel}" already exists.`,
        };
      }
      try {
        const response = await fetch(`${API_BASE_URL}/items/${itemId}`, {
          method: "PATCH",
          headers: {
            "Content-Type": "application/json",
            Authorization: `Bearer ${token}`,
          },
          body: JSON.stringify({ label: trimmedLabel }),
        });
        const updatedItemFromServer = await response.json();
        if (!response.ok)
          return {
            success: false,
            error: updatedItemFromServer.error || "Rename failed.",
          };
        const newTreeState = renameItemRecursive(
          tree,
          itemId,
          updatedItemFromServer.label
        );
        setTreeWithUndo(newTreeState);
        return { success: true, item: updatedItemFromServer };
      } catch (error) {
        console.error("renameItem API error:", error);
        return { success: false, error: "Network error renaming." };
      }
    },
    [tree, setTreeWithUndo]
  );

  const deleteItem = useCallback(
    /* ... (Your existing deleteItem with API calls) ... */
    async (idToDelete) => {
      if (!idToDelete) return { success: false, error: "No ID for deletion." };
      const token = getAuthToken();
      if (!token) return { success: false, error: "Authentication required." };
      try {
        const response = await fetch(`${API_BASE_URL}/items/${idToDelete}`, {
          method: "DELETE",
          headers: { Authorization: `Bearer ${token}` },
        });
        if (!response.ok && response.status !== 404) {
          const errorData = await response.json().catch(() => ({}));
          return {
            success: false,
            error: errorData.error || "Delete failed on server.",
          };
        }
        const newTreeState = deleteItemRecursive(tree, idToDelete);
        setTreeWithUndo(newTreeState);
        if (selectedItemId === idToDelete) setSelectedItemId(null);
        setExpandedFolders((prev) => {
          const next = { ...prev };
          if (prev.hasOwnProperty(idToDelete)) delete next[idToDelete];
          return next;
        });
        // setContextMenu((m) => (m.visible ? { ...m, visible: false } : m)); // Usually handled by App.jsx
        return { success: true };
      } catch (error) {
        console.error("deleteItem API error:", error);
        return { success: false, error: "Network error deleting." };
      }
    },
    [tree, selectedItemId, setTreeWithUndo /* setContextMenu not a direct dep*/]
  );

  const duplicateItem = useCallback(
    /* ... (Your existing duplicateItem, ensure it calls addItem for DB persistence) ... */
    async (itemId) => {
      const itemToDuplicate = findItemById(tree, itemId);
      if (!itemToDuplicate)
        return { success: false, error: "Item to duplicate not found." };
      const { parent } = findParentAndSiblings(tree, itemId);
      const parentId = parent?.id ?? null;
      let newDuplicate = assignNewIds(structuredClone(itemToDuplicate), true);
      let baseName = itemToDuplicate.label;
      let newLabel = `${baseName} (copy)`;
      let counter = 1;
      const targetSiblings = parentId
        ? findItemById(tree, parentId)?.children || []
        : tree;
      while (hasSiblingWithName(targetSiblings, newLabel, null)) {
        counter++;
        newLabel = `${baseName} (copy ${counter})`;
      }
      newDuplicate.label = newLabel;
      const result = await addItem(newDuplicate, parentId);
      if (result.success && result.item) {
        if (parentId && settings.autoExpandNewFolders) {
          setTimeout(() => expandFolderPath(parentId), 0);
        }
        return { success: true, item: result.item };
      } else {
        return {
          success: false,
          error: result.error || "Failed to save duplicated item.",
        };
      }
    },
    [tree, addItem, settings.autoExpandNewFolders, expandFolderPath]
  );

  const handleDrop = useCallback(
    /* ... (Your existing handleDrop, still mostly client-side for DB) ... */
    async (targetFolderId, droppedItemId) => {
      console.warn(
        "useTree: handleDrop (moving items) is client-side for DB persistence. Needs server endpoint."
      );
      const currentDraggedId = droppedItemId || draggedId;
      setDraggedId(null);
      if (!currentDraggedId || targetFolderId === currentDraggedId)
        return { success: false, error: "Invalid drop." };
      const itemToDrop = findItemById(tree, currentDraggedId);
      const targetFolder = findItemById(tree, targetFolderId);
      if (!itemToDrop || !targetFolder || targetFolder.type !== "folder")
        return { success: false, error: "Invalid item or target folder." };
      if (
        itemToDrop.type === "folder" &&
        isSelfOrDescendant(tree, itemToDrop.id, targetFolderId)
      ) {
        return {
          success: false,
          error: "Cannot drop folder into itself or one of its descendants.",
        };
      }
      if (
        hasSiblingWithName(targetFolder.children || [], itemToDrop.label, null)
      ) {
        return {
          success: false,
          error: `Item named "${itemToDrop.label}" already exists in the target folder.`,
        };
      }
      const newTreeState = treeHandleDropUtil(
        tree,
        targetFolderId,
        currentDraggedId
      );
      if (newTreeState) {
        setTreeWithUndo(newTreeState);
        if (settings.autoExpandNewFolders && targetFolderId) {
          setTimeout(() => expandFolderPath(targetFolderId), 0);
        }
        return {
          success: true,
          message:
            "Local drop successful. Server persistence for item move not yet implemented.",
        };
      }
      return { success: false, error: "Local drop simulation failed." };
    },
    [
      tree,
      draggedId,
      setTreeWithUndo,
      settings.autoExpandNewFolders,
      expandFolderPath,
      treeHandleDropUtil,
    ]
  );

  const copyItem = useCallback(
    /* ... (Your existing copyItem) ... */
    (itemId) => {
      const itemToCopy = findItemById(tree, itemId);
      if (itemToCopy) {
        try {
          const deepCopy = structuredClone(itemToCopy);
          setClipboardItem(deepCopy);
          setClipboardMode("copy");
          setCutItemId(null);
        } catch (e) {
          console.error("Error copying item:", e);
          setClipboardItem(null);
          setClipboardMode(null);
          setCutItemId(null);
        }
      }
    },
    [tree]
  );

  const cutItem = useCallback(
    /* ... (Your existing cutItem) ... */
    (itemId) => {
      const itemToCut = findItemById(tree, itemId);
      if (itemToCut) {
        try {
          const deepCopy = structuredClone(itemToCut);
          setClipboardItem(deepCopy);
          setClipboardMode("cut");
          setCutItemId(itemId);
        } catch (e) {
          console.error("Error cutting item:", e);
          setClipboardItem(null);
          setClipboardMode(null);
          setCutItemId(null);
        }
      }
    },
    [tree]
  );

  const pasteItem = useCallback(
    /* ... (Your existing pasteItem, 'copy' uses addItem, 'cut' is client-side for DB) ... */
    async (targetFolderId) => {
      console.warn(
        "useTree: pasteItem: 'cut' persistence needs backend. 'copy' uses addItem."
      );
      if (!clipboardItem)
        return { success: false, error: "Clipboard is empty." };
      const targetParent = targetFolderId
        ? findItemById(tree, targetFolderId)
        : null;
      if (targetFolderId && (!targetParent || targetParent.type !== "folder")) {
        return {
          success: false,
          error: "Target for paste must be a valid folder or root.",
        };
      }
      if (
        clipboardItem.type === "folder" &&
        isSelfOrDescendant(tree, clipboardItem.id, targetFolderId)
      ) {
        return {
          success: false,
          error: "Cannot paste a folder into itself or one of its descendants.",
        };
      }
      const targetSiblings = targetFolderId
        ? targetParent?.children || []
        : tree;
      let itemToInsert = structuredClone(clipboardItem);
      if (clipboardMode === "copy") {
        itemToInsert = assignNewIds(itemToInsert, true);
        let baseName = itemToInsert.label;
        let newLabel = baseName;
        let copyCounter = 0;
        while (hasSiblingWithName(targetSiblings, newLabel, null)) {
          copyCounter++;
          newLabel = `${baseName} (copy${
            copyCounter > 1 ? ` ${copyCounter}` : ""
          })`;
        }
        itemToInsert.label = newLabel;
        const addResult = await addItem(itemToInsert, targetFolderId);
        if (
          addResult.success &&
          targetFolderId &&
          settings.autoExpandNewFolders
        )
          expandFolderPath(targetFolderId);
        return addResult;
      } else if (clipboardMode === "cut" && cutItemId) {
        if (
          cutItemId === targetFolderId &&
          findParentAndSiblings(tree, cutItemId)?.parent?.id === targetFolderId
        ) {
          setClipboardItem(null);
          setClipboardMode(null);
          setCutItemId(null);
          return {
            success: true,
            item: itemToInsert,
            message: "Item 'pasted' in the same location.",
          };
        }
        if (
          findParentAndSiblings(tree, cutItemId)?.parent?.id !==
            targetFolderId &&
          hasSiblingWithName(targetSiblings, itemToInsert.label, null)
        ) {
          // Check if name exists unless it's the same item not changing name context
          return {
            success: false,
            error: `An item named "${itemToInsert.label}" already exists in the target folder.`,
          };
        }
        console.warn(
          "Cut & Paste: Persistence of item move not fully implemented on backend. Simulating client-side."
        );
        let tempTree = deleteItemRecursive(tree, cutItemId);
        tempTree = insertItemRecursive(tempTree, targetFolderId, itemToInsert);
        setTreeWithUndo(tempTree);
        setClipboardItem(null);
        setClipboardMode(null);
        setCutItemId(null);
        if (targetFolderId && settings.autoExpandNewFolders)
          expandFolderPath(targetFolderId);
        return {
          success: true,
          item: itemToInsert,
          message:
            "Item moved locally. Server persistence for move needs to be implemented.",
        };
      }
      return { success: false, error: "Invalid paste operation." };
    },
    [
      tree,
      clipboardItem,
      clipboardMode,
      cutItemId,
      setTreeWithUndo,
      settings.autoExpandNewFolders,
      expandFolderPath,
      addItem,
    ]
  );

  const handleExport = useCallback(
    /* ... (Your existing handleExport, no DB interaction) ... */
    (target, format) => {
      let dataToExport;
      let fileName;
      const currentSelectedItem = findItemById(tree, selectedItemId);
      if (target === "selected") {
        if (!currentSelectedItem) {
          alert("No item selected.");
          return;
        }
        dataToExport = currentSelectedItem;
        fileName = `${currentSelectedItem.label}-export`;
      } else {
        dataToExport = tree;
        fileName = "tree-export";
      }
      if (format === "json") {
        try {
          const jsonStr = JSON.stringify(dataToExport, null, 2);
          const blob = new Blob([jsonStr], { type: "application/json" });
          const url = URL.createObjectURL(blob);
          const a = document.createElement("a");
          a.href = url;
          a.download = fileName + ".json";
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(url);
        } catch (error) {
          console.error("JSON export failed:", error);
          alert("Failed to export JSON.");
        }
      } else if (format === "pdf") {
        /* ... your PDF logic ... */
      }
    },
    [tree, selectedItemId]
  );

  // ** MODIFIED handleImport to use PUT for both "entire" and "selected" (by sending full tree) **
  const handleImport = useCallback(
    async (file, importTargetOption) => {
      return new Promise((resolveOuter) => {
        if (!file || file.type !== "application/json") {
          resolveOuter({ success: false, error: "Please select a JSON file." });
          return;
        }
        const reader = new FileReader();
        reader.onload = async (e) => {
          try {
            const importedData = JSON.parse(e.target.result);
            const token = getAuthToken();
            if (!token) {
              resolveOuter({
                success: false,
                error: "Authentication required to save imported data.",
              });
              return;
            }

            let processedTreeForServer;

            if (importTargetOption === "entire") {
              processedTreeForServer = Array.isArray(importedData)
                ? importedData.map((i) =>
                    assignNewIds(structuredClone(i), true)
                  )
                : [assignNewIds(structuredClone(i), true)];
              console.log(
                "Attempting to save entire imported tree to server (from 'entire' option):",
                processedTreeForServer.length,
                "items"
              );
            } else {
              // "selected" - import under an item
              const currentSel = findItemById(tree, selectedItemId);
              if (currentSel && currentSel.type === "folder") {
                const itemsToInsert = Array.isArray(importedData)
                  ? importedData.map((i) =>
                      assignNewIds(structuredClone(i), true)
                    )
                  : [assignNewIds(structuredClone(importedData), true)];

                let tempTree = [...tree]; // Start with a fresh copy of the current tree
                itemsToInsert.forEach((it) => {
                  if (!it.label || !it.type || !it.id) {
                    console.warn(
                      "Skipping invalid item during import under selected:",
                      it
                    );
                    return;
                  }
                  // Ensure no name conflicts before inserting
                  const parentForInsert = findItemById(tempTree, currentSel.id); // Find parent in potentially modified tempTree
                  const siblingsForInsert = parentForInsert?.children || [];
                  if (hasSiblingWithName(siblingsForInsert, it.label, null)) {
                    // Handle name conflict, e.g., by renaming 'it' or skipping
                    console.warn(
                      `Name conflict for "${it.label}" under "${currentSel.label}". Skipping item or implement renaming.`
                    );
                    // For now, skip: (or you could try to auto-rename 'it.label' here)
                    // return; // Or, if you must insert, it might overwrite or backend might reject
                  }
                  tempTree = insertItemRecursive(tempTree, currentSel.id, it);
                });
                processedTreeForServer = tempTree;
                console.log(
                  "Attempting to save modified tree (import under selected) to server:",
                  processedTreeForServer.length,
                  "root items"
                );
              } else {
                resolveOuter({
                  success: false,
                  error: "Target for import must be a selected folder.",
                });
                return;
              }
            }

            const response = await fetch(`${API_BASE_URL}/items/tree`, {
              method: "PUT",
              headers: {
                "Content-Type": "application/json",
                Authorization: `Bearer ${token}`,
              },
              body: JSON.stringify({ newTree: processedTreeForServer }),
            });
            const responseData = await response.json();

            if (!response.ok) {
              console.error("Server error saving imported tree:", responseData);
              resolveOuter({
                success: false,
                error:
                  responseData.error ||
                  "Failed to save imported tree to server.",
              });
              return;
            }

            replaceTree(responseData.notesTree || processedTreeForServer);

            if (
              importTargetOption === "selected" &&
              selectedItemId &&
              settings.autoExpandNewFolders
            ) {
              expandFolderPath(selectedItemId);
            } else if (
              importTargetOption === "entire" &&
              responseData.notesTree?.length > 0 &&
              responseData.notesTree[0].type === "folder" &&
              settings.autoExpandNewFolders
            ) {
              expandFolderPath(responseData.notesTree[0].id); // Expand first root folder if any
            }

            resolveOuter({
              success: true,
              message:
                responseData.message || "Data imported and saved successfully.",
            });
          } catch (err) {
            console.error("Import processing error:", err);
            resolveOuter({
              success: false,
              error: `Import error: ${err.message}`,
            });
          }
        };
        reader.onerror = () => {
          console.error("File read error during import.");
          resolveOuter({ success: false, error: "File read error." });
        };
        reader.readAsText(file);
      });
    },
    [
      tree,
      selectedItemId,
      replaceTree,
      settings.autoExpandNewFolders,
      expandFolderPath,
    ]
  );

  const searchItems = useCallback(
    (query, opts) => {
      // Your existing searchItems
      if (!query) return [];
      const results = [];
      const currentTree = tree || [];
      const walk = (nodes, currentPathSegments = []) => {
        if (!Array.isArray(nodes)) return;
        nodes.forEach((it) => {
          if (!it || typeof it.label !== "string") return;
          const itemPath = [...currentPathSegments, it.label].join(" / ");
          if (itemMatches(it, query, opts)) {
            results.push({ ...it, path: itemPath });
          }
          if (it.type === "folder" && Array.isArray(it.children)) {
            walk(it.children, [...currentPathSegments, it.label]);
          }
        });
      };
      walk(currentTree, []);
      return results;
    },
    [tree]
  );

  return {
    tree,
    selectedItem,
    selectedItemId,
    contextMenu,
    expandedFolders,
    draggedId,
    clipboardItem,
    clipboardMode,
    cutItemId,
    setContextMenu,
    setDraggedId,
    selectItemById,
    toggleFolderExpand,
    updateNoteContent,
    updateTask,
    addItem,
    renameItem,
    deleteItem,
    duplicateItem,
    handleDrop,
    copyItem,
    cutItem,
    pasteItem,
    handleExport,
    handleImport,
    searchItems,
    getItemPath,
    expandFolderPath,
    undoTreeChange,
    redoTreeChange,
    canUndoTree,
    canRedoTree,
    resetState: resetTreeHistory,
    fetchUserTree: fetchUserTreeInternal, // Expose the internal fetch function
    isFetchingTree, // Expose loading state
  };
};


--- src\hooks\useUndoRedo.js ---
// src/hooks/useUndoRedo.js
import { useState, useCallback } from 'react';

const MAX_HISTORY_SIZE = 50; // Max number of states to keep in history

export const useUndoRedo = (initialPresent) => {
    const [history, setHistory] = useState({
        past: [],
        present: initialPresent,
        future: [],
    });

    const canUndo = history.past.length > 0;
    const canRedo = history.future.length > 0;

    const setPresentState = useCallback((newPresent) => {
        setHistory(h => {
            const newPast = [...h.past, h.present];
            // Limit history size
            if (newPast.length > MAX_HISTORY_SIZE) {
                newPast.shift(); // Remove the oldest state
            }
            return {
                past: newPast,
                present: newPresent,
                future: [], // Clear future on new action
            };
        });
    }, []);

    const undo = useCallback(() => {
        if (!canUndo) return;
        setHistory(h => {
            const newFuture = [h.present, ...h.future];
            const newPresent = h.past[h.past.length - 1];
            const newPast = h.past.slice(0, h.past.length - 1);
            return {
                past: newPast,
                present: newPresent,
                future: newFuture,
            };
        });
    }, [canUndo]);

    const redo = useCallback(() => {
        if (!canRedo) return;
        setHistory(h => {
            const newPast = [...h.past, h.present];
            const newPresent = h.future[0];
            const newFuture = h.future.slice(1);
            return {
                past: newPast,
                present: newPresent,
                future: newFuture,
            };
        });
    }, [canRedo]);

    // This function is used when you load data (e.g., from localStorage or import)
    // to reset the history with a new present state.
    const resetHistory = useCallback((newInitialPresent) => {
        setHistory({
            past: [],
            present: newInitialPresent,
            future: [],
        });
    }, []);


    return {
        state: history.present,
        setState: setPresentState, // Renamed for clarity when using the hook
        resetState: resetHistory, // For initializing or resetting the state entirely
        undo,
        redo,
        canUndo,
        canRedo,
        // Expose past and future if needed for debugging or more complex scenarios
        // pastStates: history.past,
        // futureStates: history.future,
    };
};

--- src\hooks\useTree.jsx ---
// src/hooks/useTree.jsx
import React, { useState, useEffect, useCallback, useMemo } from "react";
import { LOCAL_STORAGE_KEY } from "../utils/constants";
import {
  sortItems,
  handleDrop as treeHandleDropUtil,
  deleteItemRecursive,
  renameItemRecursive,
  insertItemRecursive,
  isSelfOrDescendant,
  findItemById,
  findParentAndSiblings,
  hasSiblingWithName,
  getItemPath,
} from "../utils/treeUtils";
import { jsPDF } from "jspdf";
import * as bidiNS from "unicode-bidirectional";
import { notoSansHebrewBase64 } from "../fonts/NotoSansHebrewBase64";
import { useSettings } from "../contexts/SettingsContext";
import { itemMatches } from "../utils/searchUtils";
import { useUndoRedo } from "./useUndoRedo";

const API_BASE_URL =
  import.meta.env.VITE_API_BASE_URL || "http://localhost:5001/api";

const getAuthToken = () => {
  return localStorage.getItem("userToken");
};

const embeddingLevels = bidiNS.embeddingLevels || bidiNS.getEmbeddingLevels;
const reorder = bidiNS.reorder || bidiNS.getReorderedString;

function htmlToPlainTextWithNewlines(html) {
  if (!html) return "";
  let text = html;
  text = text.replace(
    /<(div|p|h[1-6]|li|blockquote|pre|tr|hr)[^>]*>/gi,
    "\n$&"
  );
  text = text.replace(/<br\s*\/?>/gi, "\n");
  text = text.replace(/<[^>]+>/g, "");
  try {
    const tempDiv = document.createElement("div");
    tempDiv.innerHTML = text;
    text = tempDiv.textContent || tempDiv.innerText || "";
  } catch (e) {
    console.error("Error decoding HTML entities for PDF export:", e);
  }
  return text.trim().replace(/(\r\n|\r|\n){2,}/g, "\n");
}

export const assignNewIds = (item, isDuplication = false) => {
  // Ensure this line is correct
  const newItem = { ...item };
  if (
    isDuplication ||
    !item.id ||
    item.id.startsWith("temp-") ||
    item.id.startsWith("client-")
  ) {
    newItem.id = `client-${Date.now().toString(36)}-${Math.random()
      .toString(36)
      .substring(2, 9)}`;
  }
  if (item.type === "folder") {
    newItem.children = Array.isArray(item.children)
      ? item.children.map((child) => assignNewIds(child, isDuplication))
      : [];
  }
  return newItem;
};

export const useTree = () => {
  const EXPANDED_KEY = `${LOCAL_STORAGE_KEY}_expanded`;
  const { settings } = useSettings();

  const initialTreeState = (() => {
    try {
      const stored = localStorage.getItem(LOCAL_STORAGE_KEY);
      const parsed = stored ? JSON.parse(stored) : [];
      return Array.isArray(parsed) ? parsed : [];
    } catch (error) {
      console.error("Failed to load tree from localStorage:", error);
      return [];
    }
  })();

  const {
    state: tree,
    setState: setTreeWithUndo,
    resetState: resetTreeHistory,
    undo: undoTreeChange,
    redo: redoTreeChange,
    canUndo: canUndoTree,
    canRedo: canRedoTree,
  } = useUndoRedo(initialTreeState);

  const [selectedItemId, setSelectedItemId] = useState(null);
  const [contextMenu, setContextMenu] = useState({
    visible: false,
    x: 0,
    y: 0,
    item: null,
    isEmptyArea: false,
  });
  const [expandedFolders, setExpandedFolders] = useState(() => {
    try {
      const stored = localStorage.getItem(EXPANDED_KEY);
      return stored ? JSON.parse(stored) : {};
    } catch {
      return {};
    }
  });
  const [draggedId, setDraggedId] = useState(null);
  const [clipboardItem, setClipboardItem] = useState(null);
  const [clipboardMode, setClipboardMode] = useState(null);
  const [cutItemId, setCutItemId] = useState(null);
  const [isFetchingTree, setIsFetchingTree] = useState(false); // For loading state

  const selectedItem = useMemo(
    () => findItemById(tree, selectedItemId),
    [tree, selectedItemId]
  );

  const fetchUserTreeInternal = useCallback(
    async (token) => {
      if (!token) {
        console.log(
          "fetchUserTreeInternal: No token provided, clearing/resetting tree."
        );
        resetTreeHistory([]); // Or load from localStorage if preferred for logged-out
        setIsFetchingTree(false);
        return;
      }
      setIsFetchingTree(true);
      console.log(
        "fetchUserTreeInternal: Token found, fetching tree from server."
      );
      try {
        const response = await fetch(`${API_BASE_URL}/items/tree`, {
          headers: { Authorization: `Bearer ${token}` },
        });
        console.log(
          "fetchUserTreeInternal: fetchTreeFromServer response status:",
          response.status
        );
        if (!response.ok) {
          const errorData = await response
            .json()
            .catch(() => ({ error: "Failed to parse error response" }));
          if (response.status === 401) {
            console.error(
              "fetchUserTreeInternal: Unauthorized (401). Token might be invalid."
            );
            localStorage.removeItem("userToken"); // Critical: remove invalid token
            // Consider calling a global logout handler if App.jsx passes one down
          } else {
            console.error(
              "fetchUserTreeInternal: Server error fetching tree:",
              response.status,
              errorData
            );
          }
          resetTreeHistory([]); // Clear tree on error
          setIsFetchingTree(false);
          return; // Explicitly return on error
        }
        const data = await response.json();
        if (data && Array.isArray(data.notesTree)) {
          console.log(
            "fetchUserTreeInternal: Successfully fetched tree, resetting local state."
          );
          resetTreeHistory(data.notesTree);
        } else {
          console.warn(
            "fetchUserTreeInternal: Fetched tree data is not in expected format, using empty tree."
          );
          resetTreeHistory([]);
        }
      } catch (error) {
        console.error(
          "fetchUserTreeInternal: Network or other error fetching tree:",
          error
        );
        resetTreeHistory([]); // Clear tree on error
      } finally {
        setIsFetchingTree(false);
      }
    },
    [resetTreeHistory]
  ); // API_BASE_URL is stable

  // Effect for initial load and when token changes (e.g., after login)
  // This will be triggered by App.jsx calling fetchUserTree after login.
  // For initial load, App.jsx will also call this if a token is found.
  // The useEffect that was here before is effectively replaced by App.jsx controlling the fetch.

  useEffect(() => {
    // Persist tree to localStorage
    try {
      if (Array.isArray(tree))
        localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(tree));
    } catch (error) {
      console.error("Failed to save tree to localStorage:", error);
    }
  }, [tree]);

  useEffect(() => {
    // Persist expanded folders
    try {
      localStorage.setItem(EXPANDED_KEY, JSON.stringify(expandedFolders));
    } catch (error) {
      console.error("Failed to save expanded folders:", error);
    }
  }, [expandedFolders]);

  const selectItemById = useCallback((id) => setSelectedItemId(id), []);
  const replaceTree = useCallback(
    (newTreeData) => {
      if (Array.isArray(newTreeData)) {
        resetTreeHistory(newTreeData);
        setSelectedItemId(null);
        setExpandedFolders({});
        return { success: true };
      }
      console.error("replaceTree failed: Data is not an array.", newTreeData);
      return { success: false, error: "Import failed: Invalid data format." };
    },
    [resetTreeHistory]
  );

  const expandFolderPath = useCallback(
    /* ... (Your existing robust expandFolderPath) ... */
    (itemIdToExpand) => {
      if (!itemIdToExpand) return;
      const pathIds = [];
      const findPathRecursive = (nodes, targetId, currentPathSegmentsIds) => {
        for (const node of nodes) {
          if (!node || !node.id) continue;
          if (node.id === targetId) {
            pathIds.push(...currentPathSegmentsIds, node.id);
            return true;
          }
          if (node.type === "folder" && Array.isArray(node.children)) {
            if (
              findPathRecursive(node.children, targetId, [
                ...currentPathSegmentsIds,
                node.id,
              ])
            ) {
              return true;
            }
          }
        }
        return false;
      };
      findPathRecursive(tree, itemIdToExpand, []);
      setExpandedFolders((prev) => {
        const next = { ...prev };
        let changed = false;
        pathIds.forEach((id) => {
          const item = findItemById(tree, id);
          if (item && item.type === "folder" && !next[id]) {
            next[id] = true;
            changed = true;
          }
        });
        const targetItem = findItemById(tree, itemIdToExpand);
        if (
          targetItem &&
          targetItem.type === "folder" &&
          !next[itemIdToExpand]
        ) {
          next[itemIdToExpand] = true;
          changed = true;
        }
        return changed ? next : prev;
      });
    },
    [tree]
  );

  const toggleFolderExpand = useCallback((id, forceState) => {
    if (!id) return;
    setExpandedFolders((prev) => ({
      ...prev,
      [id]: forceState !== undefined ? Boolean(forceState) : !prev[id],
    }));
  }, []);

  const addItem = useCallback(
    /* ... (Your existing addItem with API calls) ... */
    async (newItemData, parentId) => {
      const trimmedLabel = newItemData?.label?.trim();
      if (!trimmedLabel) return { success: false, error: "Label is required." };
      if (!["folder", "note", "task"].includes(newItemData.type))
        return { success: false, error: "Invalid item type." };
      const token = getAuthToken();
      if (!token) return { success: false, error: "Authentication required." };
      const payload = { label: trimmedLabel, type: newItemData.type };
      if (newItemData.type === "note" || newItemData.type === "task")
        payload.content = newItemData.content || "";
      if (newItemData.type === "task")
        payload.completed = !!newItemData.completed;
      try {
        const endpoint = parentId
          ? `${API_BASE_URL}/items/${parentId}`
          : `${API_BASE_URL}/items`;
        const response = await fetch(endpoint, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            Authorization: `Bearer ${token}`,
          },
          body: JSON.stringify(payload),
        });
        const responseData = await response.json();
        if (!response.ok)
          return {
            success: false,
            error:
              responseData.error || `Failed to add item: ${response.status}`,
          };
        const createdItemFromServer = responseData;
        const newTreeState = insertItemRecursive(
          tree,
          parentId,
          createdItemFromServer
        );
        setTreeWithUndo(newTreeState);
        if (parentId && settings.autoExpandNewFolders) {
          setTimeout(() => expandFolderPath(parentId), 0);
        } else if (
          !parentId &&
          createdItemFromServer.type === "folder" &&
          settings.autoExpandNewFolders
        ) {
          setTimeout(() => expandFolderPath(createdItemFromServer.id), 0);
        } // Expand new root folder
        return { success: true, item: createdItemFromServer };
      } catch (error) {
        console.error("addItem API error:", error);
        return { success: false, error: "Network error adding item." };
      }
    },
    [tree, setTreeWithUndo, expandFolderPath, settings.autoExpandNewFolders]
  );

  const updateNoteContent = useCallback(
    /* ... (Your existing updateNoteContent with API calls) ... */
    async (itemId, content) => {
      const token = getAuthToken();
      if (!token) return { success: false, error: "Authentication required." };
      try {
        const response = await fetch(`${API_BASE_URL}/items/${itemId}`, {
          method: "PATCH",
          headers: {
            "Content-Type": "application/json",
            Authorization: `Bearer ${token}`,
          },
          body: JSON.stringify({ content }),
        });
        const updatedItemFromServer = await response.json();
        if (!response.ok)
          return {
            success: false,
            error: updatedItemFromServer.error || "Failed to update note.",
          };
        const mapRecursive = (items, id, serverUpdates) =>
          items.map((i) =>
            i.id === id
              ? { ...i, ...serverUpdates }
              : Array.isArray(i.children)
              ? { ...i, children: mapRecursive(i.children, id, serverUpdates) }
              : i
          );
        const newTreeState = mapRecursive(tree, itemId, updatedItemFromServer);
        setTreeWithUndo(newTreeState);
        return { success: true, item: updatedItemFromServer };
      } catch (error) {
        console.error("updateNoteContent API error:", error);
        return { success: false, error: "Network error updating note." };
      }
    },
    [tree, setTreeWithUndo]
  );

  const updateTask = useCallback(
    /* ... (Your existing updateTask with API calls) ... */
    async (taskId, clientUpdates) => {
      const token = getAuthToken();
      if (!token) return { success: false, error: "Authentication required." };
      try {
        const response = await fetch(`${API_BASE_URL}/items/${taskId}`, {
          method: "PATCH",
          headers: {
            "Content-Type": "application/json",
            Authorization: `Bearer ${token}`,
          },
          body: JSON.stringify(clientUpdates),
        });
        const updatedItemFromServer = await response.json();
        if (!response.ok)
          return {
            success: false,
            error: updatedItemFromServer.error || "Failed to update task.",
          };
        const mapRecursiveTask = (items, id, serverUpdates) =>
          items.map((i) =>
            i.id === id && i.type === "task"
              ? { ...i, ...serverUpdates }
              : Array.isArray(i.children)
              ? {
                  ...i,
                  children: mapRecursiveTask(i.children, id, serverUpdates),
                }
              : i
          );
        const newTreeState = mapRecursiveTask(
          tree,
          taskId,
          updatedItemFromServer
        );
        setTreeWithUndo(newTreeState);
        return { success: true, item: updatedItemFromServer };
      } catch (error) {
        console.error("updateTask API error:", error);
        return { success: false, error: "Network error updating task." };
      }
    },
    [tree, setTreeWithUndo]
  );

  const renameItem = useCallback(
    /* ... (Your existing renameItem with API calls) ... */
    async (itemId, newLabel) => {
      const trimmedLabel = newLabel?.trim();
      if (!trimmedLabel || !itemId)
        return { success: false, error: "Invalid ID or name." };
      const token = getAuthToken();
      if (!token) return { success: false, error: "Authentication required." };
      const { parentArray } = findParentAndSiblings(tree, itemId);
      if (hasSiblingWithName(parentArray || [], trimmedLabel, itemId)) {
        return {
          success: false,
          error: `Item "${trimmedLabel}" already exists.`,
        };
      }
      try {
        const response = await fetch(`${API_BASE_URL}/items/${itemId}`, {
          method: "PATCH",
          headers: {
            "Content-Type": "application/json",
            Authorization: `Bearer ${token}`,
          },
          body: JSON.stringify({ label: trimmedLabel }),
        });
        const updatedItemFromServer = await response.json();
        if (!response.ok)
          return {
            success: false,
            error: updatedItemFromServer.error || "Rename failed.",
          };
        const newTreeState = renameItemRecursive(
          tree,
          itemId,
          updatedItemFromServer.label
        );
        setTreeWithUndo(newTreeState);
        return { success: true, item: updatedItemFromServer };
      } catch (error) {
        console.error("renameItem API error:", error);
        return { success: false, error: "Network error renaming." };
      }
    },
    [tree, setTreeWithUndo]
  );

  const deleteItem = useCallback(
    /* ... (Your existing deleteItem with API calls) ... */
    async (idToDelete) => {
      if (!idToDelete) return { success: false, error: "No ID for deletion." };
      const token = getAuthToken();
      if (!token) return { success: false, error: "Authentication required." };
      try {
        const response = await fetch(`${API_BASE_URL}/items/${idToDelete}`, {
          method: "DELETE",
          headers: { Authorization: `Bearer ${token}` },
        });
        if (!response.ok && response.status !== 404) {
          const errorData = await response.json().catch(() => ({}));
          return {
            success: false,
            error: errorData.error || "Delete failed on server.",
          };
        }
        const newTreeState = deleteItemRecursive(tree, idToDelete);
        setTreeWithUndo(newTreeState);
        if (selectedItemId === idToDelete) setSelectedItemId(null);
        setExpandedFolders((prev) => {
          const next = { ...prev };
          if (prev.hasOwnProperty(idToDelete)) delete next[idToDelete];
          return next;
        });
        // setContextMenu((m) => (m.visible ? { ...m, visible: false } : m)); // Usually handled by App.jsx
        return { success: true };
      } catch (error) {
        console.error("deleteItem API error:", error);
        return { success: false, error: "Network error deleting." };
      }
    },
    [tree, selectedItemId, setTreeWithUndo /* setContextMenu not a direct dep*/]
  );

  const duplicateItem = useCallback(
    /* ... (Your existing duplicateItem, ensure it calls addItem for DB persistence) ... */
    async (itemId) => {
      const itemToDuplicate = findItemById(tree, itemId);
      if (!itemToDuplicate)
        return { success: false, error: "Item to duplicate not found." };
      const { parent } = findParentAndSiblings(tree, itemId);
      const parentId = parent?.id ?? null;
      let newDuplicate = assignNewIds(structuredClone(itemToDuplicate), true);
      let baseName = itemToDuplicate.label;
      let newLabel = `${baseName} (copy)`;
      let counter = 1;
      const targetSiblings = parentId
        ? findItemById(tree, parentId)?.children || []
        : tree;
      while (hasSiblingWithName(targetSiblings, newLabel, null)) {
        counter++;
        newLabel = `${baseName} (copy ${counter})`;
      }
      newDuplicate.label = newLabel;
      const result = await addItem(newDuplicate, parentId);
      if (result.success && result.item) {
        if (parentId && settings.autoExpandNewFolders) {
          setTimeout(() => expandFolderPath(parentId), 0);
        }
        return { success: true, item: result.item };
      } else {
        return {
          success: false,
          error: result.error || "Failed to save duplicated item.",
        };
      }
    },
    [tree, addItem, settings.autoExpandNewFolders, expandFolderPath]
  );

  const handleDrop = useCallback(
    /* ... (Your existing handleDrop, still mostly client-side for DB) ... */
    async (targetFolderId, droppedItemId) => {
      console.warn(
        "useTree: handleDrop (moving items) is client-side for DB persistence. Needs server endpoint."
      );
      const currentDraggedId = droppedItemId || draggedId;
      setDraggedId(null);
      if (!currentDraggedId || targetFolderId === currentDraggedId)
        return { success: false, error: "Invalid drop." };
      const itemToDrop = findItemById(tree, currentDraggedId);
      const targetFolder = findItemById(tree, targetFolderId);
      if (!itemToDrop || !targetFolder || targetFolder.type !== "folder")
        return { success: false, error: "Invalid item or target folder." };
      if (
        itemToDrop.type === "folder" &&
        isSelfOrDescendant(tree, itemToDrop.id, targetFolderId)
      ) {
        return {
          success: false,
          error: "Cannot drop folder into itself or one of its descendants.",
        };
      }
      if (
        hasSiblingWithName(targetFolder.children || [], itemToDrop.label, null)
      ) {
        return {
          success: false,
          error: `Item named "${itemToDrop.label}" already exists in the target folder.`,
        };
      }
      const newTreeState = treeHandleDropUtil(
        tree,
        targetFolderId,
        currentDraggedId
      );
      if (newTreeState) {
        setTreeWithUndo(newTreeState);
        if (settings.autoExpandNewFolders && targetFolderId) {
          setTimeout(() => expandFolderPath(targetFolderId), 0);
        }
        return {
          success: true,
          message:
            "Local drop successful. Server persistence for item move not yet implemented.",
        };
      }
      return { success: false, error: "Local drop simulation failed." };
    },
    [
      tree,
      draggedId,
      setTreeWithUndo,
      settings.autoExpandNewFolders,
      expandFolderPath,
      treeHandleDropUtil,
    ]
  );

  const copyItem = useCallback(
    /* ... (Your existing copyItem) ... */
    (itemId) => {
      const itemToCopy = findItemById(tree, itemId);
      if (itemToCopy) {
        try {
          const deepCopy = structuredClone(itemToCopy);
          setClipboardItem(deepCopy);
          setClipboardMode("copy");
          setCutItemId(null);
        } catch (e) {
          console.error("Error copying item:", e);
          setClipboardItem(null);
          setClipboardMode(null);
          setCutItemId(null);
        }
      }
    },
    [tree]
  );

  const cutItem = useCallback(
    /* ... (Your existing cutItem) ... */
    (itemId) => {
      const itemToCut = findItemById(tree, itemId);
      if (itemToCut) {
        try {
          const deepCopy = structuredClone(itemToCut);
          setClipboardItem(deepCopy);
          setClipboardMode("cut");
          setCutItemId(itemId);
        } catch (e) {
          console.error("Error cutting item:", e);
          setClipboardItem(null);
          setClipboardMode(null);
          setCutItemId(null);
        }
      }
    },
    [tree]
  );

  const pasteItem = useCallback(
    /* ... (Your existing pasteItem, 'copy' uses addItem, 'cut' is client-side for DB) ... */
    async (targetFolderId) => {
      console.warn(
        "useTree: pasteItem: 'cut' persistence needs backend. 'copy' uses addItem."
      );
      if (!clipboardItem)
        return { success: false, error: "Clipboard is empty." };
      const targetParent = targetFolderId
        ? findItemById(tree, targetFolderId)
        : null;
      if (targetFolderId && (!targetParent || targetParent.type !== "folder")) {
        return {
          success: false,
          error: "Target for paste must be a valid folder or root.",
        };
      }
      if (
        clipboardItem.type === "folder" &&
        isSelfOrDescendant(tree, clipboardItem.id, targetFolderId)
      ) {
        return {
          success: false,
          error: "Cannot paste a folder into itself or one of its descendants.",
        };
      }
      const targetSiblings = targetFolderId
        ? targetParent?.children || []
        : tree;
      let itemToInsert = structuredClone(clipboardItem);
      if (clipboardMode === "copy") {
        itemToInsert = assignNewIds(itemToInsert, true);
        let baseName = itemToInsert.label;
        let newLabel = baseName;
        let copyCounter = 0;
        while (hasSiblingWithName(targetSiblings, newLabel, null)) {
          copyCounter++;
          newLabel = `${baseName} (copy${
            copyCounter > 1 ? ` ${copyCounter}` : ""
          })`;
        }
        itemToInsert.label = newLabel;
        const addResult = await addItem(itemToInsert, targetFolderId);
        if (
          addResult.success &&
          targetFolderId &&
          settings.autoExpandNewFolders
        )
          expandFolderPath(targetFolderId);
        return addResult;
      } else if (clipboardMode === "cut" && cutItemId) {
        if (
          cutItemId === targetFolderId &&
          findParentAndSiblings(tree, cutItemId)?.parent?.id === targetFolderId
        ) {
          setClipboardItem(null);
          setClipboardMode(null);
          setCutItemId(null);
          return {
            success: true,
            item: itemToInsert,
            message: "Item 'pasted' in the same location.",
          };
        }
        if (
          findParentAndSiblings(tree, cutItemId)?.parent?.id !==
            targetFolderId &&
          hasSiblingWithName(targetSiblings, itemToInsert.label, null)
        ) {
          // Check if name exists unless it's the same item not changing name context
          return {
            success: false,
            error: `An item named "${itemToInsert.label}" already exists in the target folder.`,
          };
        }
        console.warn(
          "Cut & Paste: Persistence of item move not fully implemented on backend. Simulating client-side."
        );
        let tempTree = deleteItemRecursive(tree, cutItemId);
        tempTree = insertItemRecursive(tempTree, targetFolderId, itemToInsert);
        setTreeWithUndo(tempTree);
        setClipboardItem(null);
        setClipboardMode(null);
        setCutItemId(null);
        if (targetFolderId && settings.autoExpandNewFolders)
          expandFolderPath(targetFolderId);
        return {
          success: true,
          item: itemToInsert,
          message:
            "Item moved locally. Server persistence for move needs to be implemented.",
        };
      }
      return { success: false, error: "Invalid paste operation." };
    },
    [
      tree,
      clipboardItem,
      clipboardMode,
      cutItemId,
      setTreeWithUndo,
      settings.autoExpandNewFolders,
      expandFolderPath,
      addItem,
    ]
  );

  const handleExport = useCallback(
    /* ... (Your existing handleExport, no DB interaction) ... */
    (target, format) => {
      let dataToExport;
      let fileName;
      const currentSelectedItem = findItemById(tree, selectedItemId);
      if (target === "selected") {
        if (!currentSelectedItem) {
          alert("No item selected.");
          return;
        }
        dataToExport = currentSelectedItem;
        fileName = `${currentSelectedItem.label}-export`;
      } else {
        dataToExport = tree;
        fileName = "tree-export";
      }
      if (format === "json") {
        try {
          const jsonStr = JSON.stringify(dataToExport, null, 2);
          const blob = new Blob([jsonStr], { type: "application/json" });
          const url = URL.createObjectURL(blob);
          const a = document.createElement("a");
          a.href = url;
          a.download = fileName + ".json";
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(url);
        } catch (error) {
          console.error("JSON export failed:", error);
          alert("Failed to export JSON.");
        }
      } else if (format === "pdf") {
        /* ... your PDF logic ... */
      }
    },
    [tree, selectedItemId]
  );

  // ** MODIFIED handleImport to use PUT for both "entire" and "selected" (by sending full tree) **
  const handleImport = useCallback(
    async (file, importTargetOption) => {
      return new Promise((resolveOuter) => {
        if (!file || file.type !== "application/json") {
          resolveOuter({ success: false, error: "Please select a JSON file." });
          return;
        }
        const reader = new FileReader();
        reader.onload = async (e) => {
          try {
            const importedData = JSON.parse(e.target.result);
            const token = getAuthToken();
            if (!token) {
              resolveOuter({
                success: false,
                error: "Authentication required to save imported data.",
              });
              return;
            }

            let processedTreeForServer;

            if (importTargetOption === "entire") {
              processedTreeForServer = Array.isArray(importedData)
                ? importedData.map((i) =>
                    assignNewIds(structuredClone(i), true)
                  )
                : [assignNewIds(structuredClone(i), true)];
              console.log(
                "Attempting to save entire imported tree to server (from 'entire' option):",
                processedTreeForServer.length,
                "items"
              );
            } else {
              // "selected" - import under an item
              const currentSel = findItemById(tree, selectedItemId);
              if (currentSel && currentSel.type === "folder") {
                const itemsToInsert = Array.isArray(importedData)
                  ? importedData.map((i) =>
                      assignNewIds(structuredClone(i), true)
                    )
                  : [assignNewIds(structuredClone(importedData), true)];

                let tempTree = [...tree]; // Start with a fresh copy of the current tree
                itemsToInsert.forEach((it) => {
                  if (!it.label || !it.type || !it.id) {
                    console.warn(
                      "Skipping invalid item during import under selected:",
                      it
                    );
                    return;
                  }
                  // Ensure no name conflicts before inserting
                  const parentForInsert = findItemById(tempTree, currentSel.id); // Find parent in potentially modified tempTree
                  const siblingsForInsert = parentForInsert?.children || [];
                  if (hasSiblingWithName(siblingsForInsert, it.label, null)) {
                    // Handle name conflict, e.g., by renaming 'it' or skipping
                    console.warn(
                      `Name conflict for "${it.label}" under "${currentSel.label}". Skipping item or implement renaming.`
                    );
                    // For now, skip: (or you could try to auto-rename 'it.label' here)
                    // return; // Or, if you must insert, it might overwrite or backend might reject
                  }
                  tempTree = insertItemRecursive(tempTree, currentSel.id, it);
                });
                processedTreeForServer = tempTree;
                console.log(
                  "Attempting to save modified tree (import under selected) to server:",
                  processedTreeForServer.length,
                  "root items"
                );
              } else {
                resolveOuter({
                  success: false,
                  error: "Target for import must be a selected folder.",
                });
                return;
              }
            }

            const response = await fetch(`${API_BASE_URL}/items/tree`, {
              method: "PUT",
              headers: {
                "Content-Type": "application/json",
                Authorization: `Bearer ${token}`,
              },
              body: JSON.stringify({ newTree: processedTreeForServer }),
            });
            const responseData = await response.json();

            if (!response.ok) {
              console.error("Server error saving imported tree:", responseData);
              resolveOuter({
                success: false,
                error:
                  responseData.error ||
                  "Failed to save imported tree to server.",
              });
              return;
            }

            replaceTree(responseData.notesTree || processedTreeForServer);

            if (
              importTargetOption === "selected" &&
              selectedItemId &&
              settings.autoExpandNewFolders
            ) {
              expandFolderPath(selectedItemId);
            } else if (
              importTargetOption === "entire" &&
              responseData.notesTree?.length > 0 &&
              responseData.notesTree[0].type === "folder" &&
              settings.autoExpandNewFolders
            ) {
              expandFolderPath(responseData.notesTree[0].id); // Expand first root folder if any
            }

            resolveOuter({
              success: true,
              message:
                responseData.message || "Data imported and saved successfully.",
            });
          } catch (err) {
            console.error("Import processing error:", err);
            resolveOuter({
              success: false,
              error: `Import error: ${err.message}`,
            });
          }
        };
        reader.onerror = () => {
          console.error("File read error during import.");
          resolveOuter({ success: false, error: "File read error." });
        };
        reader.readAsText(file);
      });
    },
    [
      tree,
      selectedItemId,
      replaceTree,
      settings.autoExpandNewFolders,
      expandFolderPath,
    ]
  );

  const searchItems = useCallback(
    (query, opts) => {
      // Your existing searchItems
      if (!query) return [];
      const results = [];
      const currentTree = tree || [];
      const walk = (nodes, currentPathSegments = []) => {
        if (!Array.isArray(nodes)) return;
        nodes.forEach((it) => {
          if (!it || typeof it.label !== "string") return;
          const itemPath = [...currentPathSegments, it.label].join(" / ");
          if (itemMatches(it, query, opts)) {
            results.push({ ...it, path: itemPath });
          }
          if (it.type === "folder" && Array.isArray(it.children)) {
            walk(it.children, [...currentPathSegments, it.label]);
          }
        });
      };
      walk(currentTree, []);
      return results;
    },
    [tree]
  );

  return {
    tree,
    selectedItem,
    selectedItemId,
    contextMenu,
    expandedFolders,
    draggedId,
    clipboardItem,
    clipboardMode,
    cutItemId,
    setContextMenu,
    setDraggedId,
    selectItemById,
    toggleFolderExpand,
    updateNoteContent,
    updateTask,
    addItem,
    renameItem,
    deleteItem,
    duplicateItem,
    handleDrop,
    copyItem,
    cutItem,
    pasteItem,
    handleExport,
    handleImport,
    searchItems,
    getItemPath,
    expandFolderPath,
    undoTreeChange,
    redoTreeChange,
    canUndoTree,
    canRedoTree,
    resetState: resetTreeHistory,
    fetchUserTree: fetchUserTreeInternal, // Expose the internal fetch function
    isFetchingTree, // Expose loading state
  };
};


--- src\hooks\useUndoRedo.js ---
// src/hooks/useUndoRedo.js
import { useState, useCallback } from 'react';

const MAX_HISTORY_SIZE = 50; // Max number of states to keep in history

export const useUndoRedo = (initialPresent) => {
    const [history, setHistory] = useState({
        past: [],
        present: initialPresent,
        future: [],
    });

    const canUndo = history.past.length > 0;
    const canRedo = history.future.length > 0;

    const setPresentState = useCallback((newPresent) => {
        setHistory(h => {
            const newPast = [...h.past, h.present];
            // Limit history size
            if (newPast.length > MAX_HISTORY_SIZE) {
                newPast.shift(); // Remove the oldest state
            }
            return {
                past: newPast,
                present: newPresent,
                future: [], // Clear future on new action
            };
        });
    }, []);

    const undo = useCallback(() => {
        if (!canUndo) return;
        setHistory(h => {
            const newFuture = [h.present, ...h.future];
            const newPresent = h.past[h.past.length - 1];
            const newPast = h.past.slice(0, h.past.length - 1);
            return {
                past: newPast,
                present: newPresent,
                future: newFuture,
            };
        });
    }, [canUndo]);

    const redo = useCallback(() => {
        if (!canRedo) return;
        setHistory(h => {
            const newPast = [...h.past, h.present];
            const newPresent = h.future[0];
            const newFuture = h.future.slice(1);
            return {
                past: newPast,
                present: newPresent,
                future: newFuture,
            };
        });
    }, [canRedo]);

    // This function is used when you load data (e.g., from localStorage or import)
    // to reset the history with a new present state.
    const resetHistory = useCallback((newInitialPresent) => {
        setHistory({
            past: [],
            present: newInitialPresent,
            future: [],
        });
    }, []);


    return {
        state: history.present,
        setState: setPresentState, // Renamed for clarity when using the hook
        resetState: resetHistory, // For initializing or resetting the state entirely
        undo,
        redo,
        canUndo,
        canRedo,
        // Expose past and future if needed for debugging or more complex scenarios
        // pastStates: history.past,
        // futureStates: history.future,
    };
};

--- src\styles\index.css ---
/* src/styles/index.css */
@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {

  /*
    1. Set a responsive base font size.
       This makes 1rem roughly equivalent to 16px on most desktop browsers
       but allows for better scaling based on user preferences and device settings.
       Mobile devices might use a slightly larger physical pixel size for 1rem
       due to the viewport meta tag, improving readability.
  */
  html {
    font-size: 100%;
    /* Or 16px as a starting point if you prefer explicit base */
    -webkit-text-size-adjust: 100%;
    /* Prevent font scaling in landscape on iOS */
  }

  body {
    @apply bg-white dark:bg-zinc-900 text-zinc-900 dark:text-zinc-100;
    /*
      2. Apply a sensible default font family.
         Tailwind's default sans-serif stack is usually good.
         Ensure this is what you want for the overall UI, not just prose content.
    */
    font-family: ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";
    /*
      3. Consider a slightly larger base line-height for better readability,
         especially on mobile. Tailwind's `leading-normal` is 1.5.
         This can be overridden by specific utilities.
    */
    @apply leading-normal;
  }

  /*
    4. Customize Tailwind Typography Plugin defaults if needed.
       The `.prose` class is applied in your EditorPane.
       You might want to ensure its base font size is responsive or suitable for mobile.
       By default, `prose-sm` (which you use) has a 0.875rem (14px) base font size.
       This might be okay for content on mobile, but test thoroughly.

       If you need to globally adjust prose defaults for mobile, you could do:
  */
  /*
  .prose {
    @apply text-base; // Example: Make base prose text 1rem (16px)
  }
  .prose-sm {
    @apply text-sm; // Ensure prose-sm still works if you want smaller specific sections
                    // This would be 0.875rem (14px) if base is 1rem.
  }

  You can also target specific elements within .prose:
  .prose h1 {
    @apply text-2xl sm:text-3xl; // Responsive heading sizes
  }
  */

  /*
    If you find the default prose font sizes too small on mobile,
    and you apply `.prose` or `.prose-sm` directly in your JSX,
    you can make the component itself responsive with Tailwind classes:

    e.g., in EditorPane.jsx:
    className="editor-pane prose prose-sm md:prose ..."
    This would apply `prose` (base size) on small screens and `prose-sm` on medium and up.
    Or even just `prose md:prose-sm` if `prose` (base) is your desired mobile size.
  */
}

/*
  Scrollbar styles from your previous configuration.
  These are generally fine and don't directly impact font/resolution,
  but keeping them here for completeness of the file.
*/
@layer utilities {
  .custom-scrollbar::-webkit-scrollbar {
    width: 8px;
  }

  .custom-scrollbar::-webkit-scrollbar-track {
    background: transparent;
  }

  .custom-scrollbar::-webkit-scrollbar-thumb {
    /* Tailwind zinc-400 */
    background-color: #a1a1aa;
    border-radius: 20px;
    /* Creates padding around thumb */
    border: 3px solid transparent;
    background-clip: content-box;
  }

  .dark .custom-scrollbar::-webkit-scrollbar-thumb {
    /* Tailwind zinc-600 */
    background-color: #52525b;
  }

  .custom-scrollbar::-webkit-scrollbar-thumb:hover {
    /* Tailwind zinc-500 */
    background-color: #71717a;
  }

  .dark .custom-scrollbar::-webkit-scrollbar-thumb:hover {
    /* Tailwind zinc-500 */
    background-color: #71717a;
  }

  /* Firefox scrollbar styling (optional but recommended) */
  .custom-scrollbar {
    scrollbar-width: thin;
    /* Tailwind zinc-400 / zinc-600 */
    scrollbar-color: #a1a1aa transparent;
  }

  .dark .custom-scrollbar {
    scrollbar-color: #52525b transparent;
  }
}

/*
  Styles for code formatting within the editor.
  These are generally fine and relate to specific elements, not base typography.
  Ensure the font sizes (text-sm) used here are readable on mobile within the editor context.
  If `text-sm` (0.875rem) becomes too small because the base `rem` value is effectively small on mobile,
  you might need to use responsive prefixes here too (e.g., `text-base md:text-sm`).
*/
.editor-pane code:not(pre > code) {
  /* Style for inline code */
  @apply bg-zinc-200 dark:bg-zinc-700 px-1 py-0.5 rounded font-mono text-sm text-red-600 dark:text-red-400;
}

.editor-pane pre {
  /* Style for code blocks */
  @apply bg-zinc-100 dark:bg-zinc-900 p-3 my-2 rounded overflow-auto font-mono text-sm block;
  white-space: pre;
  /* Important for preserving whitespace */
}

.editor-pane pre code {
  /* Style for code specifically within a pre block */
  @apply bg-transparent p-0 font-mono text-sm text-inherit dark:text-inherit;
  white-space: pre;
  /* Inherit whitespace preservation */
}

.editor-pane .shell-command {
  @apply bg-black dark:bg-black text-green-400 dark:text-green-300 p-3 my-2 rounded overflow-auto font-mono text-sm block;
  white-space: pre;
}

.editor-pane .shell-command::before {
  content: "$ ";
  color: #9ca3af;
  /* gray-400 */
}

.editor-pane {
  white-space: pre-wrap;
}

/* Ensure prose styles don't override code block styles too much */
.dark .prose-invert pre {
  @apply bg-zinc-900;
}

.prose pre {
  @apply bg-zinc-100;
}

.prose code:not(pre > code) {
  @apply bg-zinc-200 dark:bg-zinc-700 text-red-600 dark:text-red-400 px-1 py-0.5;
  font-weight: normal;
}

.prose code::before,
.prose code::after {
  content: none;
}

--- src\styles\index.css ---
/* src/styles/index.css */
@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {

  /*
    1. Set a responsive base font size.
       This makes 1rem roughly equivalent to 16px on most desktop browsers
       but allows for better scaling based on user preferences and device settings.
       Mobile devices might use a slightly larger physical pixel size for 1rem
       due to the viewport meta tag, improving readability.
  */
  html {
    font-size: 100%;
    /* Or 16px as a starting point if you prefer explicit base */
    -webkit-text-size-adjust: 100%;
    /* Prevent font scaling in landscape on iOS */
  }

  body {
    @apply bg-white dark:bg-zinc-900 text-zinc-900 dark:text-zinc-100;
    /*
      2. Apply a sensible default font family.
         Tailwind's default sans-serif stack is usually good.
         Ensure this is what you want for the overall UI, not just prose content.
    */
    font-family: ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";
    /*
      3. Consider a slightly larger base line-height for better readability,
         especially on mobile. Tailwind's `leading-normal` is 1.5.
         This can be overridden by specific utilities.
    */
    @apply leading-normal;
  }

  /*
    4. Customize Tailwind Typography Plugin defaults if needed.
       The `.prose` class is applied in your EditorPane.
       You might want to ensure its base font size is responsive or suitable for mobile.
       By default, `prose-sm` (which you use) has a 0.875rem (14px) base font size.
       This might be okay for content on mobile, but test thoroughly.

       If you need to globally adjust prose defaults for mobile, you could do:
  */
  /*
  .prose {
    @apply text-base; // Example: Make base prose text 1rem (16px)
  }
  .prose-sm {
    @apply text-sm; // Ensure prose-sm still works if you want smaller specific sections
                    // This would be 0.875rem (14px) if base is 1rem.
  }

  You can also target specific elements within .prose:
  .prose h1 {
    @apply text-2xl sm:text-3xl; // Responsive heading sizes
  }
  */

  /*
    If you find the default prose font sizes too small on mobile,
    and you apply `.prose` or `.prose-sm` directly in your JSX,
    you can make the component itself responsive with Tailwind classes:

    e.g., in EditorPane.jsx:
    className="editor-pane prose prose-sm md:prose ..."
    This would apply `prose` (base size) on small screens and `prose-sm` on medium and up.
    Or even just `prose md:prose-sm` if `prose` (base) is your desired mobile size.
  */
}

/*
  Scrollbar styles from your previous configuration.
  These are generally fine and don't directly impact font/resolution,
  but keeping them here for completeness of the file.
*/
@layer utilities {
  .custom-scrollbar::-webkit-scrollbar {
    width: 8px;
  }

  .custom-scrollbar::-webkit-scrollbar-track {
    background: transparent;
  }

  .custom-scrollbar::-webkit-scrollbar-thumb {
    /* Tailwind zinc-400 */
    background-color: #a1a1aa;
    border-radius: 20px;
    /* Creates padding around thumb */
    border: 3px solid transparent;
    background-clip: content-box;
  }

  .dark .custom-scrollbar::-webkit-scrollbar-thumb {
    /* Tailwind zinc-600 */
    background-color: #52525b;
  }

  .custom-scrollbar::-webkit-scrollbar-thumb:hover {
    /* Tailwind zinc-500 */
    background-color: #71717a;
  }

  .dark .custom-scrollbar::-webkit-scrollbar-thumb:hover {
    /* Tailwind zinc-500 */
    background-color: #71717a;
  }

  /* Firefox scrollbar styling (optional but recommended) */
  .custom-scrollbar {
    scrollbar-width: thin;
    /* Tailwind zinc-400 / zinc-600 */
    scrollbar-color: #a1a1aa transparent;
  }

  .dark .custom-scrollbar {
    scrollbar-color: #52525b transparent;
  }
}

/*
  Styles for code formatting within the editor.
  These are generally fine and relate to specific elements, not base typography.
  Ensure the font sizes (text-sm) used here are readable on mobile within the editor context.
  If `text-sm` (0.875rem) becomes too small because the base `rem` value is effectively small on mobile,
  you might need to use responsive prefixes here too (e.g., `text-base md:text-sm`).
*/
.editor-pane code:not(pre > code) {
  /* Style for inline code */
  @apply bg-zinc-200 dark:bg-zinc-700 px-1 py-0.5 rounded font-mono text-sm text-red-600 dark:text-red-400;
}

.editor-pane pre {
  /* Style for code blocks */
  @apply bg-zinc-100 dark:bg-zinc-900 p-3 my-2 rounded overflow-auto font-mono text-sm block;
  white-space: pre;
  /* Important for preserving whitespace */
}

.editor-pane pre code {
  /* Style for code specifically within a pre block */
  @apply bg-transparent p-0 font-mono text-sm text-inherit dark:text-inherit;
  white-space: pre;
  /* Inherit whitespace preservation */
}

.editor-pane .shell-command {
  @apply bg-black dark:bg-black text-green-400 dark:text-green-300 p-3 my-2 rounded overflow-auto font-mono text-sm block;
  white-space: pre;
}

.editor-pane .shell-command::before {
  content: "$ ";
  color: #9ca3af;
  /* gray-400 */
}

.editor-pane {
  white-space: pre-wrap;
}

/* Ensure prose styles don't override code block styles too much */
.dark .prose-invert pre {
  @apply bg-zinc-900;
}

.prose pre {
  @apply bg-zinc-100;
}

.prose code:not(pre > code) {
  @apply bg-zinc-200 dark:bg-zinc-700 text-red-600 dark:text-red-400 px-1 py-0.5;
  font-weight: normal;
}

.prose code::before,
.prose code::after {
  content: none;
}

--- src\utils\constants.js ---
export const LOCAL_STORAGE_KEY = "myNotesTasksTree";

--- src\utils\searchUtils.js ---
export function escapeRegex(str) {
  return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

/**
 * Finds the first match of a query in text based on options.
 * @param {string} text The text to search within.
 * @param {string} query The search query.
 * @param {object} opts Search options (caseSensitive, wholeWord, useRegex).
 * @returns {object|null} An object { matchedString, startIndex } or null if no match.
 */
export function matchText(text, query, opts) {
  if (!query || text == null || typeof text !== 'string') return null;
  const flags = opts.caseSensitive ? '' : 'i';
  try {
    let pattern;
    if (opts.useRegex) {
      pattern = query;
    } else {
      // Use the (now exported) escapeRegex function
      const safe = escapeRegex(query);
      pattern = opts.wholeWord ? `\\b${safe}\\b` : safe;
    }
    const re = new RegExp(pattern, flags);
    const matchResult = re.exec(text);

    if (matchResult) {
      return {
        matchedString: matchResult[0],
        startIndex: matchResult.index,
      };
    }
    return null;
  } catch (e) {
    // console.error("Regex error in matchText:", e, query, text);
    return null;
  }
}

/**
 * Checks if an item matches the search query based on its type and relevant fields.
 * For folders, checks only the label.
 * For notes/tasks, checks label and content.
 * @param {object} item The item to check.
 * @param {string} query The search query.
 * @param {object} opts Search options.
 * @returns {boolean} True if the item is a match, false otherwise.
 */
export function itemMatches(item, query, opts) {
  if (!item || !query) return false;

  // Check label (common to all types that might have one)
  if (typeof item.label === 'string' && matchText(item.label, query, opts) !== null) {
    return true;
  }

  // Check title if it exists and differs from label
  if (typeof item.title === 'string' && item.title !== item.label && matchText(item.title, query, opts) !== null) {
    return true;
  }

  // Check content only for notes and tasks
  if ((item.type === 'note' || item.type === 'task') && typeof item.content === 'string') {
    // Convert HTML content to plain text before matching
    // Note: This assumes a simple HTML structure or requires a more robust HTML-to-text conversion
    // For efficiency, this conversion might ideally happen once when indexing or preparing search data,
    // but for direct matching, we do it here.
    let plainTextContent = '';
    try {
      const tempDiv = document.createElement("div");
      tempDiv.innerHTML = item.content;
      plainTextContent = tempDiv.textContent || tempDiv.innerText || "";
    } catch (e) { /* Ignore potential errors during conversion for search */ }

    if (matchText(plainTextContent, query, opts) !== null) {
      return true;
    }
  }

  return false;
}

--- src\utils\treeUtils.js ---
// src/utils/treeUtils.js

/**
 * Sorts items: folders first, then notes, then tasks, then alphabetically by label.
 * Returns a new sorted array (the original array is not mutated).
 */
export const sortItems = (items) => {
  if (!Array.isArray(items)) return [];
  // Return empty array if input is not an array
  // Create a shallow copy before sorting to avoid mutating the original array
  return [...items].sort((a, b) => {
    // Basic type checks to prevent errors if items lack 'type' or 'label'
    const typeA = a?.type ?? '';
    const typeB = b?.type ?? '';
    const labelA = a?.label ?? '';
    const labelB = b?.label ?? '';

    // Sort folders before notes/tasks
    if (typeA === "folder" && typeB !== "folder") return -1;
    if (typeA !== "folder" && typeB === "folder") return 1;

    // Sort notes before tasks (if types are not folders)
    if (typeA === "note" && typeB === "task") return -1;
    if (typeA === "task" && typeB === "note") return 1;

    // If types are the same (or both not folder/note/task), sort by label (case-insensitive)
    return labelA.localeCompare(labelB, undefined, { sensitivity: "base" });
  });
};

/**
 * Recursively deletes an item (by id) from a tree structure.
 * Returns a new tree array.
 */
export const deleteItemRecursive = (items, idToDelete) => {
  // Ensure working with an array, return empty if input is invalid
  const baseItems = Array.isArray(items) ? items : [];
  if (!idToDelete) return baseItems; // Return original array if no ID provided

  // Filter out the item at the current level
  return baseItems
    .filter((it) => it.id !== idToDelete)
    .map((it) => {
      // If the item is a folder and has children, recursively process its children
      if (it.type === "folder" && Array.isArray(it.children)) {
        const updatedChildren = deleteItemRecursive(it.children, idToDelete);
        // Only return a new object if children array actually changed
        return updatedChildren !== it.children ? { ...it, children: updatedChildren } : it;
      }
      // Return the item as is if it's not the one to delete or has no children to process
      return it;
    });
};

/**
 * Recursively finds an item by its id.
 * Returns the item object or null if not found.
 */
export const findItemById = (nodes, id) => {
  // Basic validation
  if (!Array.isArray(nodes) || !id) return null;
  for (const item of nodes) {
    // Check if the current item is the one we're looking for
    if (item.id === id) return item;
    // If the item is a folder and has children, search recursively within its children
    if (item.type === "folder" && Array.isArray(item.children)) {
      const found = findItemById(item.children, id);
      // If found in children, return the result immediately
      if (found) return found;
    }
  }
  // Item not found in the current level or its descendants
  return null;
};
/**
 * Finds the parent object and the siblings array of an item identified by itemId.
 * Returns an object { parent: object | null, siblings: array }.
 * If itemId is null (meaning root), parent is null and siblings is the root array.
 * If itemId is not found, returns { parent: null, siblings: [] }.
 */
export const findParentAndSiblings = (tree, itemId) => {
  // Ensure the input tree is an array
  if (!Array.isArray(tree)) {
    console.error("findParentAndSiblings: Input 'tree' is not an array.");
    return { parent: null, siblings: [] };
  }

  // Handle the case where we want the context for the root level
  if (itemId === null) {
    return { parent: null, siblings: tree };
  }

  // Recursive helper function to search the tree
  const findRecursive = (nodes, idToFind, currentParent = null) => {
    // Ensure nodes is an array before iterating
    if (!Array.isArray(nodes)) return null;
    for (let i = 0; i < nodes.length; i++) {
      const item = nodes[i];
      // Check if the current item is the one we are looking for
      if (item.id === idToFind) {
        // Found the item. Return its parent and the array containing the item (siblings).
        return { parent: currentParent, siblings: nodes };
      }
      // If the item is a folder and has children, recurse into the children
      if (item.type === "folder" && Array.isArray(item.children) && item.children.length > 0) {
        // Pass the current item as the parent for the next level of recursion
        const foundInChildren = findRecursive(item.children, idToFind, item);
        // If found in the recursive call, return the result immediately
        if (foundInChildren) return foundInChildren;
      }
    }
    // Item not found in this branch of the tree
    return null;
  };

  // Start the recursive search from the root of the tree
  const result = findRecursive(tree, itemId, null);
  if (result) {
    // Item was found, return the result { parent, siblings }
    return result;
  } else {
    // Item not found anywhere in the tree
    console.warn(`findParentAndSiblings: Could not find item with id ${itemId}`);
    // Return a default object indicating not found
    return { parent: null, siblings: [] };
  }
};
/**
 * Recursively renames an item in the tree. (Internal logic).
 * Returns a new tree array with the item renamed.
 */
export const renameItemRecursive = (items, idToRename, newLabel) => {
  const baseItems = Array.isArray(items) ? items : [];
  const trimmedLabel = newLabel.trim(); // Ensure label is trimmed

  return baseItems.map((it) => {
    // If this is the item to rename, return a new object with the updated label
    if (it.id === idToRename) {
      return { ...it, label: trimmedLabel };
    }
    // If the item has children, recursively attempt to rename within the children
    if (Array.isArray(it.children)) {
      const updatedChildren = renameItemRecursive(it.children, idToRename, trimmedLabel);
      // Only create a new parent object if the children array actually changed
      return updatedChildren !== it.children ? { ...it, children: updatedChildren } : it;
    }
    // If not the item and has no children (or not a folder), return the item unchanged
    return it;
  });
};

/**
 * Recursively inserts an item into the tree structure.
 * If targetFolderId is null, the item is added to the root.
 * Ensures the children list of the target folder remains sorted.
 * Returns a new tree array.
 */
export const insertItemRecursive = (nodes, targetFolderId, itemToInsert) => {
  const baseNodes = Array.isArray(nodes) ? nodes : [];
  // Case 1: Add to root
  if (targetFolderId === null) {
    // Add the new item and sort the root level
    return sortItems([...baseNodes, itemToInsert]);
  }

  // Case 2: Add to a specific folder
  return baseNodes.map((node) => {
    // If this node is the target folder
    if (node.id === targetFolderId && node.type === "folder") {
      const currentChildren = Array.isArray(node.children) ? node.children : [];
      // Return a new folder object with the new item added and children sorted
      return {
        ...node,
        children: sortItems([...currentChildren, itemToInsert]),
      };
    }
    // If the node has children, recurse into them
    else if (Array.isArray(node.children)) {
      const updatedChildren = insertItemRecursive(node.children, targetFolderId, itemToInsert);
      // Only create a new node object if its children actually changed
      return updatedChildren !== node.children ? { ...node, children: updatedChildren } : node;
    }
    // If not the target and no children to recurse into, return the node unchanged
    return node;
  });
};

/**
 * Checks if a name conflicts with existing siblings (case-insensitive comparison).
 * excludeId is used during rename to avoid comparing an item with itself.
 */
export const hasSiblingWithName = (siblings, nameToCheck, excludeId = null) => {
  // Basic validation: ensure siblings is an array and nameToCheck is provided
  if (!Array.isArray(siblings) || !nameToCheck) return false;
  // Normalize the name to check (trim whitespace, convert to lowercase)
  const normalizedName = nameToCheck.trim().toLowerCase();
  // If the normalized name is empty, it cannot conflict
  if (!normalizedName) return false;
  // Check if 'some' sibling matches the criteria
  return siblings.some(sibling =>
    sibling &&                                  // Ensure sibling exists
    sibling.id !== excludeId &&                 // Don't compare item with itself if excludeId is given
    sibling.label &&                         // Ensure sibling has a label
    sibling.label.trim().toLowerCase() === normalizedName // Perform case-insensitive comparison
  );
};

/**
 * Checks if 'checkItemId' is the same as or an ancestor of 'potentialTargetId'.
 * Used to prevent dropping/pasting a folder into itself or its descendants.
 */
export const isSelfOrDescendant = (nodes, checkItemId, potentialTargetId) => {
  // Basic validation: requires both IDs
  if (!checkItemId || !potentialTargetId) return false;
  // An item is its own ancestor in this context
  if (checkItemId === potentialTargetId) return true;
  // Find the item that might be the ancestor
  const item = findItemById(nodes, checkItemId);
  // If the item isn't found, or it's not a folder, it can't be an ancestor
  if (!item || item.type !== "folder" || !Array.isArray(item.children)) return false;
  // Recursive helper to check children
  const checkChildren = (children) => {
    if (!Array.isArray(children)) return false;
    for (const child of children) {
      // If a child matches the target ID, then the target is a descendant
      if (child.id === potentialTargetId) return true;
      // If the child is a folder, recursively check its children
      if (child.type === "folder" && Array.isArray(child.children)) {
        if (checkChildren(child.children)) return true; // Found in sub-branch
      }
    }
    // Target not found in this branch
    return false;
  };

  // Start the check from the children of the potential ancestor item
  return checkChildren(item.children);
};
/**
 * Handles the drop operation validation and data preparation for drag-and-drop.
 * Returns a new tree structure if drop is valid, otherwise null.
 * Includes validation for target type, ancestor dropping, and name conflicts.
 */
export const handleDrop = (currentTree, targetId, draggedId) => {
  // --- Basic Validation ---
  if (!targetId || !draggedId || targetId === draggedId) {
    console.warn("Drop cancelled: Invalid IDs or target is the same as the dragged item.", { targetId, draggedId });
    return null;
  }

  // --- Find Items ---
  const targetItem = findItemById(currentTree, targetId);
  const draggedItemData = findItemById(currentTree, draggedId);
  // --- Target Validation ---
  if (!targetItem) {
    console.warn(`Drop cancelled: Target item ${targetId} could not be found.`);
    return null;
  }
  if (targetItem.type !== "folder") {
    console.warn(`Drop cancelled: Target item ${targetId} ('${targetItem.label}') is not a folder.`);
    return null;
  }

  // --- Dragged Item Validation ---
  if (!draggedItemData) {
    console.error(`Drop cancelled: Dragged item data for ${draggedId} not found.`);
    return null;
  }

  // --- Ancestor Check (Prevent dropping a folder into itself/descendant) ---
  if (draggedItemData.type === "folder" && isSelfOrDescendant(currentTree, draggedItemData.id, targetId)) {
    const errorMsg = `Cannot drop folder '${draggedItemData.label}' into itself or one of its subfolders.`;
    console.warn("Drop prevented: Ancestor check failed.", errorMsg);
    alert(errorMsg); // User feedback
    return null;
  }

  // --- Sibling Name Conflict Check (Prevent dropping if name exists in target) ---
  const targetSiblings = targetItem.children || [];
  if (hasSiblingWithName(targetSiblings, draggedItemData.label, null)) { // excludeId is null because it's a new item in this context
      const errorMsg = `Cannot move item: An item named '${draggedItemData.label}' already exists in the target folder '${targetItem.label}'.`;
      console.warn("Drop prevented: Name conflict.", errorMsg);
      alert(errorMsg); // User feedback
      return null;
  }


  // --- Drop Logic ---
  // 1. Deep copy the dragged item (using structuredClone if available, fallback to JSON)
  let draggedItemCopy;
  try {
    draggedItemCopy = typeof structuredClone === "function"
      ? structuredClone(draggedItemData)
      : JSON.parse(JSON.stringify(draggedItemData));
  } catch (error) {
    console.error("Failed to deep copy dragged item:", error, draggedItemData);
    return null; // Abort if copy fails
  }

  // 2. Remove the original dragged item recursively from a copy of the tree
  const treeWithoutDraggedItem = deleteItemRecursive(currentTree, draggedId);
  // Verify removal happened (optional but good practice)
   if (JSON.stringify(treeWithoutDraggedItem) === JSON.stringify(currentTree)) {
      console.error("Drop failed: Removal of dragged item did not change the tree structure.", { draggedId }); // This indicates the draggedId might not have been found, despite earlier checks.
      return null;
  }


  // 3. Insert the copy into the target folder recursively
  const finalTree = insertItemRecursive(treeWithoutDraggedItem, targetId, draggedItemCopy);
  // Verify insertion happened (optional but good practice)
    if (JSON.stringify(finalTree) === JSON.stringify(treeWithoutDraggedItem)) {
      console.error("Drop failed: Insertion of dragged item copy did not change the tree structure.", { targetId, draggedId }); // This indicates the targetId might not have been found during insertion.
      return null;
    }

  return finalTree; // Return the new tree structure
};

// ********** NEW FUNCTION **********
/**
 * Gets the hierarchical path labels for a given item ID.
 * Returns the path as a string (e.g., "Root / Folder A / Item B").
 */
export const getItemPath = (tree, itemId) => {
  const pathLabels = [];
  // Recursive function to find the item and build the path upwards
  const findPathRecursive = (nodes, idToFind, currentPath = []) => {
    if (!Array.isArray(nodes)) return false; // Base case: invalid node structure

    for (const item of nodes) {
      // Create the potential path including the current item
      const newPath = [...currentPath, item.label];

      // Check if the current item is the one we're looking for
      if (item.id === idToFind) {
        pathLabels.push(...newPath); // Store the found path
        return true; // Indicate found
      }

      // If the current item is a folder and has children, search recursively
      if (item.type === "folder" && Array.isArray(item.children) && item.children.length > 0) {
        if (findPathRecursive(item.children, idToFind, newPath)) {
          return true; // Indicate found in children
        }
      }
    }
    return false; // Item not found in this branch
  };

  // Start the search from the root of the tree
  findPathRecursive(tree, itemId);

  // Join the collected labels into a string path, or return an empty string if not found
  return pathLabels.join(' / ');
};
// ********** END NEW FUNCTION **********

--- src\utils\constants.js ---
export const LOCAL_STORAGE_KEY = "myNotesTasksTree";

--- src\utils\searchUtils.js ---
export function escapeRegex(str) {
  return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

/**
 * Finds the first match of a query in text based on options.
 * @param {string} text The text to search within.
 * @param {string} query The search query.
 * @param {object} opts Search options (caseSensitive, wholeWord, useRegex).
 * @returns {object|null} An object { matchedString, startIndex } or null if no match.
 */
export function matchText(text, query, opts) {
  if (!query || text == null || typeof text !== 'string') return null;
  const flags = opts.caseSensitive ? '' : 'i';
  try {
    let pattern;
    if (opts.useRegex) {
      pattern = query;
    } else {
      // Use the (now exported) escapeRegex function
      const safe = escapeRegex(query);
      pattern = opts.wholeWord ? `\\b${safe}\\b` : safe;
    }
    const re = new RegExp(pattern, flags);
    const matchResult = re.exec(text);

    if (matchResult) {
      return {
        matchedString: matchResult[0],
        startIndex: matchResult.index,
      };
    }
    return null;
  } catch (e) {
    // console.error("Regex error in matchText:", e, query, text);
    return null;
  }
}

/**
 * Checks if an item matches the search query based on its type and relevant fields.
 * For folders, checks only the label.
 * For notes/tasks, checks label and content.
 * @param {object} item The item to check.
 * @param {string} query The search query.
 * @param {object} opts Search options.
 * @returns {boolean} True if the item is a match, false otherwise.
 */
export function itemMatches(item, query, opts) {
  if (!item || !query) return false;

  // Check label (common to all types that might have one)
  if (typeof item.label === 'string' && matchText(item.label, query, opts) !== null) {
    return true;
  }

  // Check title if it exists and differs from label
  if (typeof item.title === 'string' && item.title !== item.label && matchText(item.title, query, opts) !== null) {
    return true;
  }

  // Check content only for notes and tasks
  if ((item.type === 'note' || item.type === 'task') && typeof item.content === 'string') {
    // Convert HTML content to plain text before matching
    // Note: This assumes a simple HTML structure or requires a more robust HTML-to-text conversion
    // For efficiency, this conversion might ideally happen once when indexing or preparing search data,
    // but for direct matching, we do it here.
    let plainTextContent = '';
    try {
      const tempDiv = document.createElement("div");
      tempDiv.innerHTML = item.content;
      plainTextContent = tempDiv.textContent || tempDiv.innerText || "";
    } catch (e) { /* Ignore potential errors during conversion for search */ }

    if (matchText(plainTextContent, query, opts) !== null) {
      return true;
    }
  }

  return false;
}

--- src\utils\treeUtils.js ---
// src/utils/treeUtils.js

/**
 * Sorts items: folders first, then notes, then tasks, then alphabetically by label.
 * Returns a new sorted array (the original array is not mutated).
 */
export const sortItems = (items) => {
  if (!Array.isArray(items)) return [];
  // Return empty array if input is not an array
  // Create a shallow copy before sorting to avoid mutating the original array
  return [...items].sort((a, b) => {
    // Basic type checks to prevent errors if items lack 'type' or 'label'
    const typeA = a?.type ?? '';
    const typeB = b?.type ?? '';
    const labelA = a?.label ?? '';
    const labelB = b?.label ?? '';

    // Sort folders before notes/tasks
    if (typeA === "folder" && typeB !== "folder") return -1;
    if (typeA !== "folder" && typeB === "folder") return 1;

    // Sort notes before tasks (if types are not folders)
    if (typeA === "note" && typeB === "task") return -1;
    if (typeA === "task" && typeB === "note") return 1;

    // If types are the same (or both not folder/note/task), sort by label (case-insensitive)
    return labelA.localeCompare(labelB, undefined, { sensitivity: "base" });
  });
};

/**
 * Recursively deletes an item (by id) from a tree structure.
 * Returns a new tree array.
 */
export const deleteItemRecursive = (items, idToDelete) => {
  // Ensure working with an array, return empty if input is invalid
  const baseItems = Array.isArray(items) ? items : [];
  if (!idToDelete) return baseItems; // Return original array if no ID provided

  // Filter out the item at the current level
  return baseItems
    .filter((it) => it.id !== idToDelete)
    .map((it) => {
      // If the item is a folder and has children, recursively process its children
      if (it.type === "folder" && Array.isArray(it.children)) {
        const updatedChildren = deleteItemRecursive(it.children, idToDelete);
        // Only return a new object if children array actually changed
        return updatedChildren !== it.children ? { ...it, children: updatedChildren } : it;
      }
      // Return the item as is if it's not the one to delete or has no children to process
      return it;
    });
};

/**
 * Recursively finds an item by its id.
 * Returns the item object or null if not found.
 */
export const findItemById = (nodes, id) => {
  // Basic validation
  if (!Array.isArray(nodes) || !id) return null;
  for (const item of nodes) {
    // Check if the current item is the one we're looking for
    if (item.id === id) return item;
    // If the item is a folder and has children, search recursively within its children
    if (item.type === "folder" && Array.isArray(item.children)) {
      const found = findItemById(item.children, id);
      // If found in children, return the result immediately
      if (found) return found;
    }
  }
  // Item not found in the current level or its descendants
  return null;
};
/**
 * Finds the parent object and the siblings array of an item identified by itemId.
 * Returns an object { parent: object | null, siblings: array }.
 * If itemId is null (meaning root), parent is null and siblings is the root array.
 * If itemId is not found, returns { parent: null, siblings: [] }.
 */
export const findParentAndSiblings = (tree, itemId) => {
  // Ensure the input tree is an array
  if (!Array.isArray(tree)) {
    console.error("findParentAndSiblings: Input 'tree' is not an array.");
    return { parent: null, siblings: [] };
  }

  // Handle the case where we want the context for the root level
  if (itemId === null) {
    return { parent: null, siblings: tree };
  }

  // Recursive helper function to search the tree
  const findRecursive = (nodes, idToFind, currentParent = null) => {
    // Ensure nodes is an array before iterating
    if (!Array.isArray(nodes)) return null;
    for (let i = 0; i < nodes.length; i++) {
      const item = nodes[i];
      // Check if the current item is the one we are looking for
      if (item.id === idToFind) {
        // Found the item. Return its parent and the array containing the item (siblings).
        return { parent: currentParent, siblings: nodes };
      }
      // If the item is a folder and has children, recurse into the children
      if (item.type === "folder" && Array.isArray(item.children) && item.children.length > 0) {
        // Pass the current item as the parent for the next level of recursion
        const foundInChildren = findRecursive(item.children, idToFind, item);
        // If found in the recursive call, return the result immediately
        if (foundInChildren) return foundInChildren;
      }
    }
    // Item not found in this branch of the tree
    return null;
  };

  // Start the recursive search from the root of the tree
  const result = findRecursive(tree, itemId, null);
  if (result) {
    // Item was found, return the result { parent, siblings }
    return result;
  } else {
    // Item not found anywhere in the tree
    console.warn(`findParentAndSiblings: Could not find item with id ${itemId}`);
    // Return a default object indicating not found
    return { parent: null, siblings: [] };
  }
};
/**
 * Recursively renames an item in the tree. (Internal logic).
 * Returns a new tree array with the item renamed.
 */
export const renameItemRecursive = (items, idToRename, newLabel) => {
  const baseItems = Array.isArray(items) ? items : [];
  const trimmedLabel = newLabel.trim(); // Ensure label is trimmed

  return baseItems.map((it) => {
    // If this is the item to rename, return a new object with the updated label
    if (it.id === idToRename) {
      return { ...it, label: trimmedLabel };
    }
    // If the item has children, recursively attempt to rename within the children
    if (Array.isArray(it.children)) {
      const updatedChildren = renameItemRecursive(it.children, idToRename, trimmedLabel);
      // Only create a new parent object if the children array actually changed
      return updatedChildren !== it.children ? { ...it, children: updatedChildren } : it;
    }
    // If not the item and has no children (or not a folder), return the item unchanged
    return it;
  });
};

/**
 * Recursively inserts an item into the tree structure.
 * If targetFolderId is null, the item is added to the root.
 * Ensures the children list of the target folder remains sorted.
 * Returns a new tree array.
 */
export const insertItemRecursive = (nodes, targetFolderId, itemToInsert) => {
  const baseNodes = Array.isArray(nodes) ? nodes : [];
  // Case 1: Add to root
  if (targetFolderId === null) {
    // Add the new item and sort the root level
    return sortItems([...baseNodes, itemToInsert]);
  }

  // Case 2: Add to a specific folder
  return baseNodes.map((node) => {
    // If this node is the target folder
    if (node.id === targetFolderId && node.type === "folder") {
      const currentChildren = Array.isArray(node.children) ? node.children : [];
      // Return a new folder object with the new item added and children sorted
      return {
        ...node,
        children: sortItems([...currentChildren, itemToInsert]),
      };
    }
    // If the node has children, recurse into them
    else if (Array.isArray(node.children)) {
      const updatedChildren = insertItemRecursive(node.children, targetFolderId, itemToInsert);
      // Only create a new node object if its children actually changed
      return updatedChildren !== node.children ? { ...node, children: updatedChildren } : node;
    }
    // If not the target and no children to recurse into, return the node unchanged
    return node;
  });
};

/**
 * Checks if a name conflicts with existing siblings (case-insensitive comparison).
 * excludeId is used during rename to avoid comparing an item with itself.
 */
export const hasSiblingWithName = (siblings, nameToCheck, excludeId = null) => {
  // Basic validation: ensure siblings is an array and nameToCheck is provided
  if (!Array.isArray(siblings) || !nameToCheck) return false;
  // Normalize the name to check (trim whitespace, convert to lowercase)
  const normalizedName = nameToCheck.trim().toLowerCase();
  // If the normalized name is empty, it cannot conflict
  if (!normalizedName) return false;
  // Check if 'some' sibling matches the criteria
  return siblings.some(sibling =>
    sibling &&                                  // Ensure sibling exists
    sibling.id !== excludeId &&                 // Don't compare item with itself if excludeId is given
    sibling.label &&                         // Ensure sibling has a label
    sibling.label.trim().toLowerCase() === normalizedName // Perform case-insensitive comparison
  );
};

/**
 * Checks if 'checkItemId' is the same as or an ancestor of 'potentialTargetId'.
 * Used to prevent dropping/pasting a folder into itself or its descendants.
 */
export const isSelfOrDescendant = (nodes, checkItemId, potentialTargetId) => {
  // Basic validation: requires both IDs
  if (!checkItemId || !potentialTargetId) return false;
  // An item is its own ancestor in this context
  if (checkItemId === potentialTargetId) return true;
  // Find the item that might be the ancestor
  const item = findItemById(nodes, checkItemId);
  // If the item isn't found, or it's not a folder, it can't be an ancestor
  if (!item || item.type !== "folder" || !Array.isArray(item.children)) return false;
  // Recursive helper to check children
  const checkChildren = (children) => {
    if (!Array.isArray(children)) return false;
    for (const child of children) {
      // If a child matches the target ID, then the target is a descendant
      if (child.id === potentialTargetId) return true;
      // If the child is a folder, recursively check its children
      if (child.type === "folder" && Array.isArray(child.children)) {
        if (checkChildren(child.children)) return true; // Found in sub-branch
      }
    }
    // Target not found in this branch
    return false;
  };

  // Start the check from the children of the potential ancestor item
  return checkChildren(item.children);
};
/**
 * Handles the drop operation validation and data preparation for drag-and-drop.
 * Returns a new tree structure if drop is valid, otherwise null.
 * Includes validation for target type, ancestor dropping, and name conflicts.
 */
export const handleDrop = (currentTree, targetId, draggedId) => {
  // --- Basic Validation ---
  if (!targetId || !draggedId || targetId === draggedId) {
    console.warn("Drop cancelled: Invalid IDs or target is the same as the dragged item.", { targetId, draggedId });
    return null;
  }

  // --- Find Items ---
  const targetItem = findItemById(currentTree, targetId);
  const draggedItemData = findItemById(currentTree, draggedId);
  // --- Target Validation ---
  if (!targetItem) {
    console.warn(`Drop cancelled: Target item ${targetId} could not be found.`);
    return null;
  }
  if (targetItem.type !== "folder") {
    console.warn(`Drop cancelled: Target item ${targetId} ('${targetItem.label}') is not a folder.`);
    return null;
  }

  // --- Dragged Item Validation ---
  if (!draggedItemData) {
    console.error(`Drop cancelled: Dragged item data for ${draggedId} not found.`);
    return null;
  }

  // --- Ancestor Check (Prevent dropping a folder into itself/descendant) ---
  if (draggedItemData.type === "folder" && isSelfOrDescendant(currentTree, draggedItemData.id, targetId)) {
    const errorMsg = `Cannot drop folder '${draggedItemData.label}' into itself or one of its subfolders.`;
    console.warn("Drop prevented: Ancestor check failed.", errorMsg);
    alert(errorMsg); // User feedback
    return null;
  }

  // --- Sibling Name Conflict Check (Prevent dropping if name exists in target) ---
  const targetSiblings = targetItem.children || [];
  if (hasSiblingWithName(targetSiblings, draggedItemData.label, null)) { // excludeId is null because it's a new item in this context
      const errorMsg = `Cannot move item: An item named '${draggedItemData.label}' already exists in the target folder '${targetItem.label}'.`;
      console.warn("Drop prevented: Name conflict.", errorMsg);
      alert(errorMsg); // User feedback
      return null;
  }


  // --- Drop Logic ---
  // 1. Deep copy the dragged item (using structuredClone if available, fallback to JSON)
  let draggedItemCopy;
  try {
    draggedItemCopy = typeof structuredClone === "function"
      ? structuredClone(draggedItemData)
      : JSON.parse(JSON.stringify(draggedItemData));
  } catch (error) {
    console.error("Failed to deep copy dragged item:", error, draggedItemData);
    return null; // Abort if copy fails
  }

  // 2. Remove the original dragged item recursively from a copy of the tree
  const treeWithoutDraggedItem = deleteItemRecursive(currentTree, draggedId);
  // Verify removal happened (optional but good practice)
   if (JSON.stringify(treeWithoutDraggedItem) === JSON.stringify(currentTree)) {
      console.error("Drop failed: Removal of dragged item did not change the tree structure.", { draggedId }); // This indicates the draggedId might not have been found, despite earlier checks.
      return null;
  }


  // 3. Insert the copy into the target folder recursively
  const finalTree = insertItemRecursive(treeWithoutDraggedItem, targetId, draggedItemCopy);
  // Verify insertion happened (optional but good practice)
    if (JSON.stringify(finalTree) === JSON.stringify(treeWithoutDraggedItem)) {
      console.error("Drop failed: Insertion of dragged item copy did not change the tree structure.", { targetId, draggedId }); // This indicates the targetId might not have been found during insertion.
      return null;
    }

  return finalTree; // Return the new tree structure
};

// ********** NEW FUNCTION **********
/**
 * Gets the hierarchical path labels for a given item ID.
 * Returns the path as a string (e.g., "Root / Folder A / Item B").
 */
export const getItemPath = (tree, itemId) => {
  const pathLabels = [];
  // Recursive function to find the item and build the path upwards
  const findPathRecursive = (nodes, idToFind, currentPath = []) => {
    if (!Array.isArray(nodes)) return false; // Base case: invalid node structure

    for (const item of nodes) {
      // Create the potential path including the current item
      const newPath = [...currentPath, item.label];

      // Check if the current item is the one we're looking for
      if (item.id === idToFind) {
        pathLabels.push(...newPath); // Store the found path
        return true; // Indicate found
      }

      // If the current item is a folder and has children, search recursively
      if (item.type === "folder" && Array.isArray(item.children) && item.children.length > 0) {
        if (findPathRecursive(item.children, idToFind, newPath)) {
          return true; // Indicate found in children
        }
      }
    }
    return false; // Item not found in this branch
  };

  // Start the search from the root of the tree
  findPathRecursive(tree, itemId);

  // Join the collected labels into a string path, or return an empty string if not found
  return pathLabels.join(' / ');
};
// ********** END NEW FUNCTION **********

--- src\.gitignore ---
# Node dependencies
node_modules/

# Logs
logs/
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# Runtime files
pids/
*.pid
*.seed
*.pid.lock

# Build output
dist/
build/

# Coverage reports
coverage/

# Environment variables
.env
.env.*.local

# Editor directories and settings
.vscode/
.idea/
*.suo
*.ntvs*
*.njsproj
*.sln

# OS generated files
.DS_Store
Thumbs.db
ehthumbs.db

# lockfiles (optional‚Äîkeep if you want to track versioning)
# package-lock.json
# yarn.lock

# TypeScript build info
*.tsbuildinfo

# Next.js
.next/

# Gatsby
.cache/
public/

# Parcel bundler
.parcel-cache/

# Testing
jest.config.js
jest.local.js

# Misc
npm-debug.log*
yarn-error.log*

# ignore build output
dist/

--- src\App.jsx ---
// src/App.jsx
import React, { useState, useEffect, useCallback, useRef } from "react";
// ... (all your existing imports, ensure useSettings and useTree are present)
import Tree from "./components/Tree";
import FolderContents from "./components/FolderContents";
import ContentEditor from "./components/ContentEditor";
import ContextMenu from "./components/ContextMenu";
import AddDialog from "./components/AddDialog";
import AboutDialog from "./components/AboutDialog";
import ExportDialog from "./components/ExportDialog";
import ImportDialog from "./components/ImportDialog";
import SettingsDialog from "./components/SettingsDialog";
import { useTree } from "./hooks/useTree.jsx";
import { useSettings } from "./contexts/SettingsContext";
import {
  findItemById as findItemByIdUtil,
  findParentAndSiblings as findParentAndSiblingsUtil,
} from "./utils/treeUtils";
import { Panel, PanelGroup, PanelResizeHandle } from "react-resizable-panels";
import {
  Search as SearchIcon,
  Info,
  EllipsisVertical,
  XCircle,
  Settings as SettingsIcon,
  Undo,
  Redo,
  LogOut,
  FileJson,
} from "lucide-react";
import SearchResultsPane from "./components/SearchResultsPane";
import { matchText } from "./utils/searchUtils";
import { Sheet } from "react-modal-sheet";
import Login from "./components/Login";
import Register from "./components/Register";

// Helper function to generate timestamped filename
function getTimestampedFilename(baseName = "tree-export", extension = "json") {
  const now = new Date();
  const year = now.getFullYear();
  const month = (now.getMonth() + 1).toString().padStart(2, "0");
  const day = now.getDate().toString().padStart(2, "0");
  const hours = now.getHours().toString().padStart(2, "0");
  const minutes = now.getMinutes().toString().padStart(2, "0");
  const seconds = now.getSeconds().toString().padStart(2, "0");
  return `${baseName}-${year}${month}${day}-${hours}${minutes}${seconds}.${extension}`;
}

function htmlToPlainTextWithNewlines(html) {
  if (!html) return "";
  let text = html;
  text = text.replace(
    /<(div|p|h[1-6]|li|blockquote|pre|tr|hr)[^>]*>/gi,
    "\n$&"
  );
  text = text.replace(/<br\s*\/?>/gi, "\n");
  text = text.replace(/<[^>]+>/g, "");
  try {
    const tempDiv = document.createElement("div");
    tempDiv.innerHTML = text;
    text = tempDiv.textContent || tempDiv.innerText || "";
  } catch (e) {
    /* ignore */
  }
  return text.replace(/(\r?\n|\r){2,}/g, "\n").trim();
}

const APP_HEADER_HEIGHT_CLASS = "h-14 sm:h-12";

const ErrorDisplay = ({ message, type = "error", onClose }) => {
  if (!message) return null;
  useEffect(() => {
    const timer = setTimeout(() => onClose(), 5000);
    return () => clearTimeout(timer);
  }, [message, onClose]);

  const baseClasses =
    "fixed top-3 right-3 left-3 md:left-auto md:max-w-lg z-[100] px-4 py-3 rounded-lg shadow-xl flex justify-between items-center text-sm transition-all duration-300 ease-in-out";
  let typeClasses =
    type === "success"
      ? "bg-green-100 dark:bg-green-800/80 border border-green-400 dark:border-green-600 text-green-700 dark:text-green-200"
      : type === "info"
      ? "bg-sky-100 dark:bg-sky-800/80 border border-sky-400 dark:border-sky-600 text-sky-700 dark:text-sky-200"
      : "bg-red-100 dark:bg-red-800/80 border border-red-400 dark:border-red-600 text-red-700 dark:text-red-200";

  const iconColor =
    type === "success"
      ? "text-green-500 hover:text-green-700 dark:text-green-300 dark:hover:text-green-100"
      : type === "info"
      ? "text-sky-500 hover:text-sky-700 dark:text-sky-300 dark:hover:text-sky-100"
      : "text-red-500 hover:text-red-700 dark:text-red-300 dark:hover:text-red-100";

  return (
    <div className={`${baseClasses} ${typeClasses}`}>
      <span>{message}</span>
      <button
        onClick={onClose}
        className={`ml-3 -mr-1 -my-1 p-1 ${iconColor} rounded-full focus:outline-none focus:ring-2 focus:ring-current`}
        aria-label="Close message"
      >
        <XCircle className="w-5 h-5" />
      </button>
    </div>
  );
};

const App = () => {
  const { settings } = useSettings();
  const {
    tree,
    selectedItem,
    selectedItemId,
    selectItemById,
    contextMenu,
    setContextMenu,
    expandedFolders,
    toggleFolderExpand,
    expandFolderPath,
    getItemPath,
    updateNoteContent,
    updateTask,
    renameItem,
    deleteItem,
    draggedId,
    setDraggedId,
    handleDrop,
    clipboardItem,
    copyItem,
    cutItem,
    pasteItem,
    addItem,
    duplicateItem,
    handleExport,
    handleImport: handleImportFromHook,
    searchItems,
    undoTreeChange,
    redoTreeChange,
    canUndoTree,
    canRedoTree,
    resetState: resetTreeHistory,
    fetchUserTree,
    isFetchingTree,
  } = useTree();

  // Moved State Declarations to the top
  const [currentUser, setCurrentUser] = useState(null);
  const [isAuthCheckComplete, setIsAuthCheckComplete] = useState(false);
  const [currentView, setCurrentView] = useState("login"); // Now declared before use in useEffects

  const [uiMessage, setUiMessage] = useState("");
  const [uiMessageType, setUiMessageType] = useState("error");

  const [searchSheetOpen, setSearchSheetOpen] = useState(false);
  const [searchQuery, setSearchQuery] = useState("");
  const [searchOptions, setSearchOptions] = useState({
    caseSensitive: false,
    wholeWord: false,
    useRegex: false,
  });
  const [searchResults, setSearchResults] = useState([]);
  const [addDialogOpen, setAddDialogOpen] = useState(false);
  const [newItemType, setNewItemType] = useState("folder");
  const [newItemLabel, setNewItemLabel] = useState("");
  const [addDialogErrorMessage, setAddDialogErrorMessage] = useState("");
  const [parentItemForAdd, setParentItemForAdd] = useState(null);
  const [inlineRenameId, setInlineRenameId] = useState(null);
  const [inlineRenameValue, setInlineRenameValue] = useState("");
  const [aboutDialogOpen, setAboutDialogOpen] = useState(false);
  const [exportDialogState, setExportDialogState] = useState({
    isOpen: false,
    context: null,
  });
  const [importDialogState, setImportDialogState] = useState({
    isOpen: false,
    context: null,
  });
  const [settingsDialogOpen, setSettingsDialogOpen] = useState(false);
  const [topMenuOpen, setTopMenuOpen] = useState(false);
  const topMenuRef = useRef(null);

  const showMessage = useCallback(
    (message, type = "error", duration = 5000) => {
      setUiMessage(message);
      setUiMessageType(type);
    },
    []
  );

  // --- Auto Export Logic ---
  const autoExportIntervalRef = useRef(null);

  useEffect(() => {
    if (autoExportIntervalRef.current) {
      clearInterval(autoExportIntervalRef.current);
      autoExportIntervalRef.current = null;
    }

    const canRunAutoExport =
      settings.autoExportEnabled &&
      settings.autoExportIntervalMinutes >= 1 &&
      currentView === "app" &&
      currentUser;

    if (canRunAutoExport) {
      const intervalMs = settings.autoExportIntervalMinutes * 60 * 1000;
      const performAutoExport = () => {
        if (!tree || tree.length === 0) {
          console.info("Auto Export: Tree is empty, skipping export.");
          return;
        }
        const exportFormat = settings.defaultExportFormat || "json";
        const filename = getTimestampedFilename(
          "auto-tree-export",
          exportFormat
        );
        console.log(`Auto Export: Triggering export of tree as ${filename}`);
        showMessage(`Auto-exporting as ${filename}...`, "info", 2000);
        try {
          const dataToExport = tree;
          if (exportFormat === "json") {
            const jsonStr = JSON.stringify(dataToExport, null, 2);
            const blob = new Blob([jsonStr], { type: "application/json" });
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            console.log(
              `Auto Export: Successfully triggered download for ${filename}`
            );
          } else if (exportFormat === "pdf") {
            console.warn(
              `PDF auto-export for ${filename} needs specific PDF generation logic.`
            );
            showMessage(
              `PDF Auto-export for ${filename} (not implemented).`,
              "info",
              3000
            );
          }
        } catch (error) {
          console.error("Auto Export: Failed to export data.", error);
          showMessage("Auto export failed.", "error");
        }
      };
      autoExportIntervalRef.current = setInterval(
        performAutoExport,
        intervalMs
      );
      console.log(
        `Auto Export: Enabled. Interval set to ${settings.autoExportIntervalMinutes} minutes.`
      );
      showMessage(
        `Auto-export active: every ${settings.autoExportIntervalMinutes} min.`,
        "info",
        4000
      );
    } else {
      if (
        settings.autoExportEnabled &&
        (currentView !== "app" || !currentUser)
      ) {
        console.log("Auto Export: Paused (not in app view or no user).");
      } else if (!settings.autoExportEnabled) {
        console.log("Auto Export: Disabled.");
      }
    }
    return () => {
      if (autoExportIntervalRef.current) {
        clearInterval(autoExportIntervalRef.current);
        autoExportIntervalRef.current = null;
        console.log("Auto Export: Interval cleared.");
      }
    };
  }, [
    settings.autoExportEnabled,
    settings.autoExportIntervalMinutes,
    settings.defaultExportFormat,
    tree,
    showMessage,
    currentView,
    currentUser,
  ]);
  // --- End Auto Export Logic ---

  useEffect(() => {
    // Initial Auth Check
    const token = localStorage.getItem("userToken");
    if (token && fetchUserTree) {
      setCurrentUser({ token });
      setCurrentView("app");
      fetchUserTree(token).finally(() => setIsAuthCheckComplete(true));
    } else {
      setCurrentView("login");
      if (resetTreeHistory) resetTreeHistory([]);
      setIsAuthCheckComplete(true);
    }
  }, [fetchUserTree, resetTreeHistory]);

  const handleLoginSuccess = async (userData) => {
    setCurrentUser(userData);
    setCurrentView("app");
    if (fetchUserTree) {
      await fetchUserTree(localStorage.getItem("userToken"));
    }
  };

  const handleLogout = () => {
    localStorage.removeItem("userToken");
    setCurrentUser(null);
    if (resetTreeHistory) resetTreeHistory([]);
    showMessage("");
    setCurrentView("login");
  };

  // ... (all other useCallback and useEffect hooks from your App.jsx)
  const startInlineRename = useCallback(
    (item) => {
      if (!item || draggedId === item.id || inlineRenameId) return;
      showMessage("", "error");
      setInlineRenameId(item.id);
      setInlineRenameValue(item.label);
      setContextMenu((m) => ({ ...m, visible: false }));
    },
    [draggedId, inlineRenameId, showMessage, setContextMenu]
  );
  const cancelInlineRename = useCallback(() => {
    setInlineRenameId(null);
    setInlineRenameValue("");
    showMessage("", "error");
    requestAnimationFrame(() => {
      const treeNav = document.querySelector(
        'nav[aria-label="Notes and Tasks Tree"]'
      );
      treeNav?.focus({ preventScroll: true });
    });
  }, [showMessage]);
  const findItemByIdFromTree = useCallback(
    (id) => findItemByIdUtil(tree, id),
    [tree]
  );
  const findParentAndSiblingsFromTree = useCallback(
    (id) => findParentAndSiblingsUtil(tree, id),
    [tree]
  );
  const handleAttemptRename = useCallback(async () => {
    if (!inlineRenameId) return;
    const newLabel = inlineRenameValue.trim();
    const originalItem = findItemByIdFromTree(inlineRenameId);
    if (!newLabel) {
      showMessage("Name cannot be empty.", "error");
      return;
    }
    if (newLabel === originalItem?.label) {
      cancelInlineRename();
      return;
    }
    const result = await renameItem(inlineRenameId, newLabel);
    if (result.success) {
      cancelInlineRename();
      showMessage("Item renamed successfully.", "success", 3000);
    } else {
      showMessage(result.error || "Rename failed.", "error");
    }
  }, [
    inlineRenameId,
    inlineRenameValue,
    renameItem,
    cancelInlineRename,
    findItemByIdFromTree,
    showMessage,
  ]);
  const openAddDialog = useCallback(
    (type, parent) => {
      setNewItemType(type);
      setParentItemForAdd(parent);
      setNewItemLabel("");
      setAddDialogErrorMessage("");
      showMessage("", "error");
      setAddDialogOpen(true);
      setContextMenu((m) => ({ ...m, visible: false }));
      setTopMenuOpen(false);
    },
    [showMessage, setContextMenu]
  );
  const handleAdd = useCallback(async () => {
    const trimmedLabel = newItemLabel.trim();
    if (!trimmedLabel) {
      setAddDialogErrorMessage("Name cannot be empty.");
      return;
    }
    const parentId = parentItemForAdd?.id ?? null;
    const siblings = parentId
      ? findItemByIdFromTree(parentId)?.children || []
      : tree;
    if (
      siblings.some(
        (sibling) => sibling.label.toLowerCase() === trimmedLabel.toLowerCase()
      )
    ) {
      setAddDialogErrorMessage(
        `An item named "${trimmedLabel}" already exists here.`
      );
      return;
    }
    const newItemData = {
      type: newItemType,
      label: trimmedLabel,
      ...(newItemType === "task" ? { completed: false, content: "" } : {}),
      ...(newItemType === "note" ? { content: "" } : {}),
    };
    const result = await addItem(newItemData, parentId);
    if (result.success) {
      setAddDialogOpen(false);
      setNewItemLabel("");
      setParentItemForAdd(null);
      setAddDialogErrorMessage("");
      showMessage(
        `${newItemType.charAt(0).toUpperCase() + newItemType.slice(1)} added.`,
        "success",
        3000
      );
      if (result.item?.id) {
        selectItemById(result.item.id);
        if (result.item.type === "folder" && settings.autoExpandNewFolders) {
          expandFolderPath(result.item.id);
        }
        if (parentId && settings.autoExpandNewFolders) {
          expandFolderPath(parentId);
        }
      }
    } else {
      setAddDialogErrorMessage(result.error || "Add operation failed.");
    }
  }, [
    newItemLabel,
    newItemType,
    parentItemForAdd,
    addItem,
    showMessage,
    selectItemById,
    settings.autoExpandNewFolders,
    expandFolderPath,
    tree,
    findItemByIdFromTree,
  ]);
  const handleToggleTask = useCallback(
    async (id, currentCompletedStatus) => {
      const result = await updateTask(id, {
        completed: !currentCompletedStatus,
      });
      if (!result.success) {
        showMessage(result.error || "Failed to update task status.", "error");
      } else {
        showMessage("Task status updated.", "success", 2000);
      }
    },
    [updateTask, showMessage]
  );
  const handleDragEnd = useCallback(() => setDraggedId(null), [setDraggedId]);
  const openExportDialog = useCallback(
    (context) => {
      setExportDialogState({ isOpen: true, context });
      setContextMenu((m) => ({ ...m, visible: false }));
      setTopMenuOpen(false);
    },
    [setContextMenu]
  ); // Added setContextMenu dependency
  const openImportDialog = useCallback(
    (context) => {
      setImportDialogState({ isOpen: true, context });
      setContextMenu((m) => ({ ...m, visible: false }));
      setTopMenuOpen(false);
    },
    [setContextMenu]
  ); // Added setContextMenu dependency
  const handleFileImport = useCallback(
    async (file, importTargetOption) => {
      showMessage("", "error");
      const result = await handleImportFromHook(file, importTargetOption);
      if (result && result.success) {
        showMessage(result.message || "Import successful!", "success");
        setTimeout(() => {
          setImportDialogState({ isOpen: false, context: null });
        }, 1500);
        return {
          success: true,
          message: result.message || "Import successful!",
        };
      } else {
        showMessage(result?.error || "Import operation failed.", "error");
        return {
          success: false,
          error: result?.error || "Import operation failed.",
        };
      }
    },
    [handleImportFromHook, setImportDialogState, showMessage]
  );
  const handlePasteWrapper = useCallback(
    async (targetId) => {
      const result = await pasteItem(targetId);
      if (!result.success) {
        showMessage(result.error || "Paste operation failed.", "error");
      } else {
        showMessage("Item pasted.", "success", 3000);
      }
    },
    [pasteItem, showMessage]
  );
  const handleDeleteConfirm = useCallback(
    async (itemIdToDelete) => {
      if (itemIdToDelete) {
        const result = await deleteItem(itemIdToDelete);
        if (!result.success) {
          showMessage(result.error || "Delete operation failed.", "error");
        } else {
          showMessage("Item deleted.", "success", 3000);
        }
      }
      setContextMenu((m) => ({ ...m, visible: false }));
    },
    [deleteItem, showMessage, setContextMenu]
  );
  const handleShowItemMenu = useCallback(
    (item, buttonElement) => {
      if (!item || !buttonElement) return;
      const rect = buttonElement.getBoundingClientRect();
      let x = rect.left,
        y = rect.bottom + 2;
      const menuWidth = 190;
      const menuHeight = item.type === "folder" ? 350 : 280;
      if (x + menuWidth > window.innerWidth - 10)
        x = window.innerWidth - menuWidth - 10;
      if (x < 10) x = 10;
      if (y + menuHeight > window.innerHeight - 10)
        y = rect.top - menuHeight - 2;
      if (y < 10) y = 10;
      selectItemById(item.id);
      setContextMenu({ visible: true, x, y, item, isEmptyArea: false });
    },
    [selectItemById, setContextMenu]
  );
  const handleNativeContextMenu = useCallback(
    (event, item) => {
      if (draggedId || inlineRenameId) {
        event.preventDefault();
        return;
      }
      event.preventDefault();
      event.stopPropagation();
      selectItemById(item?.id ?? null);
      let x = event.clientX,
        y = event.clientY;
      const menuWidth = 190;
      const menuHeight = item ? (item.type === "folder" ? 350 : 280) : 180;
      if (x + menuWidth > window.innerWidth - 10)
        x = window.innerWidth - menuWidth - 10;
      if (x < 10) x = 10;
      if (y + menuHeight > window.innerHeight - 10)
        y = window.innerHeight - menuHeight - 10;
      if (y < 10) y = 10;
      setContextMenu({ visible: true, x, y, item, isEmptyArea: !item });
    },
    [draggedId, inlineRenameId, selectItemById, setContextMenu]
  );
  useEffect(() => {
    /* Global Keydown for Undo/Redo, Search Toggle */ const handler = (e) => {
      const activeElement = document.activeElement;
      const isInputFocused =
        activeElement &&
        (activeElement.tagName === "INPUT" ||
          activeElement.tagName === "TEXTAREA" ||
          activeElement.isContentEditable);
      const isRenameInputActive =
        !!inlineRenameId &&
        activeElement?.closest(`li[data-item-id="${inlineRenameId}"] input`) ===
          activeElement;
      if (
        isInputFocused &&
        !isRenameInputActive &&
        !activeElement.classList.contains("editor-pane") &&
        activeElement.id !== "tree-navigation-area" &&
        activeElement.id !== "global-search-input"
      ) {
        if (
          (e.ctrlKey || e.metaKey) &&
          (e.key.toLowerCase() === "z" || e.key.toLowerCase() === "y")
        ) {
          return;
        }
      }
      if (
        (e.ctrlKey || e.metaKey) &&
        e.key.toLowerCase() === "z" &&
        !e.shiftKey
      ) {
        if (isRenameInputActive) {
          return;
        }
        e.preventDefault();
        if (canUndoTree) undoTreeChange();
      } else if (
        (e.ctrlKey || e.metaKey) &&
        (e.key.toLowerCase() === "y" ||
          (e.shiftKey && e.key.toLowerCase() === "z"))
      ) {
        if (isRenameInputActive) {
          return;
        }
        e.preventDefault();
        if (canRedoTree) redoTreeChange();
      } else if (
        (e.ctrlKey || e.metaKey) &&
        e.shiftKey &&
        e.key.toUpperCase() === "F"
      ) {
        if (isInputFocused && activeElement.id === "global-search-input")
          return;
        e.preventDefault();
        setSearchSheetOpen((s) => !s);
      }
    };
    window.addEventListener("keydown", handler);
    return () => window.removeEventListener("keydown", handler);
  }, [
    canUndoTree,
    undoTreeChange,
    canRedoTree,
    redoTreeChange,
    inlineRenameId,
  ]);
  useEffect(() => {
    /* Global Keydown for Tree Item Operations */ const handleGlobalTreeOpsKeyDown =
      async (e) => {
        const activeEl = document.activeElement;
        const isRenameActive =
          !!inlineRenameId &&
          activeEl?.closest(`li[data-item-id="${inlineRenameId}"] input`) ===
            activeEl;
        if (isRenameActive && (e.key === "Enter" || e.key === "Escape")) {
          return;
        }
        const isStandardInputFocused =
          activeEl &&
          (activeEl.tagName === "INPUT" || activeEl.tagName === "TEXTAREA") &&
          activeEl.id !== "tree-navigation-area" &&
          !isRenameActive;
        const isContentEditorFocused =
          activeEl &&
          (activeEl.classList.contains("editor-pane") ||
            activeEl.closest(".editor-pane"));
        const isTreeAreaLikelyFocused = () => {
          const treeNav = document.querySelector(
            'nav[aria-label="Notes and Tasks Tree"]'
          );
          return (
            treeNav &&
            (treeNav === activeEl ||
              treeNav.contains(activeEl) ||
              document.body === activeEl)
          );
        };
        if (isStandardInputFocused || isContentEditorFocused) {
          if (
            (e.ctrlKey || e.metaKey) &&
            ["c", "x", "v"].includes(e.key.toLowerCase())
          )
            return;
          if (e.key === "F2" && isContentEditorFocused && !selectedItemId)
            return;
          if (e.key === "F2" && isStandardInputFocused) return;
          if (
            (e.key === "Delete" || e.key === "Backspace") &&
            !isTreeAreaLikelyFocused()
          )
            return;
        }
        if (
          e.key === "F2" &&
          selectedItemId &&
          !isRenameActive &&
          (!isContentEditorFocused || isTreeAreaLikelyFocused())
        ) {
          if (
            isTreeAreaLikelyFocused() ||
            (isContentEditorFocused && selectedItemId)
          ) {
            e.preventDefault();
            const item = findItemByIdFromTree(selectedItemId);
            if (item) startInlineRename(item);
          }
        } else if (
          (e.ctrlKey || e.metaKey) &&
          e.key.toLowerCase() === "c" &&
          selectedItemId &&
          !isRenameActive &&
          !isContentEditorFocused
        ) {
          e.preventDefault();
          copyItem(selectedItemId);
          showMessage("Item copied.", "success", 2000);
        } else if (
          (e.ctrlKey || e.metaKey) &&
          e.key.toLowerCase() === "x" &&
          selectedItemId &&
          !isRenameActive &&
          !isContentEditorFocused
        ) {
          e.preventDefault();
          cutItem(selectedItemId);
          showMessage("Item cut.", "success", 2000);
        } else if (
          (e.ctrlKey || e.metaKey) &&
          e.key.toLowerCase() === "v" &&
          clipboardItem &&
          !isRenameActive &&
          !isContentEditorFocused
        ) {
          e.preventDefault();
          const currentItem = findItemByIdFromTree(selectedItemId);
          const targetIdForPaste =
            currentItem?.type === "folder"
              ? selectedItemId
              : findParentAndSiblingsFromTree(selectedItemId)?.parent?.id ??
                null;
          await handlePasteWrapper(targetIdForPaste);
        } else if (
          (e.key === "Delete" ||
            (e.key === "Backspace" && (e.metaKey || e.ctrlKey))) &&
          selectedItemId &&
          !isRenameActive
        ) {
          if (
            isContentEditorFocused ||
            (isStandardInputFocused && activeEl.id !== "tree-navigation-area")
          )
            return;
          if (
            activeEl.id === "global-search-input" &&
            ((e.key === "Backspace" && searchQuery !== "") ||
              e.key === "Delete")
          )
            return;
          if (isTreeAreaLikelyFocused() || document.body === activeEl) {
            e.preventDefault();
            const item = findItemByIdFromTree(selectedItemId);
            if (
              item &&
              window.confirm(`Delete "${item.label}"? This cannot be undone.`)
            ) {
              await handleDeleteConfirm(selectedItemId);
            }
          }
        }
      };
    window.addEventListener("keydown", handleGlobalTreeOpsKeyDown);
    return () =>
      window.removeEventListener("keydown", handleGlobalTreeOpsKeyDown);
  }, [
    selectedItemId,
    inlineRenameId,
    tree,
    clipboardItem,
    searchQuery,
    copyItem,
    cutItem,
    pasteItem,
    deleteItem,
    startInlineRename,
    handlePasteWrapper,
    showMessage,
    findItemByIdFromTree,
    findParentAndSiblingsFromTree,
    handleDeleteConfirm,
    setContextMenu /* Added setContextMenu dependency for completeness */,
  ]);
  useEffect(() => {
    /* Search Results processing */ if (searchQuery && searchSheetOpen) {
      const currentSearchOpts = { ...searchOptions, useRegex: false };
      const rawHits = searchItems(searchQuery, currentSearchOpts);
      const CONTEXT_CHARS_BEFORE = 20,
        CONTEXT_CHARS_AFTER = 20,
        MAX_SNIPPET_LENGTH = 80;
      let resultCounter = 0;
      const processedResults = rawHits
        .map((hit) => {
          if (!hit || !hit.id) return null;
          const pathString = getItemPath(hit.id) || "";
          const originalLabel =
            typeof hit.label === "string"
              ? hit.label
              : typeof hit.title === "string"
              ? hit.title
              : "";
          const originalContentHtml =
            typeof hit.content === "string" ? hit.content : "";
          const plainTextContent =
            htmlToPlainTextWithNewlines(originalContentHtml);
          let displaySnippetText = "";
          let hlStartIndex = -1;
          let hlEndIndex = -1;
          let matchSrc = "";
          let pathLabelHlDetails = {
            start: -1,
            end: -1,
            originalMatchInLabel: "",
          };
          const labelMatchInfo = matchText(
            originalLabel,
            searchQuery,
            currentSearchOpts
          );
          if (labelMatchInfo) {
            matchSrc = "label";
            displaySnippetText = originalLabel;
            hlStartIndex = labelMatchInfo.startIndex;
            hlEndIndex =
              labelMatchInfo.startIndex + labelMatchInfo.matchedString.length;
            pathLabelHlDetails = {
              start: labelMatchInfo.startIndex,
              end: hlEndIndex,
              originalMatchInLabel: labelMatchInfo.matchedString,
            };
          }
          if (
            (hit.type === "note" || hit.type === "task") &&
            plainTextContent
          ) {
            const contentMatchInfo = matchText(
              plainTextContent,
              searchQuery,
              currentSearchOpts
            );
            if (contentMatchInfo) {
              if (matchSrc === "label") {
                matchSrc = "label & content";
              } else {
                matchSrc = "content";
                const { matchedString, startIndex: siInPlainText } =
                  contentMatchInfo;
                let snipStart = Math.max(
                  0,
                  siInPlainText - CONTEXT_CHARS_BEFORE
                );
                let snipEnd = Math.min(
                  plainTextContent.length,
                  siInPlainText + matchedString.length + CONTEXT_CHARS_AFTER
                );
                displaySnippetText = plainTextContent.substring(
                  snipStart,
                  snipEnd
                );
                hlStartIndex = siInPlainText - snipStart;
                hlEndIndex = hlStartIndex + matchedString.length;
                let preEll = snipStart > 0;
                let sufEll = snipEnd < plainTextContent.length;
                if (displaySnippetText.length > MAX_SNIPPET_LENGTH) {
                  const overflow =
                    displaySnippetText.length - MAX_SNIPPET_LENGTH;
                  let reduceStart = Math.floor(overflow / 2);
                  let reduceEnd = overflow - reduceStart;
                  if (hlStartIndex < reduceStart) {
                    displaySnippetText = displaySnippetText.substring(
                      0,
                      MAX_SNIPPET_LENGTH
                    );
                    sufEll = true;
                  } else if (
                    hlEndIndex >
                    displaySnippetText.length - reduceEnd
                  ) {
                    displaySnippetText = displaySnippetText.substring(overflow);
                    hlStartIndex -= overflow;
                    hlEndIndex -= overflow;
                    preEll = true;
                  } else {
                    displaySnippetText = displaySnippetText.substring(
                      reduceStart,
                      displaySnippetText.length - reduceEnd
                    );
                    hlStartIndex -= reduceStart;
                    hlEndIndex -= reduceStart;
                    preEll = true;
                    sufEll = true;
                  }
                  hlStartIndex = Math.max(0, hlStartIndex);
                  hlEndIndex = Math.min(displaySnippetText.length, hlEndIndex);
                  if (hlStartIndex >= hlEndIndex) {
                    hlStartIndex = -1;
                    hlEndIndex = -1;
                  }
                }
                if (preEll && !displaySnippetText.startsWith("..."))
                  displaySnippetText = "..." + displaySnippetText;
                if (sufEll && !displaySnippetText.endsWith("..."))
                  displaySnippetText = displaySnippetText + "...";
              }
            }
          }
          if (!matchSrc) {
            displaySnippetText =
              originalLabel.substring(0, MAX_SNIPPET_LENGTH) +
              (originalLabel.length > MAX_SNIPPET_LENGTH ? "..." : "");
            matchSrc = "unknown";
          }
          resultCounter++;
          return {
            id: `${hit.id}-${matchSrc}-${resultCounter}`,
            originalId: hit.id,
            ...hit,
            path: pathString,
            displaySnippetText,
            highlightStartIndexInSnippet: hlStartIndex,
            highlightEndIndexInSnippet: hlEndIndex,
            matchSource: matchSrc,
            pathLabelHighlight:
              pathLabelHlDetails.start !== -1 ? pathLabelHlDetails : undefined,
          };
        })
        .filter(Boolean);
      setSearchResults(
        processedResults.filter(
          (r) => r && r.matchSource && r.matchSource !== "unknown"
        )
      );
    } else {
      setSearchResults([]);
    }
  }, [
    searchQuery,
    searchOptions,
    searchItems,
    getItemPath,
    searchSheetOpen,
    tree /* matchText removed as direct dep */,
  ]);
  useEffect(() => {
    /* Top Menu Outside Click Handler */ const handleClickOutside = (e) => {
      if (topMenuRef.current && !topMenuRef.current.contains(e.target)) {
        setTopMenuOpen(false);
      }
    };
    document.addEventListener("mousedown", handleClickOutside);
    return () => document.removeEventListener("mousedown", handleClickOutside);
  }, []);

  // -- Render logic --
  if (!isAuthCheckComplete)
    return (
      <div className="flex items-center justify-center min-h-screen bg-zinc-100 dark:bg-zinc-900 text-zinc-100">
        Loading application...
      </div>
    );
  // Use the state variables currentView and setCurrentView for rendering logic
  if (currentView === "login")
    return (
      <Login
        onLoginSuccess={handleLoginSuccess}
        onSwitchToRegister={() => setCurrentView("register")}
      />
    );
  if (currentView === "register")
    return (
      <Register
        onRegisterSuccess={() => setCurrentView("login")}
        onSwitchToLogin={() => setCurrentView("login")}
      />
    );

  return (
    <div className="relative flex flex-col h-screen bg-zinc-100 dark:bg-zinc-900 text-zinc-900 dark:text-zinc-100 overflow-hidden">
      <ErrorDisplay
        message={uiMessage}
        type={uiMessageType}
        onClose={() => setUiMessage("")}
      />
      <header
        className={`fixed top-0 left-0 right-0 z-30 bg-white dark:bg-zinc-800/95 backdrop-blur-sm shadow-sm ${APP_HEADER_HEIGHT_CLASS}`}
      >
        <div className="container mx-auto px-2 sm:px-4 flex justify-between items-center h-full">
          <h1 className="font-semibold text-lg sm:text-xl md:text-2xl whitespace-nowrap overflow-hidden text-ellipsis mr-2 text-zinc-800 dark:text-zinc-100">
            Notes & Tasks
          </h1>
          <div
            className="flex items-center space-x-0.5 sm:space-x-1 relative"
            ref={topMenuRef}
          >
            <button
              onClick={undoTreeChange}
              disabled={!canUndoTree}
              title="Undo (Ctrl+Z)"
              className={`p-2 hover:bg-zinc-200 dark:hover:bg-zinc-700 rounded-full ${
                !canUndoTree
                  ? "opacity-40 cursor-not-allowed"
                  : "text-zinc-600 dark:text-zinc-300"
              }`}
            >
              {" "}
              <Undo className="w-5 h-5" />{" "}
            </button>
            <button
              onClick={redoTreeChange}
              disabled={!canRedoTree}
              title="Redo (Ctrl+Y)"
              className={`p-2 hover:bg-zinc-200 dark:hover:bg-zinc-700 rounded-full ${
                !canRedoTree
                  ? "opacity-40 cursor-not-allowed"
                  : "text-zinc-600 dark:text-zinc-300"
              }`}
            >
              {" "}
              <Redo className="w-5 h-5" />{" "}
            </button>
            <button
              onClick={() => setSearchSheetOpen((s) => !s)}
              title="Search (Ctrl+Shift+F)"
              className={`p-2 hover:bg-zinc-200 dark:hover:bg-zinc-700 rounded-full ${
                searchSheetOpen
                  ? "bg-blue-100 dark:bg-blue-700/50 text-blue-600 dark:text-blue-300"
                  : "text-zinc-600 dark:text-zinc-300"
              }`}
            >
              {" "}
              <SearchIcon className="w-5 h-5" />{" "}
            </button>
            <button
              onClick={() => setSettingsDialogOpen(true)}
              className="p-2 text-zinc-600 dark:text-zinc-300 hover:bg-zinc-200 dark:hover:bg-zinc-700 rounded-full"
              title="Settings"
            >
              {" "}
              <SettingsIcon className="w-5 h-5" />{" "}
            </button>
            <button
              onClick={() => setTopMenuOpen((p) => !p)}
              className="p-2 text-zinc-600 dark:text-zinc-300 hover:bg-zinc-200 dark:hover:bg-zinc-700 rounded-full"
              title="More actions"
            >
              {" "}
              <EllipsisVertical className="w-5 h-5" />{" "}
            </button>
            {topMenuOpen && (
              <div className="absolute top-full right-0 mt-2 w-56 bg-white dark:bg-zinc-800 border border-zinc-200 dark:border-zinc-700 rounded-md shadow-lg z-40 py-1">
                <button
                  onClick={() => {
                    openAddDialog("folder", null);
                    setTopMenuOpen(false);
                  }}
                  className="flex items-center gap-3 w-full px-4 py-2.5 text-sm text-left text-zinc-700 dark:text-zinc-200 hover:bg-zinc-100 dark:hover:bg-zinc-700"
                >
                  {" "}
                  <FileJson className="w-4 h-4 opacity-70" /> Add Root Folder{" "}
                </button>
                <button
                  onClick={() => {
                    openExportDialog("tree");
                    setTopMenuOpen(false);
                  }}
                  className="flex items-center gap-3 w-full px-4 py-2.5 text-sm text-left text-zinc-700 dark:text-zinc-200 hover:bg-zinc-100 dark:hover:bg-zinc-700"
                >
                  {" "}
                  <FileJson className="w-4 h-4 opacity-70" /> Export Full
                  Tree...{" "}
                </button>
                <button
                  onClick={() => {
                    openImportDialog("tree");
                    setTopMenuOpen(false);
                  }}
                  className="flex items-center gap-3 w-full px-4 py-2.5 text-sm text-left text-zinc-700 dark:text-zinc-200 hover:bg-zinc-100 dark:hover:bg-zinc-700"
                >
                  {" "}
                  <FileJson className="w-4 h-4 opacity-70" /> Import Full
                  Tree...{" "}
                </button>
                <div className="my-1 h-px bg-zinc-200 dark:bg-zinc-700"></div>
                <button
                  onClick={() => {
                    setAboutDialogOpen(true);
                    setTopMenuOpen(false);
                  }}
                  className="flex items-center gap-3 w-full px-4 py-2.5 text-sm text-left text-zinc-700 dark:text-zinc-200 hover:bg-zinc-100 dark:hover:bg-zinc-700"
                >
                  {" "}
                  <Info className="w-4 h-4 opacity-70" /> About{" "}
                </button>
                <button
                  onClick={() => {
                    handleLogout();
                    setTopMenuOpen(false);
                  }}
                  className="flex items-center gap-3 w-full px-4 py-2.5 text-sm text-left text-red-600 dark:text-red-400 hover:bg-red-50 dark:hover:bg-red-700/30"
                >
                  {" "}
                  <LogOut className="w-4 h-4 opacity-70" /> Logout{" "}
                </button>
              </div>
            )}
          </div>
        </div>
      </header>
      <main className={`flex-1 flex min-h-0 pt-14 sm:pt-12`}>
        <PanelGroup direction="horizontal" className="flex-1">
          <Panel
            id="tree-panel"
            order={0}
            defaultSize={30}
            minSize={20}
            maxSize={60}
            className="flex flex-col !overflow-hidden bg-zinc-50 dark:bg-zinc-800/30 border-r border-zinc-200 dark:border-zinc-700/50"
          >
            <div
              className="flex-grow overflow-auto"
              id="tree-navigation-area"
              tabIndex={-1}
            >
              <Tree
                items={tree || []}
                selectedItemId={selectedItemId}
                onSelect={selectItemById}
                inlineRenameId={inlineRenameId}
                inlineRenameValue={inlineRenameValue}
                setInlineRenameValue={setInlineRenameValue}
                onAttemptRename={handleAttemptRename}
                cancelInlineRename={cancelInlineRename}
                expandedFolders={expandedFolders}
                onToggleExpand={toggleFolderExpand}
                onToggleTask={handleToggleTask}
                draggedId={draggedId}
                onDragStart={(e, id) => {
                  if (inlineRenameId) {
                    e.preventDefault();
                    return;
                  }
                  try {
                    if (e.dataTransfer) {
                      e.dataTransfer.setData("text/plain", id);
                      e.dataTransfer.effectAllowed = "move";
                    }
                    setDraggedId(id);
                  } catch (err) {
                    console.error("Drag error:", err);
                    showMessage("Drag operation failed.", "error");
                  }
                }}
                onDrop={(targetId) => handleDrop(targetId, draggedId)}
                onDragEnd={handleDragEnd}
                onNativeContextMenu={handleNativeContextMenu}
                onShowItemMenu={handleShowItemMenu}
                onRename={startInlineRename}
                uiError={uiMessage}
                setUiError={(msg) => showMessage(msg, "error")}
              />
            </div>
          </Panel>
          <PanelResizeHandle className="w-1.5 bg-zinc-200 dark:bg-zinc-700 hover:bg-blue-500 data-[resize-handle-active=true]:bg-blue-600 transition-colors cursor-col-resize z-20 flex-shrink-0" />
          <Panel
            id="content-panel"
            order={1}
            defaultSize={70}
            minSize={30}
            className="flex flex-col !overflow-hidden bg-white dark:bg-zinc-900"
          >
            <div className="flex-grow overflow-auto h-full">
              {selectedItem ? (
                selectedItem.type === "folder" ? (
                  <div className="p-3 sm:p-4">
                    <h2 className="text-lg sm:text-xl font-semibold mb-3 text-zinc-800 dark:text-zinc-100 break-words">
                      {" "}
                      {selectedItem.label}{" "}
                    </h2>
                    <FolderContents
                      folder={selectedItem}
                      onSelect={selectItemById}
                      handleDragStart={(e, id) => {
                        if (inlineRenameId) e.preventDefault();
                        else setDraggedId(id);
                      }}
                      handleDragEnter={(e, id) => {}}
                      handleDragOver={(e) => e.preventDefault()}
                      handleDragLeave={(e) => {}}
                      handleDrop={(e, targetItemId) => {
                        if (draggedId && targetItemId === selectedItem.id) {
                          handleDrop(targetItemId, draggedId);
                        }
                      }}
                      handleDragEnd={handleDragEnd}
                      draggedId={draggedId}
                      onToggleExpand={toggleFolderExpand}
                      expandedItems={expandedFolders}
                      onShowItemMenu={handleShowItemMenu}
                    />
                  </div>
                ) : selectedItem.type === "note" ||
                  selectedItem.type === "task" ? (
                  <ContentEditor
                    key={selectedItemId}
                    item={selectedItem}
                    defaultFontFamily={settings.editorFontFamily}
                    defaultFontSize={settings.editorFontSize}
                    onSaveContent={
                      selectedItem.type === "task"
                        ? async (id, content) => {
                            const result = await updateTask(id, { content });
                            if (!result.success)
                              showMessage(
                                result.error || "Failed to save task content.",
                                "error"
                              );
                          }
                        : async (id, content) => {
                            const result = await updateNoteContent(id, content);
                            if (!result.success)
                              showMessage(
                                result.error || "Failed to save note content.",
                                "error"
                              );
                          }
                    }
                  />
                ) : null
              ) : (
                <div className="flex items-center justify-center h-full text-zinc-500 dark:text-zinc-400 p-4 text-center">
                  {" "}
                  Select or create an item to view or edit its content.{" "}
                </div>
              )}
            </div>
          </Panel>
        </PanelGroup>
      </main>
      <Sheet
        isOpen={searchSheetOpen}
        onClose={() => setSearchSheetOpen(false)}
        snapPoints={[0.85, 0.6, 0.3]}
        initialSnap={1}
        className="z-40"
      >
        <Sheet.Container className="!bg-zinc-50 dark:!bg-zinc-900 !rounded-t-xl">
          <Sheet.Header>
            <div className="flex justify-center py-2.5 cursor-grab">
              <div className="w-10 h-1.5 bg-zinc-300 dark:bg-zinc-600 rounded-full"></div>
            </div>
          </Sheet.Header>
          <Sheet.Content className="!pb-0">
            <div className="overflow-y-auto h-full">
              <SearchResultsPane
                headerHeightClass={APP_HEADER_HEIGHT_CLASS}
                query={searchQuery}
                onQueryChange={setSearchQuery}
                results={searchResults}
                onSelectResult={(item) => {
                  if (item.originalId) {
                    expandFolderPath(item.originalId);
                    selectItemById(item.originalId);
                    setSearchSheetOpen(false);
                    setTimeout(() => {
                      document
                        .querySelector(`li[data-item-id="${item.originalId}"]`)
                        ?.scrollIntoView({
                          behavior: "smooth",
                          block: "center",
                        });
                    }, 100);
                  }
                }}
                onClose={() => setSearchSheetOpen(false)}
                opts={searchOptions}
                setOpts={setSearchOptions}
              />
            </div>
          </Sheet.Content>
        </Sheet.Container>
        <Sheet.Backdrop onTap={() => setSearchSheetOpen(false)} />
      </Sheet>
      {contextMenu.visible && (
        <ContextMenu
          visible={contextMenu.visible}
          x={contextMenu.x}
          y={contextMenu.y}
          item={contextMenu.item}
          isEmptyArea={contextMenu.isEmptyArea}
          clipboardItem={clipboardItem}
          onAddRootFolder={() => openAddDialog("folder", null)}
          onAddFolder={() =>
            contextMenu.item && openAddDialog("folder", contextMenu.item)
          }
          onAddNote={() =>
            contextMenu.item && openAddDialog("note", contextMenu.item)
          }
          onAddTask={() =>
            contextMenu.item && openAddDialog("task", contextMenu.item)
          }
          onRename={() =>
            contextMenu.item && startInlineRename(contextMenu.item)
          }
          onDelete={() => {
            if (contextMenu.item) {
              if (
                window.confirm(
                  `Delete "${contextMenu.item.label}"? This cannot be undone.`
                )
              ) {
                handleDeleteConfirm(contextMenu.item.id);
              } else {
                setContextMenu((m) => ({ ...m, visible: false }));
              }
            } else {
              setContextMenu((m) => ({ ...m, visible: false }));
            }
          }}
          onDuplicate={async () => {
            if (contextMenu.item) {
              const result = await duplicateItem(contextMenu.item.id);
              if (!result.success)
                showMessage(result.error || "Duplicate failed", "error");
              else showMessage("Item duplicated.", "success", 3000);
            }
          }}
          onClose={() => setContextMenu((m) => ({ ...m, visible: false }))}
          onCopy={() => {
            if (contextMenu.item) {
              copyItem(contextMenu.item.id);
              showMessage("Item copied.", "success", 2000);
            }
          }}
          onCut={() => {
            if (contextMenu.item) {
              cutItem(contextMenu.item.id);
              showMessage("Item cut.", "success", 2000);
            }
          }}
          onPaste={async () => {
            const tid = contextMenu.isEmptyArea
              ? null
              : contextMenu.item?.type === "folder"
              ? contextMenu.item.id
              : findParentAndSiblingsFromTree(contextMenu.item?.id)?.parent
                  ?.id ?? null;
            await handlePasteWrapper(tid);
          }}
          onExportItem={() => openExportDialog("item")}
          onImportItem={() => openImportDialog("item")}
          onExportTree={() => openExportDialog("tree")}
          onImportTree={() => openImportDialog("tree")}
        />
      )}
      <AddDialog
        isOpen={addDialogOpen}
        newItemType={newItemType}
        newItemLabel={newItemLabel}
        errorMessage={addDialogErrorMessage}
        onLabelChange={(e) => {
          setNewItemLabel(e.target.value);
          if (addDialogOpen) setAddDialogErrorMessage("");
        }}
        onAdd={handleAdd}
        onCancel={() => {
          setAddDialogOpen(false);
          setAddDialogErrorMessage("");
          showMessage("", "error");
        }}
      />
      <AboutDialog
        isOpen={aboutDialogOpen}
        onClose={() => setAboutDialogOpen(false)}
      />
      <ExportDialog
        isOpen={exportDialogState.isOpen}
        context={exportDialogState.context}
        defaultFormat={settings.defaultExportFormat}
        onClose={() => setExportDialogState({ isOpen: false, context: null })}
        onExport={handleExport}
      />
      <ImportDialog
        isOpen={importDialogState.isOpen}
        context={importDialogState.context}
        selectedItem={selectedItem}
        onClose={() => {
          setImportDialogState({ isOpen: false, context: null });
          showMessage("", "success");
        }}
        onImport={handleFileImport}
      />
      <SettingsDialog
        isOpen={settingsDialogOpen}
        onClose={() => setSettingsDialogOpen(false)}
      />
    </div>
  );
};
export default App;


--- src\index.css ---
@tailwind base;
@tailwind components;
@tailwind utilities;

--- src\main.jsx ---
// src/main.jsx
import React from "react";
import ReactDOM from "react-dom/client";
import App from "./App.jsx";
import { SettingsProvider } from "./contexts/SettingsContext"; // <-- Import Provider
import "./styles/index.css";

ReactDOM.createRoot(document.getElementById("root")).render(
  <React.StrictMode>
    {/* Wrap App with the SettingsProvider */}
    <SettingsProvider>
      <App />
    </SettingsProvider>
  </React.StrictMode>
);

--- src\fonts\NotoSansHebrewBase64.js ---
export const notoSansHebrewBase64 = `
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AYwBjQESAZEBLAAwAY8BrAHSAYQBtgGyAU0BTAGrAaoBQAF4ASsBqQFuAUYBVQGTARMAlwCiAKMAqACrALUAtgC7AL0AxQDGAMgAzQDOANMA3ADdAN4A4QDmAOoA8wD0APkA+gD/ARoBFgEbARABvgFTAQMBFQEfAS8BOQFLAU4BWgFeAWYBaAFqAXABdAF7AYoBkgGdAaMBrgG3AcEBwgHHAcgBzgEYARcBGQERAEIBSgEoAa0BqAEzAS4BhQFWAaABiQEyAYsBkAEmAYYBVwGUAJ0AmQCbAKEAnACgAJgApgCxAKwArgCvAMIAvgC/AMAAtADSANgA1QDWANsA1wFzANoA7gDrAOwA7QD7AOkBUgELAQQBBgEUAQkBDwEKASQBPwE6ATwBPQFjAV8BYAFhAUcBeQGCAXwBfQGIAX4BNQGHAbsBuAG5AboByQGxAcsAngEMAJoBBQCfAQ4ApAEgAKcBJQClASMAqQEwAKoBMQCyAUIAsAE+ALMBRQCtATsAtwFPALkBUQC4AVAAvAFbAMMBZADEAWUAwQFiAMcBaQDJAWsAywFtAMoBbADMAW8AzwF1ANEBdwDQAXYA2QGDANQBfwDfAZ4A4AGfAOIBpADkAaYA4wGlAOcBrwDwAb0A8gHAAO8BvADxAb8A9gHEAPwBygD9AQABzwECAdEBAQHQAOUBpwDoAbABKQEhARwBNwGhAYABswFcAVQBCAEqAbQBcQEdATgBNAGiAV0BIgEtAScBgQAUAFwAXQCQAI8AcgBYAJEASACJAHEAHgAfACEAUQBtAEoACQBBADoAQAA/ABIATgBuAIgARgAyABMAlAA8AF8AKAAkACYALQB1AFsASQBPAC4ALwBUAA8AZwA7AFUARwBkAGgAaQB7ADkARQBQAAMADAAiABAAKgB8AJIALABvAIoAFQA0ADcAFwA9ABgAQwBZAAoAGQBLABsAcwBSAFYAYABrAJYAfwCAAI0AHQAgAPgBxgD1AcMA9wHFAP4BzQFEAUMBlwGYAZYAjAAzAI4ACwCBAIIAgwCEAIUAHACGAIcACABlAGYAYgBjAAYABwAEAA0AIwARACsAfQCTAHAAiwAWADUAOABEAFoAGgBMAHQAUwBXAGEAbAB+AA4ANgBNAAUAAAAjAaoAAwABBAkAAACaBPYAAwABBAkAAQAgBNYAAwABBAkAAgAOBMgAAwABBAkAAwBCBIYAAwABBAkABAAwBFYAAwABBAkABQAaBDwAAwABBAkABgAsBBAAAwABBAkABwBEA8wAAwABBAkACAAUA7gAAwABBAkACQAUA6QAAwABBAkACgAsA3gAAwABBAkACwA+AzoAAwABBAkADAAqAxAAAwABBAkADQEiAe4AAwABBAkADgA2AbgAAwABBAkAGQAcAZwAAwABBAkBAAAMAZAAAwABBAkBAQAKAYYAAwABBAkBJgAaAWwAAwABBAkBJwB2APYAAwABBAkBKAAiANQAAwABBAkBKQAaALoAAwABBAkBKwAIALIAAwABBAkBLAAUAJ4AAwABBAkBLQAKAJQAAwABBAkBLgAOBMgAAwABBAkBLwAMAIgAAwABBAkBMAAQAHgAAwABBAkBMQAIAHAAAwABBAkBMgASAF4AAwABBAkBMwAKAFQAAwABBAkBNAAcADgAAwABBAkBNQASACYAAwABBAkBNgAaAAwAAwABBAkBNwAMAAAATgBvAHIAbQBhAGwAUwBlAG0AaQBDAG8AbgBkAGUAbgBzAGUAZABDAG8AbgBkAGUAbgBzAGUAZABFAHgAdAByAGEAQwBvAG4AZABlAG4AcwBlAGQAQgBsAGEAYwBrAEUAeAB0AHIAYQBCAG8AbABkAEIAbwBsAGQAUwBlAG0AaQBCAG8AbABkAE0AZQBkAGkAdQBtAEwAaQBnAGgAdABFAHgAdAByAGEATABpAGcAaAB0AFQAaABpAG4AaQBvAHQAYQAgAGEAZABzAGMAcgBpAHAAdABBAGMAYwBlAG4AdABlAGQAIABHAHIAZQBlAGsAIABTAEMAVABpAHQAbABpAG4AZwAgAEEAbAB0AGUAcgBuAGEAdABlAHMAIABJACAAYQBuAGQAIABKACAAZgBvAHIAIAB0AGkAdABsAGkAbgBnACAAYQBuAGQAIABhAGwAbAAgAGMAYQBwACAAcwBlAHQAdABpAG4AZwBzAGYAbABvAHIAaQBuACAAcwB5AG0AYgBvAGwAVwBpAGQAdABoAFcAZQBpAGcAaAB0AE4AbwB0AG8AUwBhAG4AcwBIAGUAYgByAGUAdwBoAHQAdABwAHMAOgAvAC8AbwBwAGUAbgBmAG8AbgB0AGwAaQBjAGUAbgBzAGUALgBvAHIAZwBUAGgAaQBzACAARgBvAG4AdAAgAFMAbwBmAHQAdwBhAHIAZQAgAGkAcwAgAGwAaQBjAGUAbgBzAGUAZAAgAHUAbgBkAGUAcgAgAHQAaABlACAAUwBJAEwAIABPAHAAZQBuACAARgBvAG4AdAAgAEwAaQBjAGUAbgBzAGUALAAgAFYAZQByAHMAaQBvAG4AIAAxAC4AMQAuACAAVABoAGkAcwAgAGwAaQBjAGUAbgBzAGUAIABpAHMAIABhAHYAYQBpAGwAYQBiAGwAZQAgAHcAaQB0AGgAIABhACAARgBBAFEAIABhAHQAOgAgAGgAdAB0AHAAcwA6AC8ALwBvAHAAZQBuAGYAbwBuAHQAbABpAGMAZQBuAHMAZQAuAG8AcgBnAGgAdAB0AHAAcwA6AC8ALwBoAGEAZgBvAG4AdABpAGEALgBjAG8AbQAvAGgAdAB0AHAAOgAvAC8AdwB3AHcALgBnAG8AbwBnAGwAZQAuAGMAbwBtAC8AZwBlAHQALwBuAG8AdABvAC8ARABlAHMAaQBnAG4AZQBkACAAYgB5ACAAQgBlAG4AIABOAGEAdABoAGEAbgBCAGUAbgAgAE4AYQB0AGgAYQBuAEcAbwBvAGcAbABlACAATABMAEMATgBvAHQAbwAgAGkAcwAgAGEAIAB0AHIAYQBkAGUAbQBhAHIAawAgAG8AZgAgAEcAbwBvAGcAbABlACAASQBuAGMALgBOAG8AdABvAFMAYQBuAHMASABlAGIAcgBlAHcALQBSAGUAZwB1AGwAYQByAFYAZQByAHMAaQBvAG4AIAAzAC4AMAAwADEATgBvAHQAbwAgAFMAYQBuAHMAIABIAGUAYgByAGUAdwAgAFIAZQBnAHUAbABhAHIAMwAuADAAMAAxADsARwBPAE8ARwA7AE4AbwB0AG8AUwBhAG4AcwBIAGUAYgByAGUAdwAtAFIAZQBnAHUAbABhAHIAUgBlAGcAdQBsAGEAcgBOAG8AdABvACAAUwBhAG4AcwAgAEgAZQBiAHIAZQB3AEMAbwBwAHkAcgBpAGcAaAB0ACAAMgAwADIANAAgAFQAaABlACAATgBvAHQAbwAgAFAAcgBvAGoAZQBjAHQAIABBAHUAdABoAG8AcgBzACAAKABoAHQAdABwAHMAOgAvAC8AZwBpAHQAaAB1AGIALgBjAG8AbQAvAG4AbwB0AG8AZgBvAG4AdABzAC8AaABlAGIAcgBlAHcAKQAAAfQAMgEEAAAAAAAAAngAJAJ4ACQCgwATAngAJAJ4ACQCOQAwAAAANwJRACYCRgAiAjwAKQI8ACkCNQApAAAANwIeACYCHgAmAAAANwAAADIAAAA3AiEAKwIhACsCrAAxAUkALAJsADACbAAwAhEAHAMaACEAugASAAAAMgAAADIBbQASAAAAMgF2ABcBdgAXAAAANAAAADQAAAA0AAAANgAAADcAAAA9AnMANQJzADUClgAsAAAANwAAADcAAAA3AUEAIQFBACEAAAA4AAAAMgIDAC0CAwAtAgMALQIKACICCgAiAAAANwAAADIBRAAiAAAAMgKUAC8ClAAvAAAAMgAAADIAAAAyAQoAAAF7ADABewAwAY0ATwAAADICDQDlAAAAMgAAADQAAAA3AlkANQJZADUCWQA1AAAAMgAAADQAAAA0AAAAMgJzAEACcwBAAAAANwAAADQCCwAoAgsAKAAAADUCgwAsAoMALAAAADcAAAA1AAAAMgMYAFQAAAA2AtoAQALaAEAC2gBAAtoAQAAAADcC2gBAAtoAQAAAADQAAAA3APYARQEOAAACrQAjAq0AIwAAADIAAAAyAnoAOQJ6ADkAAAAzAAAAMgIsACsCLAArAAAANgAA/+4AAP+VAAD/7gAA/y4CUgAwAAAANwEtACYBLQALAS0AJgJNACYCWgAmAvkAJgKiACEDHwAvAqcAHQKEAAgCpgAnA0wAJgAAADcAAAAyAScAJgEnABABMgAmAlcAJgJkACYAAAAyAAAANQAAADIBSgAqAUr/9gAAADIAAAAAAnkAJgJ5AAADQP/+AnkAAAJ5AAACeQAAAnkAAAJ5AAACeQAAAnkAAAJ5AAACeQAAAnwAXQJzADsCcwA7AnMAOwJzADsCcwA7AsQAXQLEAF0CxAAQAiYAXQImAF0CJgBdAiYAXQImAF0CJgBdAiYAXQImAF0CJgBdAsQAEAH+AF0C2AA7AtgAOwLYADsC2AA7AsUAWwLZAF0C3wAAAVYAMwFWADMBVgAKAVYAFwFWADMBVgAzAVYAGgFWADMBFP+lAl4AXQJeAF0CFwBdAhcASAIXAF0CFwBdAiEAAQN2AF0C7QBdAu0AXQLtAF0C7QBdAu0AXQMCADsDmQA7AwIAOwMCADsDAgA7AwIAOwMCADsDAgA7AwIAOwJTAF0DAgA7AmcAXQJnAF0CZwBdAiwANAIsADQCLAA0AiwANAIsADQCGQALAhkACwIZAAsCUQBdAtkAVwLZAFcC2QBXAtkAVwLZAFcC2QBXAtkAVwLZAFcC2QBXAmQAAAOlABoDpQAaA6UAGgOlABoDpQAaAk3//wI1AAACNQAAAjUAAAI1AAACNQAAAk4AIgJOACICTgAiAk4AIgIpACwCKQAsAikALAIpACwBOAAoAAD+6wIpACwDcgAsAikALAIpACwC4gA1AikALAIpACwCKQAaAkAANAIiAC8DdQAwAikALAJeAFABbwAJAg0A5QF1ABwBdQAjAT0ATAE9ABgBfQAoAAD/aQF+AGIB8QA1AfEANQGUACgAAP9cAfEANQHxADUB8QA1AOUADwAA/5QCQABNAZQAKAAA/1MA9gBFAOYAIgAA/8QDPQAwAl4ANQJeADUCZAA1AaoAOAJJAJMAAP9rAkAAMwI9ADIAvQAoAAD/ygI5ADUCOQA1AjkANQI5ADUCOQA1AjkANQI5ADUCQAA0AukARQI5ADUD6AAnAfQAJwI5ADUCQAAzAksANAJAACYA+ABFAPgARgFGAA8CQABAAkAAFgJeADUCXgA1Al4ANQJeADUCdABQATgAKAAA/hgCQAA0AfMAHgHzAB4BIAAeASAAHgJhAFECZQAKAcoAKAAA/4IA+wBIAPsAPgD7/90A+//qAPsAUQD7AAoA+//sAPsAEgD7/84A+//OAhMAUQITAFEA+wBSAPsAPQD7AFIA+wBBAkAANAEeAAEDjABRAAD/bQFBACECQABGAmEAUQJhAFECYQBRAmEAUQJAAC4CYQBRAowAGAJWADUCVgA1AlYANQJWADUDzAA1APUAKAAA/60CVgA1AlYANQJAAE8BXgAjAW8AIAJhADUCVgA1AfT//QJeAFICiwBOASYAKAEmACEDUwAsAPYARQD2AEUCQAAzAl4AMwHAABgBwAAhAY0ARAGsACEBYQASAWEAEQCtABIArQARAPIAIQDZAEQBmgBSAZoAUgGaADIDPQAwATAAKAAA/4wB4AApAeAAKQHgACkB4AApAeAAKQH/AD4A+QAiAkAAMwJAADcBbwAKAkAALQF0ABABdAAQAXQAEAJeAFICQAAqAbUAKAAA/gQC0AAGAkAAMAJhAEwCYQBMAmEATAJhAEwCYQBMAmEATAJhAEwBsP/+AmEATAJhAEwB8gAAAwEADwMBAA8DAQAPAwEADwMBAA8CGAASAfAAAAHwAAAB8AAAAfAAAAJAABEB8AAAAdsAIwHbACMB2wAjAdsAIwJAADQB6QC4AekAtwF1ACgAAgAAAAAAAP+cADIAAAAAAAAAAAAAAAAAAAAAAAAAAAHWAAABAgEDAQQBBQEGAQcBCAEJAQoBCwEMAQ0BDgEPARABEQESARMBFAEVARYBFwEYARkBGgEbARwBHQEeAR8BIAEhASIBIwEkASUBJgEnASgBKQEqASsBLAEtAS4BLwEwABABMQEyATMBNAE1ATYBNwE4ATkBOgE7ATwBPQE+AT8BQAFBAUIBQwFEAUUBRgFHAUgBSQFKAUsBTAFNAU4BTwFQAVEBUgFTAVQBVQFWAVcBWAFZAVoBWwFcAV0BXgFfAWABYQFiAWMBZAFlAWYBZwFoAWkAAwFqAWsBbAFtAW4BbwFwAXEBcgFzAXQBdQF2AXcBeAF5AXoBewF8AX0BfgF/AYABgQGCAYMBhAGFAYYBhwGIAYkBigGLAYwBjQGOAY8BkAGRAZIBkwGUAZUAJACQAMkBlgDHAGIArQGXAZgAYwCuACUAJgD9AP8AZAGZACcBmgGbACgAZQGcAMgAygGdAMsBngGfAOkAKQAqAPgBoAGhAaIAKwGjACwAzADNAM4A+gDPAaQBpQAtAC4BpgAvAacBqAGpAOIAMAAxAaoBqwGsAGYAMgCwANAA0QBnANMBrQCRAK8AMwA0ADUBrgGvADYBsADkAPsBsQA3AbIBswDtADgA1ADVAGgA1gG0AbUBtgG3ADkAOgG4AbkBugG7ADsAPADrAbwAuwG9AD0BvgDmAb8ARABpAcAAawCNAcEAbACgAGoBwgAJAcMAbgBBAGEADQAjAG0ARQA/AF8AXgBgAD4AQADbAcQAhwBGAP4A4QHFAQAAbwHGAN4BxwCEANgByAAdAA8ByQCLAEcBygEBAIMAjgHLALgABwDcAcwASABwAc0AcgBzAc4AcQAbAKsBzwCzALIB0AAgAOoB0QAEAKMASQAYABcASgD5AdIB0wCJAEMB1AAhAKkAqgC+AL8ASwHVAN8B1gBMAHQAdgB3ANcAdQHXAdgATQHZAE4B2gBPAdsB3AHdAB8A4wBQAd4A7wDwAFEB3wHgAeEAHAB4AAYAUgB5AHsAfACxAOAB4gB6AeMAFACdAJ4AoQB9AeQAUwCIAAsADAAIABEAwwAOAFQAIgCiAAUAxQC0ALUAtgC3AMQACgBVAeUB5gCKAN0B5wBWAegA5QD8AekAhgAeABoAGQASAIUAVwHqAesA7gAWANkB7ACMABUAWAB+AIAAgQB/Ae0B7gBCAe8B8ABZAFoB8QHyAfMB9ABbAFwA7AH1ALoAlgH2AF0B9wDnAfgAEwH5AfoB+wJDUgROVUxMB3VuaTA1RDAHdW5pRkIzMAd1bmlGQjRGB3VuaUZCMkUHdW5pRkIyRgd1bmlGQjI5B3VuaTA1QTIHdW5pMDVFMgd1bmlGQjIwB3VuaTA1RDEHdW5pRkIzMQd1bmlGQjRDB3VuaTA1QkMHdW5pMDVEMwd1bmlGQjMzB3VuaTA1QTcHdW5pMDVBRAd1bmkwNTkxB3VuaTA1REEHdW5pRkIzQQd1bmkwNUREB3VuaTA1REYHdW5pMDVFMwd1bmlGQjQzB3VuaTA1RTUHdW5pRkIyNgd1bmkwNUYzB3VuaTA1OUMHdW5pMDU5RAd1bmkwNUY0B3VuaTA1OUUHdW5pMDVEMgd1bmlGQjMyB3VuaTA1QjIPdW5pMDVCMjIwMEQwNUJEB3VuaTA1QjMPdW5pMDVCMzIwMEQwNUJEB3VuaTA1QjEPdW5pMDVCMTIwMEQwNUJEB3VuaTA1RDQHdW5pRkIzNAd1bmkwNUQ3B3VuaTA1QjQHdW5pMDVCOQd1bmkwNUJBB3VuaTIwMTAHdW5pMDVBQwd1bmlGQjFFB3VuaTA1REIHdW5pRkIzQgd1bmlGQjREB3VuaTA1REMHdW5pRkIzQwd1bmkwNUM1B3VuaTA1QTQHdW5pMDVCRQd1bmkwNUFGB3VuaTA1REUHdW5pRkIzRQd1bmkwNUE2B3VuaTA1QTUHdW5pMDVBMwd1bmkwMEEwB3VuaTA1RTAHdW5pRkI0MAd1bmkwNUM2B3VuaTA1QUIHdW5pMDVDMAd1bmkwNTk5B3VuaTA1QjcHdW5pMDVBMQd1bmkwNUU0B3VuaUZCNDQHdW5pRkI0RQd1bmkwNUE4B3VuaTA1QjgHdW5pMDVDNwd1bmkwNTlGB3VuaTA1RTcHdW5pRkI0Nwd1bmkwNUJCB3VuaTA1QkYHdW5pMDVFOAd1bmlGQjQ4B3VuaTA1OTcHdW5pMDVFMQd1bmlGQjQxB3VuaTA1QjYHdW5pMDU5Mgd1bmkwNTkzB3VuaTIwQUEHdW5pMDVCMAd1bmkwNUU5B3VuaUZCNDkHdW5pRkIyQwd1bmlGQjJEB3VuaTA1QzEHdW5pRkIyQQd1bmlGQjJCB3VuaTA1QkQHdW5pMDVDMgd1bmkwNUMzB3VuaTA1RUEHdW5pRkI0QQd1bmkwNUEwB3VuaTA1QTkHdW5pMDVEOAd1bmlGQjM4B3VuaTA1OUIHdW5pMDU5Ngd1bmkwNUU2B3VuaUZCNDYHdW5pMDVCNQd1bmkyMDBDB3VuaTIwMEQHdW5pMjAwRQd1bmkyMDBGB3VuaTI1Q0MHdW5pMDVDNAd1bmkwNUQ1B3VuaUZCMzUHdW5pRkI0Qgd1bmkwNUYwB3VuaTA1RjEHdW5pRkIyMQd1bmlGQjIyB3VuaUZCMjMHdW5pRkIyNAd1bmlGQjI1B3VuaUZCMjcHdW5pRkIyOAd1bmkwNUFBB3VuaTA1OUEHdW5pMDVEOQd1bmlGQjM5B3VuaUZCMUQHdW5pMDVGMgd1bmlGQjFGB3VuaTA1OTUHdW5pMDU5NAd1bmkwNTk4B3VuaTA1RDYHdW5pRkIzNgd1bmkwNUFFB3VuaTAzNEYLeW9keW9keW9kaGIGQWJyZXZlB0FtYWNyb24HQW9nb25lawpDZG90YWNjZW50BkRjYXJvbgZEY3JvYXQGRWNhcm9uCkVkb3RhY2NlbnQHRW1hY3JvbgdFb2dvbmVrB3VuaTAxMjIKR2RvdGFjY2VudAd1bmkxRTlFBEhiYXIHSW1hY3JvbgdJb2dvbmVrB3VuaTAxMzYGTGFjdXRlBkxjYXJvbgd1bmkwMTNCBk5hY3V0ZQZOY2Fyb24HdW5pMDE0NQ1PaHVuZ2FydW1sYXV0BlJhY3V0ZQZSY2Fyb24GU2FjdXRlB3VuaTAyMTgGVGNhcm9uB3VuaTAyMUENVWh1bmdhcnVtbGF1dAdVbWFjcm9uB1VvZ29uZWsFVXJpbmcGV2FjdXRlC1djaXJjdW1mbGV4CVdkaWVyZXNpcwZXZ3JhdmULWWNpcmN1bWZsZXgGWWdyYXZlBlphY3V0ZQpaZG90YWNjZW50BmFicmV2ZQlhY3V0ZWNvbWIHYW1hY3Jvbgdhb2dvbmVrB3VuaTAzMDYHdW5pMDMwQwpjZG90YWNjZW50B3VuaTAzMjcHdW5pMDMwMgd1bmkw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`;

